
import "lucy/encoding/json"
public class xxx {
	public boolValue bool
	public y string  
	public intValue int  
	public floatValue float 
	public stringValue string  
	public c map { int -> string }  
	public d map { string  -> int }  
	
	public fn toString()->(s string ){
		s = sprintf("boolValue:%b\n" , this.boolValue )		
		s += sprintf("intValue:%d\n" , this.intValue )	
		s += sprintf("stringValue:%s\n" , this.stringValue )	
		s += sprintf("floatValue:%s\n" , this.floatValue )	
	}
}

fn main(args []string) {
	x := new xxx()
	x.y = "11111111111"
	x.c = new map { int -> string }()
	x.c[1] = "hello world"
	x.c[2] = "hello world"
    x.d = { "hello world" -> 1 , "11111111111111111" -> 222 }
	x.intValue = 100
	x.floatValue = 99.9999
	x.stringValue = "hello world"
	bs,err := json.encode(x  )
	if err != null {
		print(err)
	}
	print(string(bs))
	x2 := new xxx[](2)
	for k, _:= range x2 {
		if k == 0 {
			continue  
		}
		x2[k] = new xxx()
	} 
	bs,err = json.encode(x2 , "\t")
	if err != null {
		print(err)
	}
	print(string(bs))
	print("#############################")
	y := new xxx ()
	s := `
		{
			"boolValue" : true , 
			"intValue" : 110e2 ,
			"stringValue" :"\u4e2d\u6587hello world",
			"floatValue" : 1e3 
		} 
	`
	y2 , err := json.decode([]byte(s) , y )
	if err != null {
		panic(err)
	}

	print(y2)
	s = `
		[
			1 ,2 
		]
	`
	
	arr := new byte[](0)
	
	arr2 , err := json.decode([]byte(s) ,arr )
	if err != null {
		panic(err)
	}
	if len(byte[](arr2)) != 2 {
		panic(new error("not 2"))
	}
	for v := range byte[](arr2)  {
		print(v)
	}
	
	

}


























