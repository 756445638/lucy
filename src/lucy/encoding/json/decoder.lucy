
import "java/lang/Object" 
import "java/lang/Class"
import "java/lang/Boolean"
import "java/lang/Byte"
import "java/lang/Short"
import "java/lang/Float"
import "java/lang/Integer"
import "java/lang/Double"
import "java/lang/Long"
import "java/lang/Character" 
import "java/lang/String" 
import "java/lang/reflect/Array"

enum JsonSyntaxTreeType {
	JsonSyntaxTreeTypeArray = 1  ,
	JsonSyntaxTreeTypeObject ,
	JsonSyntaxTreeTypeNumber ,
	JsonSyntaxTreeTypeBool ,
	JsonSyntaxTreeTypeString ,
	JsonSyntaxTreeTypeNull
}



class JsonSyntaxTreeNode {
	Type JsonSyntaxTreeType
	boolValue bool 
	numberValue Number   // number value
	stringValue string 
	arrayElements []JsonSyntaxTreeNode 
	object map{ string -> JsonSyntaxTreeNode} 
	fn nodeType() -> (t string ) {
		switch this.Type {
			case JsonSyntaxTreeTypeArray :
				return "array" 
			case JsonSyntaxTreeTypeObject :
				return "object" 
			case JsonSyntaxTreeTypeNumber :
				return "number" 
			case JsonSyntaxTreeTypeBool :
				return "bool" 
			case JsonSyntaxTreeTypeString :
				return "string" 
			case JsonSyntaxTreeTypeNull:
				return "null" 
		}
	}
}




class Decoder {
	x Object 
	bs []byte
	offset int  
	tree JsonSyntaxTreeNode  
	
	public fn Decoder(x Object,bs []byte) {
		this.super()
		this.x = x
		this.bs = bs
	}
	
	public fn decode() -> (x2 Object , err error){
		defer {
			x := catch()
			if x != null  &&
				err == null {
				err = x 
			}
		}
		err = this.parseSyntaxTree()
		if err != null {
			return  
		}
		return this.decodeFromTree(this.tree , this . x )
	}
	
	private fn parseSyntaxTree() -> (err error) {
		if this.bs.size() == 4  && 
			this.bs[0] == 'n' &&
			this.bs[1] == 'u' &&
			this.bs[2] == 'l' && 
			this.bs[3] == 'l'{
			return null 
		}
		this.skipWhiteSpace()
		b := this.bs[this.offset]  
		if b != '[' && b != '{' {
			err = new error("unkown begining of json input")
		}
		this.tree ,err = this.parseValue()
		if err != null {
			return  
		}
	}
	
	
	private fn decodeFromTree(tree JsonSyntaxTreeNode , x Object) -> (x2 Object , err error ){
		c := x.getClass()
		if c.isArray () {
			return this.decodeArrayFromTree(tree , x , c)
		}
		return  this.decodeObjectFromTree(tree , x , c)
	}

	static fn decodePrimitives(c Class , tree JsonSyntaxTreeNode) -> (x Object,err error) {
		typeName := c.getName()
		switch typeName { 
			case "boolean":
				if tree.Type != JsonSyntaxTreeTypeBool {
					return null, new error(sprintf("cannot decode '%s' to 'bool'" , tree.nodeType()))
				} 
				return Boolean.valueOf(tree.boolValue), null
			case "byte":
				if tree.Type != JsonSyntaxTreeTypeNumber {
					return null, new error(sprintf("cannot decode '%s' to 'byte'" , tree.nodeType()))
				} 
				longValue,err := tree.numberValue.getLong()
				if err != null {
					return null , err 
				}
				if longValue > long(Byte.MAX_VALUE) {
					return null , new error(sprintf("%d exceeds byte max value" ,longValue))
				}
				return Byte.valueOf(byte(longValue)) , null 
			case "short":
				if tree.Type != JsonSyntaxTreeTypeNumber {
					return null, new error(sprintf("cannot decode '%s' to 'short'" , tree.nodeType()))
				} 
				longValue,err := tree.numberValue.getLong()
				if err != null {
					return null , err 
				}
				if longValue > long(Short.MAX_VALUE) {
					return null , new error(sprintf("%d exceeds short max value" ,longValue))
				}
				return Short.valueOf(short(longValue)) , null 
			case "char":
				if tree.Type != JsonSyntaxTreeTypeNumber {
					return null, new error(sprintf("cannot decode '%s' to 'character'" , tree.nodeType()))
				} 
				longValue,err := tree.numberValue.getLong()
				if err != null {
					return null , err 
				}
				if longValue > long(Character.MAX_VALUE) {
					return null , new error(sprintf("%d exceeds character max value" ,longValue))
				}
				return Character.valueOf(char(longValue)) , null
			case "int" :
				if tree.Type != JsonSyntaxTreeTypeNumber {
					return null, new error(sprintf("cannot decode '%s' to 'byte'" , tree.nodeType()))
				} 
				longValue,err := tree.numberValue.getLong()
				if err != null {
					return null , err 
				}
				if longValue > long(Integer.MAX_VALUE) {
					return null , new error(sprintf("%d exceeds integer max value" ,longValue))
				}
				return Integer.valueOf(int(longValue)) , null 
			case "long" :
				if tree.Type != JsonSyntaxTreeTypeNumber {
					return null, new error(sprintf("cannot decode '%s' to 'long'" , tree.nodeType()))
				} 
				longValue,err := tree.numberValue.getLong()
				if err != null {
					return null , err 
				}
				return Long.valueOf(longValue) , null 
			case "float" :
				if tree.Type != JsonSyntaxTreeTypeNumber {
					return null, new error(sprintf("cannot decode '%s' to 'float'" , tree.nodeType()))
				} 
				doubleValue,err := tree.numberValue.getDouble()
				if err != null {
					return null , err 
				}
				if doubleValue > double( Float.MAX_VALUE) {
					return null , new error(sprintf("%f exceeds byte max value" ,doubleValue))
				}
				return Float.valueOf(float(doubleValue)) , null 
			case "double":
				if tree.Type != JsonSyntaxTreeTypeNumber {
					return null, new error(sprintf("cannot decode '%s' to 'double'" , tree.nodeType()))
				} 
				doubleValue,err := tree.numberValue.getDouble()
				if err != null {
					return null , err 
				}
				return Double.valueOf(doubleValue) , null
			default:
			    panic(new error(typeName))  // not a primitive type , panic 
		}
	}
	
	
	private fn decodeObjectFromTree (tree JsonSyntaxTreeNode , x Object , c Class) -> (x2 Object, err error ){
		if tree.Type == JsonSyntaxTreeTypeNull {
		    return null , null
		}
		if tree.Type == JsonSyntaxTreeTypeString {
			return tree.stringValue , null
		}
		if tree.Type != JsonSyntaxTreeTypeObject  {
			return null, new error(sprintf("cannot decode '%s' to 'object'" , tree.nodeType()))
		}
		fs := c.getFields()
		for f := range fs {
			if tree.object == null || 
				false == tree.object.keyExist(f.getName()) {
				continue  
			}
			cc := f.getType()
			if  (cc.isPrimitive()) {
				tree :=  tree.object[f.getName()]
				obj , err :=  __CLASS__.decodePrimitives( cc , tree  )
				if err != null {
					return null, err
				}
				f.set(x , obj) 
				continue  
			}
			t, err := this.decodeObjectFromTree( tree.object[f.getName()] , f.get(x) , cc )
			if err != null {
				return null, err
			}
			f.set(x , t )
		}
	}
	
	
	private fn decodeArrayFromTree (tree JsonSyntaxTreeNode , x Object , c Class) -> (x2 Object , err error ){
		componentClass := c.getComponentType()
		if tree.Type == JsonSyntaxTreeTypeNull {
			x2 = Array.newInstance( componentClass, 0)
			return 
		}
		if tree.Type != JsonSyntaxTreeTypeArray {
			return  null , new error(sprintf("cannot decode '%s' to 'array'" , tree.nodeType()))
		}
		x2 = Array.newInstance( componentClass, tree.arrayElements.size())
		for k,v := range tree.arrayElements {
			if componentClass.isPrimitive() {
				t , err := .decodePrimitives(componentClass ,v )
				if err != null {
					return null ,err 
				}
				Array.set(x2 , k , t)
			}else {
				t := componentClass.newInstance() 
				t2 , err := this.decodeFromTree(v , t )
				if err != null {
					return null, err 
				}
				Array.set(x2 , k , t2)
			}
		}
		return x2, null
	}
	
	
	
	private fn skipWhiteSpace() {
		b := this.bs[this.offset++] // 
		for b == ' ' || b == '\t' || b == '\n' || b == '\r' || b == '\f' || b == '\v' { // 13 stands for CR
			b = this.bs[this.offset++]
		}
		this.offset -- 
	}

	private fn parseValue() -> (n JsonSyntaxTreeNode,err error ) {
		this.skipWhiteSpace()
		b := this.bs[this.offset]
		switch b {
			case '\"':
				s := this.parseString()
				n = new JsonSyntaxTreeNode()
				n.Type = JsonSyntaxTreeTypeString
				n.stringValue = s 
				return 
			case '[':
				return this.parseArray()
			case '{':
				return this.parseObject()
			case 't' , 'f':
				var isTrue = b == 't'  
				if isTrue {
					err = this.parseTrue()
				}else {
					err = this.parseFalse()
				}
				if err != null {
					return null , err  
				}
				n = new JsonSyntaxTreeNode()
				n.Type = JsonSyntaxTreeTypeBool
				n.boolValue = isTrue
				return 
			case 'n':
				err = this.parseNull()
				if err != null {
					return null , err  
				}
				n = new JsonSyntaxTreeNode()
				n.Type = JsonSyntaxTreeTypeNull
				return
			default:
				if .isDigit(b) == false && b != '-' {
					err = new error("malformed json format: " + this.getErrMsg() )
					return 
				}
				var number Number  
				number,err = this.parseNumber()
				if err != null {
					return null , err  
				}
				n = new JsonSyntaxTreeNode()
				n.Type = JsonSyntaxTreeTypeNumber
				n.numberValue = number 
				return 
		} 
	} 

	private fn parseArray() -> (n JsonSyntaxTreeNode,err error ) {
		n = new JsonSyntaxTreeNode()
		n.Type = JsonSyntaxTreeTypeArray
		n.arrayElements = []JsonSyntaxTreeNode{}
		b := this.bs[this.offset ++ ]
		for b != ']' {
			value,err := this.parseValue()
			if err != null {
				return null,err 
			}
			n.arrayElements.append(value)
			this.skipWhiteSpace()
			b = this.bs[this.offset++]
			if b == ',' {	
			}else if b == ']' {
				break 
			}else {
				return null , new error(sprintf("expect ']' or ',' but '%s'" , this.getErrMsg()))
			}
		}
		if b != ']' {
			return null , new error ("'[' and ']' not match")
		}
		return n , null  
	}

	private fn parseObject() -> (n JsonSyntaxTreeNode,err error )  {
		this.offset++  // skip { 
		b := this.bs[this.offset]
		n = new JsonSyntaxTreeNode()
		n.Type = JsonSyntaxTreeTypeObject
		n.object = new map {string -> JsonSyntaxTreeNode } ()
		for b != '}' {
			k ,err := this.parseValue()
			if err != null {
				return null , err  
			}
			if k.Type != JsonSyntaxTreeTypeString {
				return null , new error("expect string for object key , but:" + k.nodeType())
			}
			this.skipWhiteSpace()
			b = this.bs[this.offset++]  
			if b != ':' {
				return null , new error("expect colon, but :" +  this.getErrMsg())
			}
			v,err := this.parseValue()
			if err != null {
				return null ,err 
			}
			n.object[k.stringValue] = v
			this.skipWhiteSpace()
			b = this.bs[this.offset]
			if b == ',' {
				this.offset++ 	
				this.skipWhiteSpace()
				b = this.bs[this.offset]
				if b == '}' {
					return null , new error(sprintf("expect key value list, but '%s'",this.getErrMsg()))
				}
			}else if b == '}' {
					//nothing to do 
			}else {
				return null , new error(sprintf("expect '}' or ',' but '%s'",this.getErrMsg()))
			}
		}
		if b != '}' {
			err = new error("expect } , but " + string(this.bs[this.offset:]))
		}
		this.offset ++ // skip } 
		return   
	}
	

	private fn parseString() -> (s string) {
		this.offset++  // skip "
		b := this.bs[this.offset++] 
		bs := []byte {}  
		for b != '\"' {
			if b != '\\' {
				bs.append(b)
				b = this.bs[this.offset++]
				continue
			}
			b = this.bs[this.offset++]
			switch b{
				case '\"' :
					bs.append('\"')
					b = this.bs[this.offset++]
				case '\\':
					bs.append('\\')
					b = this.bs[this.offset++]
				case 47b:
					bs.append(47b)
					b = this.bs[this.offset++]
				case 'b':
					bs.append('\b')
					b = this.bs[this.offset++]
				case 'f':
					bs.append('\f')
					b = this.bs[this.offset++]
				case 'n':
					bs.append('\n')
					b = this.bs[this.offset++]
				case 'r':
					bs.append('\r')
					b = this.bs[this.offset++]
				case 't':  // 1 
					bs.append('\t')
					b = this.bs[this.offset++]
				case 'u':  // unicode
					var c char  
					for i := 0 ;i < 4 ;i ++ {
						if b = this.bs[this.offset++] ; .isHex(b) == false {
							panic(new error("expect hex number"))
						}
						c = c * 16 + char(.hexByte2Int(b))
					}
					t := new char[](1)
					t[0] = c 
					for v := range new String(t).getBytes("utf-8") {
						bs.append(v)
					}
					b = this.bs[this.offset++ ]
			}
		}
		s = string(bs)
	}

	// no check 
	private fn hexByte2Int(b byte ) -> (v int ) {
		if b >= 'a' && b <= 'z' {
			return int(b - 'a') + 10 
		}else if b >= 'A' && b <= 'Z' {
			return int(b - 'A') + 10 
		}else {
			return int(b - '0')
		}
	}
	
	
	// 
	private fn parseTrue () ->(err error ) {
		this.offset++  // skip 't' 
		if this.bs[ this.offset ++ ] != 'r' {
			err = new error("wrong true")
		} 
		if this.bs[ this.offset ++ ] != 'u' {
			err = new error("wrong true")
		} 
		if this.bs[ this.offset ++ ] != 'e' {
			err = new error("wrong true")
		} 
	}

	private fn parseNull () ->(err error ) {
		this.offset++  // skip 'n' 
		if this.bs[ this.offset ++ ] != 'u' {
			err = new error("wrong null")
		} 
		if this.bs[ this.offset ++ ] != 'l' {
			err = new error("wrong null")
		} 
		if this.bs[ this.offset ++ ] != 'l' {
			err = new error("wrong null")
		} 
	}

	private fn parseFalse () ->(err error ) {
		this.offset++  // skip 'f' 
		if this.bs[ this.offset ++ ] != 'a' {
			err = new error("wrong false")
		} 
		if this.bs[ this.offset ++ ] != 'l' {
			err = new error("wrong false")
		} 
		if this.bs[ this.offset ++ ] != 's' {
			err = new error("wrong false")
		} 
		if this.bs[ this.offset ++ ] != 'e' {
			err = new error("wrong false")
		} 
	}
	
	private static fn isDigit(b byte) -> (is bool) {
		is = b >= '0' && b <= '9'
	}
	private static fn isHex(b byte) -> (is bool) {
		is = .isDigit(b) ||
			(b >= 'a' && b <= 'f') || 
			(b >= 'A' && b <= 'Z')
	} 

	private fn parseNumber() -> (n Number ,err error ) {
		n  = new Number()
		b := this.bs[this.offset ++ ]
		if b == '-' {
			n.isNegative = true 
			b = this.bs[this.offset++]
			if false == .isDigit(b) {
				err = new error("expect number after '-'")
				return 
			}
		}
		if b == '0' { // 
			n.integerPart.append(b)
		}else {
			for .isDigit(b) {
				n.integerPart.append(b)
				b = this.bs[this.offset++]
			}
		}
		if b == '.' {
			n.isFloat = true  
			b = this.bs[this.offset++]
			if .isDigit(b) == false  {
				err = new error("expect number after '.'")
				return 
			}
			for .isDigit(b) {
				n.floatPart.append(b)
				b = this.bs[this.offset++]
			}
		}
		if b == 'e' || b == 'E' {
			b = this.bs[ this.offset ++ ]
			if b == '+' {
				b = this.bs[this.offset ++ ]
			}else if b == '-' {
				b = this.bs[this.offset ++ ]
				n.eIsNegative = true
			}
			if false ==  .isDigit(b) {
				err = new error("expect number after 'e' or 'E' ," + this.getErrMsg() )
				return 
			}
			for .isDigit(b) {
				n.e.append(b)
				b = this.bs[this.offset ++ ]
			}
		}
	}
	
	private fn getErrMsg() -> (msg string ) {
		end := this.bs.size()
		size := 20 
		if this.bs.size() - this.offset >  size {
			end = this.offset + size
		}
		return string(this.bs[this.offset:end])
	}
}
