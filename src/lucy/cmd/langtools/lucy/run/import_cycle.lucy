 

class ImportStack {
	Stacks []PackageCompiled
	M      map { string -> PackageCompiled }


    fn fromLast(last ImportStack) ->(self ImportStack)  {
        self = this
        this.Stacks = new []PackageCompiled(len(last.Stacks))
        copy(this.Stacks, last.Stacks)
        this.M = new map { string -> PackageCompiled } ()
        for k, v := range last.M {
            this.M[k] = v
        }
    }

    /*
        check if import cycling
    */
    fn insert(c PackageCompiled) ->(err error) {
        if _, ok := this.M[c.packageName]; ok {
            errMsg := fmt.Sprintf("package named '%s' import cycling\n", c.packageName)
            errMsg += "\t"
            for _, v := range this.Stacks {
                errMsg += fmt.Sprintf("'%s' -> ", v.packageName)
            }
            errMsg += c.packageName
            return new error(sprintf(errMsg))
        }
        this.Stacks = append(this.Stacks, c)
        this.M[c.packageName] = c
        return null
    }
}

