import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/lex"

class EnumParser extends ParserExtends {
	fn EnumParser(parser Parser){
		this.super()
		this.parser = parser
	}

	fn parse() -> (e ast.Enum, err error) {
		var enumName string
		this.Next(lfIsToken) // skip enum
		this.parser.unExpectNewLineAndSkip()
		if this.parser.token.Type != lex.TokenIdentifier {
			err = new error(sprintf("%s expect 'identifier' for enum name, but '%s'",
				this.parser.errMsgPrefix(), this.parser.token.Description))
			this.parser.errs.append(err)
			enumName = compileAutoName()
			this.consume(untilLc)

		} else {
			enumName = this.parser.token.stringValue
			this.Next(lfNotToken) // skip enum name
		}
		e = new ast.Enum()
		e.name = enumName
		e.pos = this.parser.mkPos()
		comment := new CommentParser(this.parser)
		if this.parser.token.Type != lex.TokenLc {
			err = new error(sprintf("%s expect '{',but '%s'", this.parser.errMsgPrefix(), this.parser.token.Description))
			this.parser.errs.append(err)
			this.consume(untilLc)
		}
		this.Next(lfNotToken)
		for this.parser.token.Type != lex.TokenRc &&
			this.parser.token.Type != lex.TokenEof {
			switch this.parser.token.Type {
			case lex.TokenLf:
				this.Next(lfNotToken)
			case lex.TokenMultiLineComment,
				lex.TokenComment:
				comment.read()
			case lex.TokenIdentifier:
				name := this.parser.token.stringValue
				pos := this.parser.mkPos()
				var value ast.Expression
				var err error
				this.Next(lfIsToken)
				if this.parser.token.Type == lex.TokenAssign {
					this.Next(lfNotToken)
					value, err = this.parser.ExpressionParser.parseExpression(false)
					if err != null {
						this.consume(untilSemicolonOrLf)
					}
				}
				enumComment := comment.comment
				if e.Init == null && value != null {
					e.Init = value
					e.FirstValueIndex = len(e.Enums)
					value = null
				}
				enumName := new ast.EnumName()
				enumName.name = name
				enumName.pos = pos
				enumName.NoNeed = value
				enumName.Enum = e
				enumName.comment = enumComment
				e.Enums.append(enumName)
				comment.reset()
			case lex.TokenComma:
				this.Next(lfNotToken)
			default:
				this.parser.errs.append( new error(sprintf("%s token '%s' is not except",
					this.parser.errMsgPrefix(), this.parser.token.Description)))
				this.Next(lfNotToken)
				comment.reset()
			}
		}
		this.parser.ifTokenIsLfThenSkip()
		if this.parser.token.Type != lex.TokenRc {
			err = new error(sprintf("%s expect '}',but '%s'", this.parser.errMsgPrefix(), this.parser.token.Description))
			this.parser.errs.append( err)
			this.consume(untilRc)
		}
		this.Next(lfNotToken)
		return e, err
	}


}

