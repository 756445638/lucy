import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/lex"


class StatementForParser extends ParserExtends{
	bp BlockParser

	fn StatementForParser(parser Parser ,bp BlockParser){
		this.super()
		this.parser = parser
		this.bp = bp
	}
	

	protected fn parseFor() -> (statementFor ast.StatementFor, err error) {
		statementFor = new ast.StatementFor()
		statementFor.pos = this.parser.mkPos()
		statementFor.block = new ast.Block()
		this.next(lfIsToken) // skip for
		this.parser.unExpectNewLineAndSkip()
		if this.parser.token.Type != lex.TokenLc &&
			this.parser.token.Type != lex.TokenSemicolon { // not '{' and not ';'
			statementFor.condition, err = this.parser.ExpressionParser.parseExpression(true)
			if err != null {
				this.consume(untilLc)
				goto parseBlock
			}
		}
		if this.parser.token.Type == lex.TokenSemicolon {
			this.next(lfNotToken) // skip ;
			statementFor.Init = statementFor.condition
			statementFor.condition = null // mk null
			//condition
			if this.parser.token.Type != lex.TokenSemicolon {
				statementFor.condition, err = this.parser.ExpressionParser.parseExpression(false)
				if err != null {
					this.consume(untilLc)
					goto parseBlock
				}
				if this.parser.token.Type != lex.TokenSemicolon {
					this.parser.errs.append( new error(sprintf("%s missing semicolon after expression",
						this.parser.errMsgPrefix())))
					this.consume(untilLc)
					goto parseBlock
				}
			}
			this.next(lfIsToken)
			this.parser.unExpectNewLineAndSkip()
			if this.parser.token.Type != lex.TokenLc {
				statementFor.increment, err = this.parser.ExpressionParser.parseExpression(true)
				if err != null {
					this.consume(untilLc)
					goto parseBlock
				}
			}
		}
	parseBlock:
		this.parser.ifTokenIsLfThenSkip()
		if this.parser.token.Type != lex.TokenLc {
			err = new error(sprintf("%s expect '{',but '%s'",
				this.parser.errMsgPrefix(), this.parser.token.description))
			this.parser.errs.append( err)
			return
		}
		this.next(lfNotToken) // skip {
		this.bp.parseStatementList(statementFor.block, false)
		if this.parser.token.Type != lex.TokenRc {
			this.parser.errs.append( new error(sprintf("%s expect '}', but '%s'",
				this.parser.errMsgPrefix(), this.parser.token.description)))
			this.consume(untilRc)
		}
		this.next(lfNotToken) // skip }
		return statementFor, null
	}
	
}

