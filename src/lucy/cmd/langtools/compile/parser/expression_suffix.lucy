import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/lex"

class ExpressionSuffix extends  ParserExtends {
	ep ExpressionParser
	
	fn ExpressionSuffix(parser Parser , ep ExpressionParser){
		this.super()
		this.parser = parser
		this.ep = ep 
	}
	fn parseSuffixExpression() -> (e ast.Expression, err error) {
		var prefix ast.Expression
		switch this.parser.token.Type {
		case lex.TokenIdentifier:
			prefix = new ast.Expression()
			prefix.Op = this.parser.token.stringValue
			prefix.Type = ast.ExpressionTypeIdentifier
			identifier := new ast.ExpressionIdentifier()
			identifier.Name = this.parser.token.Data.(string)
			prefix.Data = identifier
			prefix.Pos = this.parser.mkPos()
			this.Next(lfIsToken)
		case lex.TokenTrue:
			prefix = new ast.Expression()
			prefix.Op = "true"
			prefix.Type = ast.ExpressionTypeBool
			prefix.boolValue = true
			prefix.Pos = this.parser.mkPos()
			this.Next(lfIsToken)
		case lex.TokenFalse:
			prefix = new ast.Expression()
			prefix.Op = "false"
			prefix.Type = ast.ExpressionTypeBool
			prefix.boolValue = false
			prefix.Pos = this.parser.mkPos()
			this.Next(lfIsToken)
		case lex.TokenSelection:
			prefix = new ast.Expression()
			prefix.Op = "."
			prefix.Type = ast.ExpressionTypeDot
			prefix.Pos = this.parser.mkPos()
			//special case , no next
		case lex.TokenGlobal:
			prefix = new ast.Expression()
			prefix.Op = "global"
			prefix.Type = ast.ExpressionTypeGlobal
			prefix.Pos = this.parser.mkPos()
			this.Next(lfIsToken)
		case lex.TokenLiteralByte:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeByte
			prefix.longValue = this.parser.token.longValue
			prefix.Pos = this.parser.mkPos()
			prefix.Op = "byteLiteral"
			this.Next(lfIsToken)
		case lex.TokenLiteralShort:
		    prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeShort
			prefix.longValue = this.parser.token.longValue
			prefix.Pos = this.parser.mkPos()
			prefix.Op = "shortLiteral"
			this.Next(lfIsToken)
		case lex.TokenLiteralChar:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeChar
			prefix.longValue = this.parser.token.longValue
			prefix.Pos = this.parser.mkPos()
			prefix.Op = "charLiteral"
			this.Next(lfIsToken)
		case lex.TokenLiteralInt:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeInt
			prefix.longValue = this.parser.token.longValue
			prefix.Pos = this.parser.mkPos()
			prefix.Op = "intLiteral"
			this.Next(lfIsToken)
		case lex.TokenLiteralLong:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeLong
			prefix.longValue = this.parser.token.longValue
			prefix.Pos = this.parser.mkPos()
			prefix.Op = "longLiteral"
			this.Next(lfIsToken)
		case lex.TokenLiteralFloat:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeFloat
			prefix.doubleValue = this.parser.token.doubleValue
			prefix.Pos = this.parser.mkPos()
			prefix.Op = "floatLiteral"
			this.Next(lfIsToken)
		case lex.TokenLiteralDouble:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeDouble
			prefix.doubleValue = this.parser.token.doubleValue
			prefix.Pos = this.parser.mkPos()
			prefix.Op = "doubleLiteral"
			this.Next(lfIsToken)
		case lex.TokenLiteralString:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeString
			prefix.Data = this.parser.token.Data
			prefix.Pos = this.parser.mkPos()
			prefix.Op = "stringLiteral"
			this.Next(lfIsToken)
		case lex.TokenNull:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeNull
			prefix.Pos = this.parser.mkPos()
			prefix.Op = "null"
			this.Next(lfIsToken)
		case lex.TokenLp:
			pos := this.parser.mkPos()
			this.Next(lfNotToken)
			prefix, err = this.parseExpression(false)
			if err != null {
				return null, err
			}
			this.parser.ifTokenIsLfThenSkip()
			if this.parser.token.Type != lex.TokenRp {
				err := new error(sprintf("%s '(' and ')' not matched, but '%s'",
					this.parser.errMsgPrefix(), this.parser.token.Description))
				this.parser.errs.append( err)
				return null, err
			}
			newExpression := new ast.Expression()
			newExpression.Type = ast.ExpressionTypeParenthesis
			newExpression.Pos = pos
			newExpression.Data = prefix
			newExpression.Op = "(" + prefix.Op + ")"
			prefix = newExpression
			this.Next(lfIsToken)
		case lex.TokenIncrement:
			pos := this.parser.mkPos()
			this.Next(lfIsToken) // skip ++
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE := new ast.Expression()
			newE.Pos = pos
			newE.Op = "++()"
			newE.Type = ast.ExpressionTypePrefixIncrement
			newE.Data = prefix
			prefix = newE
		case lex.TokenDecrement:
			pos := this.parser.mkPos()
			this.Next(lfIsToken) // skip --
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE := new ast.Expression()
			newE.Op = "--()"
			newE.Type = ast.ExpressionTypePrefixDecrement
			newE.Data = prefix
			newE.Pos = pos
			prefix = newE
		case lex.TokenNot:
			op := this.parser.token.Description
			pos := this.parser.mkPos()
			this.Next(lfIsToken)
			newE := new ast.Expression()
			newE.Op = op
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE.Type = ast.ExpressionTypeNot
			newE.Data = prefix
			newE.Pos = pos
			prefix = newE
		case lex.TokenBitNot:
			op := this.parser.token.Description
			pos := this.parser.mkPos()
			this.Next(lfIsToken)
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE := new ast.Expression()
			newE.Op = op
			newE.Type = ast.ExpressionTypeBitwiseNot
			newE.Data = prefix
			newE.Pos = pos
			prefix = newE
		case lex.TokenSub:
			op := this.parser.token.Description
			pos := this.parser.mkPos()
			this.Next(lfIsToken)
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE := new ast.Expression()
			newE.Op = op
			newE.Type = ast.ExpressionTypeNegative
			newE.Data = prefix
			newE.Pos = pos
			prefix.AsSubForNegative = newE
			prefix = newE
		case lex.TokenFn:
			pos := this.parser.mkPos()
			f, err := this.parser.FunctionParser.parse(false, false)
			if err != null {
				return null, err
			}
			prefix := new ast.Expression()
			prefix.Type = ast.ExpressionTypeFunctionLiteral
			prefix.Data = f
			prefix.Pos = pos
			prefix.Op = "functionLiteral"
		case lex.TokenNew:
			pos := this.parser.mkPos()
			this.Next(lfIsToken)
			this.parser.unExpectNewLineAndSkip()
			t, err := this.parser.parseType()
			if err != null {
				return null, err
			}
			this.parser.unExpectNewLineAndSkip()
			if this.parser.token.Type != lex.TokenLp {
				err := new error(sprintf("%s missing '(' after new", this.parser.errMsgPrefix()))
				this.parser.errs.append( err)
				return null, err
			}
			this.Next(lfNotToken) // skip (
			var es []ast.Expression
			if this.parser.token.Type != lex.TokenRp { //
				es, err = this.parseExpressions(lex.TokenRp)
				if err != null {
					return null, err
				}
			}
			this.parser.ifTokenIsLfThenSkip()
			if this.parser.token.Type != lex.TokenRp {
				err := new error(sprintf("%s '(' and ')' not match", this.parser.errMsgPrefix()))
				this.parser.errs.append( err)
				return null, err
			}
			this.Next(lfIsToken)
			prefix := new ast.Expression()
			prefix.Type = ast.ExpressionTypeNew
			prefix.Pos = pos
			prefix.Op = "new"
			prefix.Type = ast.ExpressionTypeNew
            t := new ast.ExpressionNew()
            t.Args = es
            t.Type = t
            prefix.Data = t
		case lex.TokenLb:
			prefix, err = this.parseArrayExpression()
			if err != null {
				return prefix, err
			}
		// bool(xxx)
		case lex.TokenBool:
			prefix, err = this.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
			//byte()
		case lex.TokenByte:
			prefix, err = this.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
			//short()
		case lex.TokenShort:
			prefix, err = this.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
			//char()
		case lex.TokenChar:
			prefix, err = this.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
			//int()
		case lex.TokenInt:
			prefix, err = this.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
			//long()
		case lex.TokenLong:
			prefix, err = this.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
			//float()
		case lex.TokenFloat:
			prefix, err = this.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
			//double
		case lex.TokenDouble:
			prefix, err = this.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
			//string()
		case lex.TokenString:
			prefix, err = this.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
			// range
		case lex.TokenRange:
			pos := this.parser.mkPos()
			this.Next(lfIsToken)
			this.parser.unExpectNewLineAndSkip()
			e, err := this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			prefix = new ast.Expression()
			prefix.Op = "range"
			prefix.Type = ast.ExpressionTypeRange
			prefix.Pos = pos
			prefix.Data = e
			return prefix, null
		case lex.TokenMap:
			prefix, err = this.parseMapExpression()
			if err != null {
				return prefix, err
			}
		case lex.TokenLc:
			prefix, err = this.parseMapExpression()
			if err != null {
				return prefix, err
			}

		case lex.TokenLf:
			this.parser.unExpectNewLineAndSkip()
			return this.parseSuffixExpression()
		default:
			err = new error(sprintf("%s unkown begining of a expression, token:'%s'",
				this.parser.errMsgPrefix(), this.parser.token.Description))
			this.parser.errs.append( err)
			return null, err
		}
		for this.parser.token.Type == lex.TokenIncrement ||
			this.parser.token.Type == lex.TokenDecrement ||
			this.parser.token.Type == lex.TokenLp ||
			this.parser.token.Type == lex.TokenLb ||
			this.parser.token.Type == lex.TokenSelection ||
			this.parser.token.Type == lex.TokenVArgs ||
			this.parser.token.Type == lex.TokenSelectConst {
			switch this.parser.token.Type {
			case lex.TokenVArgs:
				newExpression := new ast.Expression()
				newExpression.Op = "..."
				newExpression.Type = ast.ExpressionTypeVArgs
				newExpression.Data = prefix
				newExpression.Pos = this.parser.mkPos()
				this.Next(lfIsToken)
				return newExpression, null
			case lex.TokenIncrement,
				lex.TokenDecrement:
				newExpression := new ast.Expression()
				if this.parser.token.Type == lex.TokenIncrement {
					newExpression.Op = "()++"
					newExpression.Type = ast.ExpressionTypeIncrement
				} else {
					newExpression.Op = "()--"
					newExpression.Type = ast.ExpressionTypeDecrement
				}
				newExpression.Data = prefix
				prefix = newExpression
				newExpression.Pos = this.parser.mkPos()
				this.Next(lfIsToken)
			case lex.TokenLb:
				this.Next(lfNotToken) // skip [
				if this.parser.token.Type == lex.TokenColon {
					/*
						a[:]
					*/
					this.Next(lfNotToken) // skip :
					var end ast.Expression
					if this.parser.token.Type != lex.TokenRb {
						end, err = this.parseExpression(false)
						if err != null {
							return null, err
						}
					}
					this.parser.ifTokenIsLfThenSkip()
					if this.parser.token.Type != lex.TokenRb {
						err := new error(sprintf("%s '[' and ']' not match", this.parser.errMsgPrefix()))
						this.parser.errs.append( err)
						return null, err
					}
					newExpression := new ast.Expression()
					newExpression.Type = ast.ExpressionTypeSlice
					newExpression.Op = "slice"
					newExpression.Pos = this.parser.mkPos()
					slice := new ast.ExpressionSlice()
					newExpression.Data = slice
					slice.ExpressionOn = prefix
					slice.End = end
					prefix = newExpression
					this.Next(lfIsToken) // skip ]
				} else {
					e, err := this.parseExpression(false)
					if err != null {
						return null, err
					}
					if this.parser.token.Type == lex.TokenColon {
						this.Next(lfNotToken)
						var end ast.Expression
						if this.parser.token.Type != lex.TokenRb {
							end, err = this.parseExpression(false)
							if err != null {
								return null, err
							}
						}
						if this.parser.token.Type != lex.TokenRb {
							err := new error(sprintf("%s '[' and ']' not match", this.parser.errMsgPrefix()))
							this.parser.errs.append( err)
							return null, err
						}
						newExpression := new ast.Expression()
						newExpression.Type = ast.ExpressionTypeSlice
						newExpression.Op = "slice"
						newExpression.Pos = this.parser.mkPos()
						slice := new ast.ExpressionSlice()
						newExpression.Data = slice
						slice.Start = e
						slice.ExpressionOn = prefix
						slice.End = end
						prefix = newExpression
						this.Next(lfIsToken) // skip ]
					} else {
						if this.parser.token.Type != lex.TokenRb {
							err := new error(sprintf("%s '[' and ']' not match", this.parser.errMsgPrefix()))
							this.parser.errs.append( err)
							return null, err
						}
						newExpression := new ast.Expression()
						newExpression.Pos = this.parser.mkPos()
						newExpression.Op = "index"
						newExpression.Type = ast.ExpressionTypeIndex
						index := new ast.ExpressionIndex()
						index.Expression = prefix
						index.Index = e
						newExpression.Data = index
						prefix = newExpression
						this.Next(lfIsToken)
					}
				}
			case lex.TokenSelectConst:
				pos := this.parser.mkPos()
				this.Next(lfNotToken) // skip ::
				var constName string
				if this.parser.token.Type != lex.TokenIdentifier {
					this.parser.errs.append(
						new error(sprintf("%s expect idnetifier , but '%s'",
							this.parser.errMsgPrefix(), this.parser.token.Description)))
					constName = compileAutoName()
				} else {
					constName = this.parser.token.Data.(string)
					this.Next(lfIsToken)
				}
				newExpression := new ast.Expression()
				newExpression.Pos = pos
				newExpression.Op = "selectConst"
				newExpression.Type = ast.ExpressionTypeSelectionConst
				selection := new ast.ExpressionSelection()
				selection.Expression = prefix
				selection.Name = constName
				newExpression.Data = selection
				prefix = newExpression
			case lex.TokenSelection:
				pos := this.parser.mkPos()
				this.Next(lfNotToken) // skip .
				if this.parser.token.Type == lex.TokenIdentifier {
					newExpression := new ast.Expression()
					newExpression.Pos = pos
					newExpression.Op = "selection"
					newExpression.Type = ast.ExpressionTypeSelection
					selection := new ast.ExpressionSelection()
					selection.Expression = prefix
					selection.Name = this.parser.token.Data.(string)
					newExpression.Data = selection
					prefix = newExpression
					this.Next(lfIsToken)
				} else if this.parser.token.Type == lex.TokenLp { //  a.(xxx)
					//
					this.Next(lfNotToken) // skip (
					typ, err := this.parser.parseType()
					if err != null {
						return null, err
					}
					this.parser.ifTokenIsLfThenSkip()
					if this.parser.token.Type != lex.TokenRp {
						err := new error(sprintf("%s '(' and ')' not match", this.parser.errMsgPrefix()))
						this.parser.errs.append( err)
						return null, err
					}
					newExpression := new ast.Expression()
					newExpression.Pos = pos
					newExpression.Op = "assert"
					newExpression.Type = ast.ExpressionTypeTypeAssert
					typeAssert := new ast.ExpressionTypeAssert()
					typeAssert.Type = typ
					typeAssert.Expression = prefix
					newExpression.Data = typeAssert
					prefix = newExpression
					this.Next(lfIsToken) // skip  )
				} else {
					err := new error(sprintf("%s expect  'identifier' or '(',but '%s'",
						this.parser.errMsgPrefix(), this.parser.token.Description))
					this.parser.errs.append( err)
					return null, err
				}
			case lex.TokenLp:
				newExpression, err := this.parseCallExpression(prefix)
				if err != null {
					return null, err
				}
				prefix = newExpression
			}
		}

		return prefix, null
	}

	fn parseCallExpression(on ast.Expression) -> (e ast.Expression,err error) {
		var err error
		this.Next(lfNotToken) // skip (
		var args []ast.Expression
		if this.parser.token.Type != lex.TokenRp { //a(123)
			args, err = this.parseExpressions(lex.TokenRp)
			if err != null {
				return null, err
			}
		}
		{
			pos := this.parser.mkPos()
			if this.parser.lastToken != null {
				pos = new ast.Pos()
				pos.Filename = this.parser.filename
				pos.Line = this.parser.lastToken.EndLine
				pos.Column = this.parser.lastToken.EndColumn
			}
			this.parser.ifTokenIsLfThenSkip()
			if this.parser.token.Type != lex.TokenRp {
				err := new error(sprintf("%s except ')' ,but '%s'",
					this.parser.errMsgPrefix(pos),
					this.parser.token.Description))
				this.parser.errs.append( err)
				return null, err
			}
	    }
		pos := this.parser.mkPos()
		this.Next(lfIsToken) // skip )
		result := new ast.Expression()
		if on.Type == ast.ExpressionTypeSelection {
			/*
				x.x()
			*/
			result.Type = ast.ExpressionTypeMethodCall
			result.Op = "methodCall"
			call := new ast.ExpressionMethodCall()
			index := on.Data.(ast.ExpressionSelection)
			call.Expression = index.Expression
			call.Args = args
			call.Name = index.Name
			result.Pos = on.Pos
			result.Data = call
		} else {
			result.Type = ast.ExpressionTypeFunctionCall
			result.Op = "functionCall"
			call := new ast.ExpressionFunctionCall()
			call.Expression = on
			call.Args = args
			result.Data = call
			result.Pos = pos
		}

		if this.parser.token.Type == lex.TokenLt { // <
			/*
				template function call return type binds
				fn a ()->(r T) {

				}
				a<int , ... >
			*/
			this.Next(lfNotToken) // skip <
			ts, err := this.parser.parseTypes(lex.TokenGt)
			if err != null {
				return result, err
			}
			this.parser.ifTokenIsLfThenSkip()
			if this.parser.token.Type != lex.TokenGt {
				this.parser.errs.append(
					new error(sprintf("%s '<' and '>' not match",
						this.parser.errMsgPrefix())))
				this.parser.consume(untilGt)
			}
			this.Next(lfIsToken)
			if result.Type == ast.ExpressionTypeFunctionCall {
				result.Data.(ast.ExpressionFunctionCall).ParameterTypes = ts
			} else {
				result.Data.(ast.ExpressionMethodCall).ParameterTypes = ts
			}
		}
		return result, null
	}

}
