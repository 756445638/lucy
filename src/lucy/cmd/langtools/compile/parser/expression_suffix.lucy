import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/lex"

class ExpressionSuffix extends  ParserExtends {
	ep ExpressionParser
	
	fn ExpressionSuffix(parser Parser , ep ExpressionParser){
		this.super()
		this.parser = parser
		this.ep = ep 
	}
	fn parseSuffixExpression() -> (prefix ast.Expression, err error) {
		switch this.parser.token.Type {
		case lex.TokenIdentifier:
			prefix = new ast.Expression()
			prefix.op = this.parser.token.stringValue
			prefix.Type = ast.ExpressionTypeIdentifier
			identifier := new ast.ExpressionIdentifier()
			identifier.name = this.parser.token.stringValue
			prefix.data = identifier
			identifier.locateDefinition  = this.parser.token.locateDefinition 
			identifier.getHover  = this.parser.token.getHover 
			identifier.findUsage  = this.parser.token.findUsage 
			identifier.rename  = this.parser.token.rename
			prefix.pos = this.parser.mkPos()
			this.next(lfIsToken)
		case lex.TokenTrue:
			prefix = new ast.Expression()
			prefix.op = "true"
			prefix.Type = ast.ExpressionTypeBool
			prefix.boolValue = true
			prefix.pos = this.parser.mkPos()
			this.next(lfIsToken)
		case lex.TokenFalse:
			prefix = new ast.Expression()
			prefix.op = "false"
			prefix.Type = ast.ExpressionTypeBool
			prefix.boolValue = false
			prefix.pos = this.parser.mkPos()
			this.next(lfIsToken)
		case lex.TokenSelection:
			prefix = new ast.Expression()
			prefix.op = "."
			prefix.Type = ast.ExpressionTypeDot
			prefix.pos = this.parser.mkPos()
			//special case , no next
		case lex.TokenGlobal:
			prefix = new ast.Expression()
			prefix.op = "global"
			prefix.Type = ast.ExpressionTypeGlobal
			prefix.pos = this.parser.mkPos()
			this.next(lfIsToken)
		case lex.TokenLiteralByte:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeByte
			prefix.longValue = this.parser.token.longValue
			prefix.pos = this.parser.mkPos()
			prefix.op = "byteLiteral"
			this.next(lfIsToken)
		case lex.TokenLiteralShort:
		    prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeShort
			prefix.longValue = this.parser.token.longValue
			prefix.pos = this.parser.mkPos()
			prefix.op = "shortLiteral"
			this.next(lfIsToken)
		case lex.TokenLiteralChar:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeChar
			prefix.longValue = this.parser.token.longValue
			prefix.pos = this.parser.mkPos()
			prefix.op = "charLiteral"
			this.next(lfIsToken)
		case lex.TokenLiteralInt:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeInt
			prefix.longValue = this.parser.token.longValue
			prefix.pos = this.parser.mkPos()
			prefix.op = "intLiteral"
			this.next(lfIsToken)
		case lex.TokenLiteralLong:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeLong
			prefix.longValue = this.parser.token.longValue
			prefix.pos = this.parser.mkPos()
			prefix.op = "longLiteral"
			this.next(lfIsToken)
		case lex.TokenLiteralFloat:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeFloat
			prefix.doubleValue = this.parser.token.doubleValue
			prefix.pos = this.parser.mkPos()
			prefix.op = "floatLiteral"
			this.next(lfIsToken)
		case lex.TokenLiteralDouble:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeDouble
			prefix.doubleValue = this.parser.token.doubleValue
			prefix.pos = this.parser.mkPos()
			prefix.op = "doubleLiteral"
			this.next(lfIsToken)
		case lex.TokenLiteralString:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeString
			prefix.stringValue = this.parser.token.stringValue
			prefix.pos = this.parser.mkPos()
			prefix.op = "stringLiteral"
			this.next(lfIsToken)
		case lex.TokenNull:
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeNull
			prefix.pos = this.parser.mkPos()
			prefix.op = "null"
			this.next(lfIsToken)
		case lex.TokenLp:
			pos := this.parser.mkPos()
			this.next(lfNotToken)
			prefix, err = this.ep.parseExpression(false)
			if err != null {
				return null, err
			}
			this.parser.ifTokenIsLfThenSkip()
			if this.parser.token.Type != lex.TokenRp {
				err = new error(sprintf("%s '(' and ')' not matched, but '%s'",
					this.parser.errMsgPrefix(), this.parser.token.description))
				this.parser.errs.append( err)
				return null, err
			}
			assert(prefix != null)
			newExpression := new ast.Expression()
			newExpression.Type = ast.ExpressionTypeParenthesis
			newExpression.pos = pos
			newExpression.data = prefix
			newExpression.op = "(" + prefix.op + ")"
			prefix = newExpression
			this.next(lfIsToken)
		case lex.TokenIncrement:
			pos := this.parser.mkPos()
			this.next(lfIsToken) // skip ++
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE := new ast.Expression()
			newE.pos = pos
			newE.op = "++()"
			newE.Type = ast.ExpressionTypePrefixIncrement
			newE.data = prefix
			prefix = newE
		case lex.TokenDecrement:
			pos := this.parser.mkPos()
			this.next(lfIsToken) // skip --
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE := new ast.Expression()
			newE.op = "--()"
			newE.Type = ast.ExpressionTypePrefixDecrement
			newE.data = prefix
			newE.pos = pos
			prefix = newE
		case lex.TokenNot:
			op := this.parser.token.description
			pos := this.parser.mkPos()
			this.next(lfIsToken)
			newE := new ast.Expression()
			newE.op = op
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE.Type = ast.ExpressionTypeNot
			newE.data = prefix
			newE.pos = pos
			prefix = newE
		case lex.TokenBitNot:
			op := this.parser.token.description
			pos := this.parser.mkPos()
			this.next(lfIsToken)
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE := new ast.Expression()
			newE.op = op
			newE.Type = ast.ExpressionTypeBitwiseNot
			newE.data = prefix
			newE.pos = pos
			prefix = newE
		case lex.TokenSub:
			op := this.parser.token.description
			pos := this.parser.mkPos()
			this.next(lfIsToken)
			prefix, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			newE := new ast.Expression()
			newE.op = op
			newE.Type = ast.ExpressionTypeNegative
			newE.data = prefix
			newE.pos = pos
			prefix = newE
		case lex.TokenFn:
			pos := this.parser.mkPos()
			var f ast.Function
			f, err = this.parser.FunctionParser.parse(false, false,true)
			if err != null {
				return null, err
			}
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeFunctionLiteral
			prefix.data = f
			prefix.pos = pos
			prefix.op = "functionLiteral"
		case lex.TokenNew:
			pos := this.parser.mkPos()
			this.next(lfIsToken)
			this.parser.unExpectNewLineAndSkip()
			var t ast.Type
			t, err = this.parser.parseType()
			if err != null {
				return null, err
			}
			this.parser.unExpectNewLineAndSkip()
			if this.parser.token.Type != lex.TokenLp {
				err = new error(sprintf("%s missing '(' after new", this.parser.errMsgPrefix()))
				this.parser.errs.append( err)
				return null, err
			}
			this.next(lfNotToken) // skip (
			var es []ast.Expression
			if this.parser.token.Type != lex.TokenRp { //
				es, err = this.ep.parseExpressions(lex.TokenRp)
				if err != null {
					return null, err
				}
			}
			this.parser.ifTokenIsLfThenSkip()
			if this.parser.token.Type != lex.TokenRp {
				err = new error(sprintf("%s '(' and ')' not match", this.parser.errMsgPrefix()))
				this.parser.errs.append( err)
				return null, err
			}
			prefix = new ast.Expression()
			prefix.Type = ast.ExpressionTypeNew
			prefix.pos = pos
			prefix.op = "new"
            n := new ast.ExpressionNew()
            n.args = es
            n.Type = t
            prefix.data = n
            this.next(lfIsToken)
		case lex.TokenLb:
			prefix, err = this.ep.ExpressionArrayParser.parseArrayExpression()
			if err != null {
				return prefix, err
			}
		// bool(xxx)
		case lex.TokenBool ,lex.TokenByte , lex.TokenShort , lex.TokenChar ,
		 	lex.TokenInt ,lex.TokenLong ,lex.TokenFloat ,lex.TokenDouble , lex.TokenString :
			prefix, err = this.ep.parseTypeConversionExpression()
			if err != null {
				return prefix, err
			}
		case lex.TokenRange:
			pos := this.parser.mkPos()
			this.next(lfIsToken)
			this.parser.unExpectNewLineAndSkip()
			var e ast.Expression
			e, err = this.parseSuffixExpression()
			if err != null {
				return null, err
			}
			prefix = new ast.Expression()
			prefix.op = "range"
			prefix.Type = ast.ExpressionTypeRange
			prefix.pos = pos
			prefix.data = e
			return prefix, null
		case lex.TokenMap:
			prefix, err = this.ep.parseMapExpression()
			if err != null {
				return prefix, err
			}
		case lex.TokenLc:
			prefix, err = this.ep.parseMapExpression()
			if err != null {
				return prefix, err
			}

		case lex.TokenLf:
			this.parser.unExpectNewLineAndSkip()
			return this.parseSuffixExpression()
		default:
			err = new error(sprintf("%s unkown begining of a expression, token:'%s'",
				this.parser.errMsgPrefix(), this.parser.token.description))
			this.parser.errs.append( err)
			return null, err
		}
		for this.parser.token.Type == lex.TokenIncrement ||
			this.parser.token.Type == lex.TokenDecrement ||
			this.parser.token.Type == lex.TokenLp ||
			this.parser.token.Type == lex.TokenLb ||
			this.parser.token.Type == lex.TokenSelection ||
			this.parser.token.Type == lex.TokenVArgs ||
			this.parser.token.Type == lex.TokenSelectConst {
			switch this.parser.token.Type {
			case lex.TokenVArgs:
				newExpression := new ast.Expression()
				newExpression.op = "..."
				newExpression.Type = ast.ExpressionTypeVArgs
				newExpression.data = prefix
				newExpression.pos = this.parser.mkPos()
				this.next(lfIsToken)
				return newExpression, null
			case lex.TokenIncrement,
				lex.TokenDecrement:
				newExpression := new ast.Expression()
				if this.parser.token.Type == lex.TokenIncrement {
					newExpression.op = "()++"
					newExpression.Type = ast.ExpressionTypeIncrement
				} else {
					newExpression.op = "()--"
					newExpression.Type = ast.ExpressionTypeDecrement
				}
				newExpression.data = prefix
				prefix = newExpression
				newExpression.pos = this.parser.mkPos()
				this.next(lfIsToken)
			case lex.TokenLb:
				this.next(lfNotToken) // skip [
				if this.parser.token.Type == lex.TokenColon {
					/*
						a[:]
					*/
					this.next(lfNotToken) // skip :
					var end ast.Expression
					if this.parser.token.Type != lex.TokenRb {
						end, err = this.ep.parseExpression(false)
						if err != null {
							return null, err
						}
					}
					this.parser.ifTokenIsLfThenSkip()
					if this.parser.token.Type != lex.TokenRb {
						err = new error(sprintf("%s '[' and ']' not match", this.parser.errMsgPrefix()))
						this.parser.errs.append( err)
						return null, err
					}
					newExpression := new ast.Expression()
					newExpression.Type = ast.ExpressionTypeSlice
					newExpression.op = "slice"
					newExpression.pos = this.parser.mkPos()
					slice := new ast.ExpressionSlice()
					newExpression.data = slice
					slice.ExpressionOn = prefix
					slice.end = end
					prefix = newExpression
					this.next(lfIsToken) // skip ]
				} else {
				    var e ast.Expression
					e, err = this.ep.parseExpression(false)
					if err != null {
						return null, err
					}
					if this.parser.token.Type == lex.TokenColon {
						this.next(lfNotToken)
						var end ast.Expression
						if this.parser.token.Type != lex.TokenRb {
							end, err = this.ep.parseExpression(false)
							if err != null {
								return null, err
							}
						}
						if this.parser.token.Type != lex.TokenRb {
							err = new error(sprintf("%s '[' and ']' not match", this.parser.errMsgPrefix()))
							this.parser.errs.append( err)
							return null, err
						}
						newExpression := new ast.Expression()
						newExpression.Type = ast.ExpressionTypeSlice
						newExpression.op = "slice"
						newExpression.pos = this.parser.mkPos()
						slice := new ast.ExpressionSlice()
						newExpression.data = slice
						slice.start = e
						slice.ExpressionOn = prefix
						slice.end = end
						prefix = newExpression
						this.next(lfIsToken) // skip ]
					} else {
						if this.parser.token.Type != lex.TokenRb {
							err = new error(sprintf("%s '[' and ']' not match", this.parser.errMsgPrefix()))
							this.parser.errs.append( err)
							return null, err
						}
						newExpression := new ast.Expression()
						newExpression.pos = this.parser.mkPos()
						newExpression.op = "index"
						newExpression.Type = ast.ExpressionTypeIndex
						index := new ast.ExpressionIndex()
						index.Expression = prefix
						index.index = e
						newExpression.data = index
						prefix = newExpression
						this.next(lfIsToken)
					}
				}
			case lex.TokenSelectConst:
				pos := this.parser.mkPos()
				this.next(lfNotToken) // skip ::
				var constName string
				newExpression := new ast.Expression()
				selection := new ast.ExpressionSelection()
				if this.parser.token.Type != lex.TokenIdentifier {
					this.parser.errs.append(
						new error(sprintf("%s expect idnetifier , but '%s'",
							this.parser.errMsgPrefix(), this.parser.token.description)))
					constName = compileAutoName()
				} else {
					constName = this.parser.token.stringValue
					selection.locateDefinition = this.parser.token.locateDefinition
					selection.findUsage = this.parser.token.findUsage
					selection.rename = this.parser.token.rename
					this.next(lfIsToken)
				}
				newExpression.pos = pos
				newExpression.op = "selectConst"
				newExpression.Type = ast.ExpressionTypeSelectionConst
				selection.Expression = prefix
				selection.name = constName
				newExpression.data = selection
				prefix = newExpression
			case lex.TokenSelection:
				pos := this.parser.mkPos()
				this.next(lfNotToken) // skip .
				if this.parser.token.Type == lex.TokenIdentifier {
					newExpression := new ast.Expression()
					newExpression.pos = pos
					newExpression.op = "selection"
					newExpression.Type = ast.ExpressionTypeSelection
					selection := new ast.ExpressionSelection()
					selection.locateDefinition = this.parser.token.locateDefinition
					selection.findUsage  = this.parser.token.findUsage
					selection.getHover  = this.parser.token.getHover
					selection.rename  = this.parser.token.rename
					selection.Expression = prefix
					selection.name = this.parser.token.stringValue
					newExpression.data = selection
					prefix = newExpression
					this.next(lfIsToken)
				} else if this.parser.token.Type == lex.TokenLp { //  a.(xxx)
					//
					this.next(lfNotToken) // skip (
					var typ ast.Type
					typ, err = this.parser.parseType()
					if err != null {
						return null, err
					}
					this.parser.ifTokenIsLfThenSkip()
					if this.parser.token.Type != lex.TokenRp {
						err = new error(sprintf("%s '(' and ')' not match", this.parser.errMsgPrefix()))
						this.parser.errs.append( err)
						return null, err
					}
					newExpression := new ast.Expression()
					newExpression.pos = pos
					newExpression.op = "assert"
					newExpression.Type = ast.ExpressionTypeTypeAssert
					typeAssert := new ast.ExpressionTypeAssert()
					typeAssert.Type = typ
					typeAssert.Expression = prefix
					newExpression.data = typeAssert
					prefix = newExpression
					this.next(lfIsToken) // skip  )
				} else {
					err = new error(sprintf("%s expect  'identifier' or '(',but '%s'",
						this.parser.errMsgPrefix(), this.parser.token.description))
					this.parser.errs.append( err)
					return null, err
				}
			case lex.TokenLp:
			    var newExpression ast.Expression
				newExpression, err = this.parseCallExpression(prefix)
				if err != null {
					return null, err
				}
				prefix = newExpression
			}
		}

		return prefix, null
	}

	fn parseCallExpression(on ast.Expression) -> (e ast.Expression,err error) {
		this.next(lfNotToken) // skip (
		var args []ast.Expression
		if this.parser.token.Type != lex.TokenRp { //a(123)
			args, err = this.ep.parseExpressions(lex.TokenRp)
			if err != null {
				return null, err
			}
		}
		{
			pos := this.parser.mkPos()
			if this.parser.lastToken != null {
				pos = new ast.Pos()
				pos.filename = this.parser.filename
				pos.line = this.parser.lastToken.endLine
				pos.column = this.parser.lastToken.endColumn
			}
			this.parser.ifTokenIsLfThenSkip()
			if this.parser.token.Type != lex.TokenRp {
				err = new error(sprintf("%s except ')' ,but '%s'",
					this.parser.errMsgPrefix(pos),
					this.parser.token.description))
				this.parser.errs.append( err)
				return null, err
			}
	    }
		pos := this.parser.mkPos()
		this.next(lfIsToken) // skip )
		result := new ast.Expression()
		if on.Type == ast.ExpressionTypeSelection {
			/*
				x.x()
			*/
			result.Type = ast.ExpressionTypeMethodCall
			result.op = "methodCall"
			call := new ast.ExpressionMethodCall()
			selection := on.data.(ast.ExpressionSelection)
			call.name = selection.name
			call.locateDefinition = selection.locateDefinition
			call.findUsage  = selection.findUsage
			call.getHover  = selection.getHover
			call.Expression = selection.Expression
			call.args = args	
			result.pos = on.pos
			result.data = call	
		} else {
			result.Type = ast.ExpressionTypeFunctionCall
			result.op = "functionCall"
			call := new ast.ExpressionFunctionCall()
			call.Expression = on
			call.args = args
			result.data = call
			result.pos = pos
		}
        /*
		if this.parser.token.Type == lex.TokenLt { // <

				template function call return type binds
				fn a ()->(r T) {

				}
				a<int , ... >

			this.next(lfNotToken) // skip <
			ts, err = this.parser.parseTypes(lex.TokenGt)
			if err != null {
				return result, err
			}
			this.parser.ifTokenIsLfThenSkip()
			if this.parser.token.Type != lex.TokenGt {
				this.parser.errs.append(
					new error(sprintf("%s '<' and '>' not match",
						this.parser.errMsgPrefix())))
				this.parser.consume(untilGt)
			}
			this.next(lfIsToken)
			if result.Type == ast.ExpressionTypeFunctionCall {
				result.data.(ast.ExpressionFunctionCall).ParameterTypes = ts
			} else {
				result.data.(ast.ExpressionMethodCall).ParameterTypes = ts
			}
		}
		*/
		return result, null
	}

}
