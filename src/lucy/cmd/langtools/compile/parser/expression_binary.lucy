import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/lex"


class ExpressionBinaryParser extends ParserExtends{
	ep ExpressionParser
	fn ExpressionBinaryParser(parser Parser , ep ExpressionParser){
		this.super()
		this.parser = parser
		this.ep = ep 
	}


	// ||
	fn parseLogicalOrExpression() -> (e ast.Expression,err error) {
		left, err := this.parseLogicalAndExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenLogicalOr {
			pos := this.parser.mkPos()
			name := this.parser.token.Description
			this.Next(lfNotToken)
			right, err := this.parseLogicalAndExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Op = name
			newExpression.Type = ast.ExpressionTypeLogicalOr
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

	// &&
	fn parseLogicalAndExpression() -> (e ast.Expression,err error) {
		left, err := this.parseEqualExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenLogicalAnd {
			pos := this.parser.mkPos()
			name := this.parser.token.Description
			this.Next(lfNotToken)
			right, err := this.parseEqualExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Op = name
			newExpression.Type = ast.ExpressionTypeLogicalAnd
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

	// == and !=
	fn parseEqualExpression() -> (e ast.Expression,err error) {
		left, err := this.parseRelationExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenEqual ||
			this.parser.token.Type == lex.TokenNe {
			typ := this.parser.token.Type
			name := this.parser.token.Description
			pos := this.parser.mkPos()
			this.Next(lfNotToken)
			right, err := this.parseRelationExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Op = name
			if typ == lex.TokenEqual {
				newExpression.Type = ast.ExpressionTypeEq
			} else {
				newExpression.Type = ast.ExpressionTypeNe
			}
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

	// > < >= <=
	fn parseRelationExpression() -> (e ast.Expression,err error) {
		left, err := this.parseOrExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenGt ||
			this.parser.token.Type == lex.TokenGe ||
			this.parser.token.Type == lex.TokenLt ||
			this.parser.token.Type == lex.TokenLe {
			typ := this.parser.token.Type
			name := this.parser.token.Description
			pos := this.parser.mkPos()
			this.Next(lfNotToken)
			right, err := this.parseOrExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Op = name
			if typ == lex.TokenGt {
				newExpression.Type = ast.ExpressionTypeGt

			} else if typ == lex.TokenGe {
				newExpression.Type = ast.ExpressionTypeGe

			} else if typ == lex.TokenLt {
				newExpression.Type = ast.ExpressionTypeLt

			} else {
				newExpression.Type = ast.ExpressionTypeLe

			}
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

	//  |
	fn parseOrExpression() -> (e ast.Expression,err error) {
		left, err := this.parseXorExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenOr {
			pos := this.parser.mkPos()
			name := this.parser.token.Description
			this.Next(lfNotToken)
			right, err := this.parseXorExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Op = name
			newExpression.Type = ast.ExpressionTypeOr
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

	// ^
	fn parseXorExpression() -> (e ast.Expression,err error) {
		left, err := this.parseAndExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenXor {
			pos := this.parser.mkPos()
			name := this.parser.token.Description
			this.Next(lfNotToken)
			right, err := this.parseAndExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Op = name
			newExpression.Type = ast.ExpressionTypeXor
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

	// &
	fn parseAndExpression() -> (e ast.Expression,err error) {
		left, err := this.parseShiftExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenAnd {
			pos := this.parser.mkPos()
			name := this.parser.token.Description
			this.Next(lfNotToken)
			right, err := this.parseShiftExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Type = ast.ExpressionTypeAnd
			newExpression.Op = name
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

	// << >>
	fn parseShiftExpression() -> (e ast.Expression,err error) {
		left, err := this.parseAddExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenLsh ||
			this.parser.token.Type == lex.TokenRsh {
			typ := this.parser.token.Type
			name := this.parser.token.Description
			pos := this.parser.mkPos()
			this.Next(lfNotToken)
			right, err := this.parseAddExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Op = name
			if typ == lex.TokenLsh {
				newExpression.Type = ast.ExpressionTypeLsh

			} else {
				newExpression.Type = ast.ExpressionTypeRsh

			}
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

	// + -
	fn parseAddExpression() -> (e ast.Expression,err error) {
		left, err := this.parseMulExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenAdd ||
			this.parser.token.Type == lex.TokenSub {
			typ := this.parser.token.Type
			name := this.parser.token.Description
			pos := this.parser.mkPos()
			this.Next(lfNotToken)
			right, err := this.parseMulExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Op = name
			if typ == lex.TokenAdd {
				newExpression.Type = ast.ExpressionTypeAdd
			} else {
				newExpression.Type = ast.ExpressionTypeSub
			}
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

	// * / %
	fn parseMulExpression() -> (e ast.Expression,err error) {
		left, err := this.ep.ExpressionSuffix.parseSuffixExpression()
		if err != null {
			return null, err
		}
		for this.parser.token.Type == lex.TokenMul ||
			this.parser.token.Type == lex.TokenDiv ||
			this.parser.token.Type == lex.TokenMod {
			typ := this.parser.token.Type
			name := this.parser.token.Description
			pos := this.parser.mkPos()
			this.Next(lfNotToken)
			right, err := this.ep.ExpressionSuffix.parseSuffixExpression()
			if err != null {
				return left, err
			}
			newExpression := new ast.Expression()
			newExpression.Pos = pos
			newExpression.Op = name
			if typ == lex.TokenMul {
				newExpression.Type = ast.ExpressionTypeMul
			} else if typ == lex.TokenDiv {
				newExpression.Type = ast.ExpressionTypeDiv
			} else {
				newExpression.Type = ast.ExpressionTypeMod
			}
			binary := new ast.ExpressionBinary()
			binary.Left = left
			binary.Right = right
			newExpression.Data = binary
			left = newExpression
		}
		return left, null
	}

} 

