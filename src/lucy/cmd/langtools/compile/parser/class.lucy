import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/lex"
import "lucy/cmd/langtools/compile/jvm/cg"


class ClassParser extends  ParserExtends{

	fn ClassParser(parser Parser){
	    this.super()
	    this.parser = parser
	}
	

	fn parseClassName() -> (name ast.NameWithPos,err error) {
		if this.parser.token.Type != lex.TokenIdentifier {
			err = new error(sprintf("%s expect identifier for class`s name,but '%s'",
				this.parser.errMsgPrefix(), this.parser.token.Description))
			this.parser.errs.append( err)
			return null, err
		}
		className := this.parser.token.stringValue
		pos := this.parser.mkPos()
		this.Next(lfNotToken)
		if this.parser.token.Type == lex.TokenSelection {
			this.Next(lfNotToken) // skip .
			if this.parser.token.Type != lex.TokenIdentifier {
				err = new error(sprintf("%s expect identifer for class`s name,but '%s'",
					this.parser.errMsgPrefix(),
					this.parser.token.Description))
				this.parser.errs.append( err)
			} else {
				className += "." + this.parser.token.stringValue
				this.Next(lfNotToken) // skip name identifier
			}
		}
		name = new ast.NameWithPos(className ,pos )

	}

	fn parseImplementsInterfaces() -> (names []ast.NameWithPos,err error) {
		names = []ast.NameWithPos{}
		for this.parser.token.Type != lex.TokenEof {
		    var name ast.NameWithPos
			name, err = this.parseClassName()
			if err != null {
				return null, err
			}
			names.append(name)
			if this.parser.token.Type == lex.TokenComma {
				this.Next(lfNotToken)
			} else {
				break
			}
		}
	}

	fn parse(isAbstract bool) -> (classDefinition ast.Class, err error) {
		isInterface := this.parser.token.Type == lex.TokenInterface
		classDefinition = new ast.Class()
		if isInterface {
			classDefinition.accessFlags |= cg.AccClassInterface
			classDefinition.accessFlags |= cg.AccClassAbstract
		}
		if isAbstract {
			classDefinition.accessFlags |= cg.AccClassAbstract
		}
		this.Next(lfIsToken) // skip class key word
		this.parser.unExpectNewLineAndSkip()
		t, err := this.parseClassName()
		if t != null {
			classDefinition.name = t.name
		}
		classDefinition.block = new ast.Block()
		classDefinition.block.isClassBlock = true
		classDefinition.block.Class = classDefinition
		if err != null {
			if classDefinition.name == null ||
				classDefinition.name == "" {
				compileAutoName()
			}
			this.consume(untilLc)
		}
		classDefinition.pos = this.parser.mkPos()
		if this.parser.token.Type == lex.TokenExtends { // parse father expression
			this.Next(lfNotToken) // skip extends
			classDefinition.superClassName, err = this.parseClassName()
			if err != null {
				this.parser.errs.append( err)
				this.consume(untilLc)
			}
		}
		if this.parser.token.Type == lex.TokenImplements {
			this.Next(lfNotToken) // skip key word
			classDefinition.interfaceNames, err = this.parseImplementsInterfaces()
			if err != null {
				this.parser.errs.append( err)
				this.consume(untilLc)
			}
		}
		this.parser.ifTokenIsLfThenSkip()
		if this.parser.token.Type != lex.TokenLc {
			err = new error(sprintf("%s expect '{' but '%s'",
				this.parser.errMsgPrefix(), this.parser.token.Description))
			this.parser.errs.append( err)
			return null, err
		}
		
		this.Next(lfNotToken) // skip {
		comment := new CommentParser(this.parser)
		comment.parser = this.parser
		var isStatic           bool
		var	isVolatile         bool
		var	isSynchronized     bool
		var	isFinal            bool
		var	accessControlToken lex.Token
		fn resetProperty() {
			isStatic = false
			isVolatile = false
			isSynchronized = false
			isFinal = false
			isAbstract = false
			accessControlToken = null
		}
		for this.parser.token.Type != lex.TokenEof {
			if len(this.parser.errs) > this.parser.nErrors2Stop {
				break
			}
			switch this.parser.token.Type {
			case lex.TokenComment, lex.TokenMultiLineComment:
				comment.read()
			case lex.TokenRc:
				this.Next(lfNotToken)
				return
			case lex.TokenSemicolon, lex.TokenLf:
				this.Next(lfNotToken)
				continue
			case lex.TokenStatic:
				isStatic = true
				this.Next(lfIsToken)
				this.parser.unExpectNewLineAndSkip()
				if this.parser.token.Type == lex.TokenLc {
					this.Next(lfNotToken) // skip {
					block := new ast.Block()
					this.parser.BlockParser.parseStatementList(block, false)
					if this.parser.token.Type != lex.TokenRc {
						this.parser.errs.append(
							new error(sprintf("%s expect '}' , but '%s'", this.parser.errMsgPrefix(),
								this.parser.token.Description)))
					} else {
						this.Next(lfNotToken) // skip }
						if classDefinition.staticBlocks == null {
                            classDefinition.staticBlocks = [block]
						}else {
						    classDefinition.staticBlocks.append(block)
						}

					}
					continue
				}
				err = this.validAfterStatic()
				if err != null {
					this.parser.errs.append( err)
					isStatic = false
				}
			//access private
			case lex.TokenPublic, lex.TokenProtected, lex.TokenPrivate:
				accessControlToken = this.parser.token
				this.Next(lfIsToken)
				this.parser.unExpectNewLineAndSkip()
				err = this.validAfterAccessControlToken(accessControlToken.Description)
				if err != null {
					this.parser.errs.append( err)
					accessControlToken = null // set to null
				}
			case lex.TokenAbstract:
				this.Next(lfIsToken)
				this.parser.unExpectNewLineAndSkip()
				err = this.validAfterAbstract()
				if err != null {
					this.parser.errs.append( err)
					accessControlToken = null // set to null
				} else {
					isAbstract = true
				}
			case lex.TokenVolatile:
				isVolatile = true
				this.Next(lfIsToken)
				if err = this.validAfterVolatile(this.parser.token); err != null {
					this.parser.errs.append( err)
					isVolatile = false
				}
			case lex.TokenFinal:
				isFinal = true
				this.Next(lfIsToken)
				if err = this.validAfterFinal(); err != null {
					this.parser.errs.append(err)
					isFinal = false
				}
			case lex.TokenIdentifier:
				err = this.parseField(classDefinition, this.parser.errs, isStatic, isVolatile, accessControlToken, comment)
				if err != null {
					this.consume(untilSemicolonOrLf)
					this.Next(lfNotToken)
				}
				resetProperty()
			case lex.TokenConst: // const is for local use
				this.Next(lfIsToken)
				err = this.parseConst(classDefinition, comment)
				if err != null {
					this.consume(untilSemicolonOrLf)
					this.Next(lfNotToken)
					continue
				}
			case lex.TokenSynchronized:
				isSynchronized = true
				this.Next(lfIsToken)
				if err = this.validAfterSynchronized(); err != null {
					this.parser.errs.append( err)
					isSynchronized = false
				}
			case lex.TokenFn:
				if isAbstract &&
					(classDefinition.isAbstract() == false && classDefinition.IsInterface() == false) {
					this.parser.errs.append(
						new error(sprintf("%s cannot  abstact method is non-abstract class",
							this.parser.errMsgPrefix())))
				}
				var f ast.Function
				f, err = this.parser.FunctionParser.parse(true, isAbstract || isInterface)
				if err != null {
					resetProperty()
					this.Next(lfNotToken)
					continue
				}
				f.comment = comment.comment
				if classDefinition.methods == null {
					classDefinition.methods = new map { string -> []ast.ClassMethod }( )
				}
				if f.name == "" {
					f.name = compileAutoName()
				}
				m := new ast.ClassMethod()
				m.Function = f
				if accessControlToken != null {
					switch accessControlToken.Type {
					case lex.TokenPrivate:
						m.Function.accessFlags |= cg.AccMethodPrivate
					case lex.TokenProtected:
						m.Function.accessFlags |= cg.AccMethodProtected
					case lex.TokenPublic:
						m.Function.accessFlags |= cg.AccMethodPublic
					}
				}
				if isSynchronized {
					m.Function.accessFlags |= cg.AccMethodSynchronized
				}
				if isStatic {
					f.accessFlags |= cg.AccMethodStatic
				}
				if isAbstract || isInterface {
					f.accessFlags |= cg.AccMethodAbstract
				}
				if isFinal {
					f.accessFlags |= cg.AccMethodFinal
				}
				if f.name == classDefinition.name && isInterface == false {
					f.name = ast.SpecialMethodInit
				}
				if classDefinition.methods[f.name] == null {
                    classDefinition.methods[f.name] = [m]
				}else {
				    classDefinition.methods[f.name].append(m)
				}
				resetProperty()
			case lex.TokenImport:
				pos := this.parser.mkPos()
				this.parser.parseImports()
				this.parser.errs.append(
					new error(sprintf("%s cannot have import at this scope",
						this.parser.errMsgPrefix(pos))))
			default:
				this.parser.errs.append(
					new error(sprintf("%s unexpected '%s'",
						this.parser.errMsgPrefix(), this.parser.token.Description)))
				this.Next(lfNotToken)
			}
		}
		return
	}

	fn parseConst(classDefinition ast.Class, comment CommentParser) -> (err error) {
		cs, err := this.parser.parseConst()
		if err != null {
			return err
		}
		constComment := comment.comment
		if this.parser.token.Type == lex.TokenComment {
			this.Next(lfIsToken)
		} else {
			this.parser.validStatementEnding()
		}
		if classDefinition.block.constants == null {
			classDefinition.block.constants = new map { string -> ast.Constant }( )
		}
		for _, v := range cs {
			if classDefinition.block.constants.keyExist(v.name) {
				this.parser.errs.append(
					new error(sprintf("%s const %s alreay declared",
						this.parser.errMsgPrefix(), v.name)))
				continue
			}
			classDefinition.block.constants[v.name] = v
			v.comment = constComment
		}
		return null
	}

	fn parseField(
		classDefinition ast.Class,
		errs []error,
		isStatic bool,
		isVolatile bool,
		accessControlToken lex.Token,
		comment CommentParser) -> (err error) {
		names, err := this.parser.parseNameList()
		if err != null {
			return err
		}
		t, err := this.parser.parseType()
		if err != null {
			return err
		}
		var initValues []ast.Expression
		if this.parser.token.Type == lex.TokenAssign {
			this.parser.Next(lfNotToken) // skip = or :=
			initValues, err = this.parser.ExpressionParser.parseExpressions(lex.TokenSemicolon)
			if err != null {
				this.consume(untilSemicolonOrLf)
			}
		}
		fieldComment := comment.comment
		if this.parser.token.Type == lex.TokenComment {
			this.Next(lfIsToken)
		} else {
			this.parser.validStatementEnding()
		}
		if classDefinition.fields == null {
			classDefinition.fields = new map { string -> ast.ClassField } ()
		}
		for k, v := range names {
			if classDefinition.fields.keyExist(v.name) {
				this.parser.errs.append( new error(sprintf("%s field %s is alreay declared",
						this.parser.errMsgPrefix(), v.name)))
				continue
			}
			f := new ast.ClassField()
			f.name = v.name
			f.pos = v.pos
			f.Type = t.Clone()
			f.accessFlags = 0
			if k < len(initValues) {
				f.defaultValueExpression = initValues[k]
			}
			f.comment = fieldComment
			if isStatic {
				f.accessFlags |= cg.AccFieldStatic
			}
			if accessControlToken != null {
				switch accessControlToken.Type {
				case lex.TokenPublic:
					f.accessFlags |= cg.AccFieldPublic
				case lex.TokenProtected:
					f.accessFlags |= cg.AccFieldProtected
				default: // private
					f.accessFlags |= cg.AccFieldPrivate
				}
			}
			if isVolatile {
				f.accessFlags |= cg.AccFieldVolatile
			}
			classDefinition.fields[v.name] = f
		}
		return null
	}


	fn validAfterVolatile(token lex.Token) ->(err error)  {
		if token.Type == lex.TokenIdentifier {
			return null
		}
		return new error(sprintf("%s not a valid token after 'volatile'",
			this.parser.errMsgPrefix()))
	}
	fn validAfterAbstract() ->(err error) {
		if this.parser.token.Type == lex.TokenFn {
			return null
		}
		return new error(sprintf("%s not a valid token after 'abstract'",
			this.parser.errMsgPrefix()))
	}
	fn validAfterSynchronized() ->(err error) {
		if this.parser.token.Type == lex.TokenFn ||
			this.parser.token.Type == lex.TokenFinal {
			return null
		}
		return new error(sprintf("%s not a valid token after 'synchronized'",
			this.parser.errMsgPrefix()))
	}
	fn validAfterStatic() ->(err error) {
		if this.parser.token.Type == lex.TokenIdentifier ||
			this.parser.token.Type == lex.TokenFn ||
			this.parser.token.Type == lex.TokenFinal {
			return null
		}
		return new error(sprintf("%s not a valid token after 'static'",
			this.parser.errMsgPrefix()))
	}
	fn validAfterFinal() ->(err error) {
		if this.parser.token.Type == lex.TokenFn ||
			this.parser.token.Type == lex.TokenSynchronized {
			return null
		}
		return new error(sprintf("%s not a valid token after 'final'",
			this.parser.errMsgPrefix()))
	}
	fn validAfterAccessControlToken(keyWord string) ->(err error) {
		if this.parser.token.Type == lex.TokenIdentifier ||
			this.parser.token.Type == lex.TokenFn ||
			this.parser.token.Type == lex.TokenStatic ||
			this.parser.token.Type == lex.TokenSynchronized ||
			this.parser.token.Type == lex.TokenFinal ||
			this.parser.token.Type == lex.TokenAbstract {
			return null
		}
		return new error(sprintf("%s not a valid token after '%s'",
			this.parser.errMsgPrefix(), keyWord))
	}
}


