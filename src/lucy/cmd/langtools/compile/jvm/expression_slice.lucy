
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"


class BuildExpressionSlice {
    

    eb BuildExpression
    
    fn BuildExpressionSlice(eb BuildExpression){
        this.super()
        this.eb = eb
    }

    fn  buildStringSlice(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        stackLength := len(state.stacks)
        defer   {
            state.popStack(len(state.stacks) - stackLength)
        }
        slice := e.data.(ast.ExpressionSlice)
        maxStack = this.eb.build(c, code, slice.ExpressionOn, context, state)
        state.pushStack(c, state.newObjectVariableType(javaStringClass))
        // build start
        stack := this.eb.build(c, code, slice.start, context, state)
        if t := char(1) + stack; t > maxStack {
            maxStack = t
        }
        if slice.End != null {
            state.pushStack(c, slice.start.value)
            stack = this.eb.build(c, code, slice.End, context, state)
            if t := char(2) + stack; t > maxStack {
                maxStack = t
            }
            code.Codes[code.CodeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                javaStringClass,
                "substring",
                "(II)Ljava/lang/String;"
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
        } else {
            code.Codes[code.CodeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                javaStringClass,
                "substring",
                "(I)Ljava/lang/String;"
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
        }
        return
    }

    fn  buildSlice(c cg.ClassHighLevel, code cg.AttributeCode,
        e ast.Expression, context Context, state StackMapState) -> (maxStack char) {
        slice := e.data.(ast.ExpressionSlice)
        if slice.ExpressionOn.value.Type == ast.VariableTypeString {
            return this.buildStringSlice(c, code, e, context, state)
        }
        stackLength := len(state.stacks)
        defer  {
            state.popStack(len(state.stacks) - stackLength)
        }
        meta := ArrayMetas[e.value.array.Type]
        maxStack = this.eb.build(c, code, slice.ExpressionOn, context, state)
        state.pushStack(c, slice.ExpressionOn.value)
        if slice.End != null {
            // build start
            stack := this.eb.build(c, code, slice.start, context, state)
            if t := char(1) + stack; t > maxStack {
                maxStack = t
            }
            state.pushStack(c, slice.start.value)
            stack = this.eb.build(c, code, slice.End, context, state)
            if t := char(3) + stack; t > maxStack {
                maxStack = t
            }
        } else {
            code.Codes[code.CodeLength] = cg.OP_dup
            code.CodeLength++
            code.Codes[code.CodeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new  cg.ConstantInfoMethodrefHighLevel(
                meta.className,
                "size",
                "()I"
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
            state.pushStack(c, slice.start.value)
            stack := this.eb.build(c, code, slice.start, context, state)
            if t := char(2) + stack; t > maxStack {
                maxStack = t
            }
            code.Codes[code.CodeLength] = cg.OP_swap
            code.CodeLength++
        }
        code.Codes[code.CodeLength] = cg.OP_invokevirtual
        c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
            meta.className,
            "slice",
            meta.sliceDescriptor
        ), code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.CodeLength += 3
        return
    }


}


