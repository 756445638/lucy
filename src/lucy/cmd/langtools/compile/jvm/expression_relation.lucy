
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"

class BuildExpressionRelation {
    

    eb BuildExpression
    
    fn BuildExpressionRelation(eb BuildExpression){
        this.super()
        this.eb = eb
    }

    fn  buildRelations(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        bin := e.Data.(ast.ExpressionBinary)
        stackLength := len(state.Stacks)
        defer  {
            state.popStack(len(state.Stacks) - stackLength)
        }
        if bin.Left.Value.IsNumber() ||
            bin.Left.Value.Type == ast.VariableTypeEnum { // in this case ,right must be a number type
            maxStack = this.build(c, code, bin.Left, context, state)
            state.pushStack(c, bin.Left.Value)
            stack := this.build(c, code, bin.Right, context, state)
            if t := jvmSlotSize(bin.Left.Value) + stack; t > maxStack {
                maxStack = t
            }
            var exit cg.Exit
            if bin.Left.Value.Type == ast.VariableTypeByte ||
                bin.Left.Value.Type == ast.VariableTypeShort ||
                bin.Left.Value.Type == ast.VariableTypeChar ||
                bin.Left.Value.Type == ast.VariableTypeInt ||
                bin.Left.Value.Type == ast.VariableTypeEnum {
                switch e.Type {
                case ast.ExpressionTypeGt:
                    exit = new cg.Exit(cg.OP_if_icmpgt, code)
                case ast.ExpressionTypeLe:
                    exit = new cg.Exit(cg.OP_if_icmple, code)
                case ast.ExpressionTypeLt:
                    exit = new cg.Exit(cg.OP_if_icmplt, code)
                case ast.ExpressionTypeGe:
                    exit = new cg.Exit(cg.OP_if_icmpge, code)
                case ast.ExpressionTypeEq:
                    exit = new cg.Exit(cg.OP_if_icmpeq, code)
                case ast.ExpressionTypeNe:
                    exit = new cg.Exit(cg.OP_if_icmpne, code)
                }
            } else {
                switch bin.Left.Value.Type {
                case ast.VariableTypeLong:
                    code.Codes[code.CodeLength] = cg.OP_lcmp
                case ast.VariableTypeFloat:
                    code.Codes[code.CodeLength] = cg.OP_fcmpl
                case ast.VariableTypeDouble:
                    code.Codes[code.CodeLength] = cg.OP_dcmpl
                }
                code.CodeLength++
                switch e.Type {
                case ast.ExpressionTypeGt:
                    exit = new cg.Exit(cg.OP_ifgt, code)
                case ast.ExpressionTypeLe:
                    exit = new cg.Exit(cg.OP_ifle, code)
                case ast.ExpressionTypeLt:
                    exit = new cg.Exit(cg.OP_iflt, code)
                case ast.ExpressionTypeGe:
                    exit = new cg.Exit(cg.OP_ifge, code)
                case ast.ExpressionTypeEq:
                    exit = new cg.Exit(cg.OP_ifeq, code)
                case ast.ExpressionTypeNe:
                    exit = new cg.Exit(cg.OP_ifne, code)
                }
            }
            state.popStack(1)
            code.Codes[code.CodeLength] = cg.OP_iconst_0
            code.CodeLength++
            falseExit := new cg.Exit(cg.OP_goto, code)
            writeExits([]cg.Exit{exit}, code.CodeLength)
            context.MakeStackMap(code, state, code.CodeLength)
            code.Codes[code.CodeLength] = cg.OP_iconst_1
            code.CodeLength++
            writeExits([]cg.Exit{falseExit}, code.CodeLength)
            state.pushStack(c,typeBool)
            context.MakeStackMap(code, state, code.CodeLength)
            defer state.popStack(1)
            return
        }
        if bin.Left.Value.Type == ast.VariableTypeBool ||
            bin.Right.Value.Type == ast.VariableTypeBool { // bool type
            maxStack = this.build(c, code, bin.Left, context, state)
            state.pushStack(c, bin.Left.Value)
            stack := this.build(c, code, bin.Right, context, state)
            if t := jvmSlotSize(bin.Left.Value) + stack; t > maxStack {
                maxStack = t
            }
            state.popStack(1) // 1 bool value
            var exit cg.Exit
            if e.Type == ast.ExpressionTypeEq {
                exit = new cg.Exit(cg.OP_if_icmpeq, code)
            } else {
                exit = new cg.Exit(cg.OP_if_icmpne, code)
            }
            code.Codes[code.CodeLength] = cg.OP_iconst_0
            code.CodeLength++
            falseExit := new cg.Exit(cg.OP_goto, code)
            writeExits([]cg.Exit{exit}, code.CodeLength)
            context.MakeStackMap(code, state, code.CodeLength)
            code.Codes[code.CodeLength] = cg.OP_iconst_1
            code.CodeLength++
            writeExits([]cg.Exit{falseExit}, code.CodeLength)
            state.pushStack(c, typeBool)
            context.MakeStackMap(code, state, code.CodeLength)
            defer state.popStack(1)
            return
        }
        if bin.Left.Value.Type == ast.VariableTypeNull ||
            bin.Right.Value.Type == ast.VariableTypeNull { // must not null-null
            var notNullExpression ast.Expression
            if bin.Left.Value.Type != ast.VariableTypeNull {
                notNullExpression = bin.Left
            } else {
                notNullExpression = bin.Right
            }
            maxStack = this.build(c, code, notNullExpression, context, state)
            var exit cg.Exit
            if e.Type == ast.ExpressionTypeEq {
                exit = new cg.Exit(cg.OP_ifnull, code)
            } else { // ne
                exit = new cg.Exit(cg.OP_ifnonnull, code)
            }
            code.Codes[code.CodeLength] = cg.OP_iconst_0
            code.CodeLength++
            falseExit := new cg.Exit(cg.OP_goto, code)
            writeExits([]cg.Exit{exit}, code.CodeLength)
            context.MakeStackMap(code, state, code.CodeLength)
            code.Codes[code.CodeLength] = cg.OP_iconst_1
            code.CodeLength++
            writeExits([]cg.Exit{falseExit}, code.CodeLength)
            state.pushStack(c,typeBool)
            context.MakeStackMap(code, state, code.CodeLength)
            defer state.popStack(1)
            return
        }

        //string compare
        if bin.Left.Value.Type == ast.VariableTypeString {
            maxStack = this.build(c, code, bin.Left, context, state)
            state.pushStack(c, bin.Left.Value)
            stack := this.build(c, code, bin.Right, context, state)
            code.Codes[code.CodeLength] = cg.OP_invokevirtual
            c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                javaStringClass,
                "compareTo",
                "(Ljava/lang/String;)I"
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
            if t := 1 + stack; t > maxStack {
                maxStack = t
            }
            state.popStack(1) // pop left string
            var exit cg.Exit
            switch e.Type {
            case ast.ExpressionTypeGt:
                exit = new cg.Exit(cg.OP_ifgt, code)
            case ast.ExpressionTypeLe:
                exit = new cg.Exit(cg.OP_ifle, code)
            case ast.ExpressionTypeLt:
                exit = new cg.Exit(cg.OP_iflt, code)
            case ast.ExpressionTypeGe:
                exit = new cg.Exit(cg.OP_ifge, code)
            case ast.ExpressionTypeEq:
                exit = new cg.Exit(cg.OP_ifeq, code)
            case ast.ExpressionTypeNe:
                exit = new cg.Exit(cg.OP_ifne, code)
            }
            code.Codes[code.CodeLength] = cg.OP_iconst_0
            code.CodeLength++
            falseExit := new cg.Exit(cg.OP_goto, code)
            writeExits([]cg.Exit{exit}, code.CodeLength)
            context.MakeStackMap(code, state, code.CodeLength)
            code.Codes[code.CodeLength] = cg.OP_iconst_1
            code.CodeLength++
            writeExits([]cg.Exit{falseExit}, code.CodeLength)
            state.pushStack(c, typeBool)
            context.MakeStackMap(code, state, code.CodeLength)
            defer state.popStack(1)
            return
        }

        if bin.Left.Value.IsPointer() && bin.Right.Value.IsPointer() { //
            stack := this.build(c, code, bin.Left, context, state)
            if stack > maxStack {
                maxStack = stack
            }
            state.pushStack(c, bin.Left.Value)
            stack = this.build(c, code, bin.Right, context, state)
            if t := stack + 1; t > maxStack {
                maxStack = t
            }
            state.popStack(1)
            var exit cg.Exit
            if e.Type == ast.ExpressionTypeEq {
                exit = new cg.Exit(cg.OP_if_acmpeq, code)
            } else { // ne
                exit = new cg.Exit(cg.OP_if_acmpne, code)
            }
            code.Codes[code.CodeLength] = cg.OP_iconst_0
            code.CodeLength++
            falseExit := new cg.Exit(cg.OP_goto, code)
            writeExits([]cg.Exit{exit}, code.CodeLength)
            context.MakeStackMap(code, state, code.CodeLength)
            code.Codes[code.CodeLength] = cg.OP_iconst_1
            code.CodeLength++
            writeExits([]cg.Exit{falseExit}, code.CodeLength)
            state.pushStack(c,typeBool)
            context.MakeStackMap(code, state, code.CodeLength)
            defer state.popStack(1)
            return
        }
        return
    }




}

