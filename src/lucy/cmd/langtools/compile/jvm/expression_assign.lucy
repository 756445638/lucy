import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"

class  BuildExpressionAssign {
	

	eb BuildExpression
    
    fn BuildExpressionAssign(eb BuildExpression){
        this.super()
        this.eb = eb
    }

	fn  buildExpressionAssign(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		e ast.Expression,
		context Context,
		state StackMapState) -> (maxStack char) {
		stackLength := len(state.stacks)
		defer  {
			state.popStack(len(state.stacks) - stackLength)
		}
		assign := e.data.(ast.ExpressionAssign)
		left := assign.lefts[0]
		right := assign.values[0]
		var remainStack char
		var op []byte
		var leftValueKind LeftValueKind
		if left.isIdentifier(ast.UnderScore) == false {
			maxStack, remainStack, op, leftValueKind =
				this.eb.BuildExpressionLeftValue.getLeftValue(c, code, left, context, state)
		}
		stack := this.eb.build(c, code, right, context, state)
		if t := remainStack + stack; t > maxStack {
			maxStack = t
		}
		if left.isIdentifier(ast.UnderScore) {
			if jvmSlotSize(right.value) == 1 {
				code.codes[code.codeLength] = cg.OP_pop
			} else {
				code.codes[code.codeLength] = cg.OP_pop2
			}
			code.codeLength++
		} else {
			currentStack := remainStack + jvmSlotSize(left.value)
			if e.isStatementExpression == false {
				currentStack += this.eb.dupStackLeaveValueBelow(code, leftValueKind, left.value)
				if currentStack > maxStack {
					maxStack = currentStack
				}
			}
			copyOPs(code, op)
		}
		return
	}

	// a,b,c = 122,fdfd2232,"hello";
	fn  buildAssign(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		e ast.Expression,
		context Context,
		state StackMapState) -> (maxStack char) {
		assign := e.data.(ast.ExpressionAssign)
		if e.isStatementExpression == false || len(assign.lefts) == 1 {
			return this.buildExpressionAssign(c, code, e, context, state)
		}
		if len(assign.values) == 1 {
			maxStack = this.eb.build(c, code, assign.values[0], context, state)
		} else {
			maxStack = this.eb.buildExpressions(c, code, assign.values, context, state)
		}
		autoVar := new MultiValueAutoVar(c, code, state)
		for k, v := range assign.lefts {
			if v.isIdentifier(ast.UnderScore) {
				continue
			}
			stackLength := len(state.stacks)
			stack, remainStack, op, _ :=
				this.eb.BuildExpressionLeftValue.getLeftValue(c, code, v, context, state)
			if stack > maxStack {
				maxStack = stack
			}
			stack = autoVar.unPack(c, code, k, v.value)
			if t := remainStack + stack; t > maxStack {
				maxStack = t
			}
			copyOPs(code, op)
			state.popStack(len(state.stacks) - stackLength)
		}
		return
	}

	
	

}

