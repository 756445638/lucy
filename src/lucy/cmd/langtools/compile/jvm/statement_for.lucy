
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"

class BuildPackageFor {


    fn buildForStatement(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        s ast.StatementFor,
        context Context,
        state StackMapState) -> (maxStack char) {
        if s.RangeAttr != null {
            if s.RangeAttr.RangeOn.Value.Type == ast.VariableTypeArray {
                return this.buildForRangeStatementForArray(c, code, s, context, state)
            } else if s.RangeAttr.RangeOn.Value.Type == ast.VariableTypeJavaArray {
                return this.buildForRangeStatementForJavaArray(c, code, s, context, state)
            } else { // for map
                return this.buildForRangeStatementForMap(c, code, s, context, state)
            }
        }
        forState := new StackMapState(state)
        defer  {
            state.addTop(forState)
        }
        //init
        if s.Init != null {
            stack := this.BuildExpression.build(c, code, s.Init, context, forState)
            if stack > maxStack {
                maxStack = stack
            }
        }
        var firstTimeExit ast.Statement
        if s.Condition != null {
            stack, exit := this.BuildExpression.buildConditionNotOk(c, code, context, forState, s.Condition)
            if stack > maxStack {
                maxStack = stack
            }
            s.Exits = append(s.Exits, exit)
            firstTimeExit = new cg.Exit(cg.OP_goto, code) // goto body
        }
        s.ContinueCodeOffset = code.CodeLength
        context.MakeStackMap(code, forState, code.CodeLength)
        if s.Increment != null {
            stack := this.BuildExpression.build(c, code, s.Increment, context, forState)
            if stack > maxStack {
                maxStack = stack
            }
        }
        if s.Condition != null {
            stack, exit := this.BuildExpression.buildConditionNotOk(c, code, context, forState, s.Condition)
            if stack > maxStack {
                maxStack = stack
            }
            s.Exits = append(s.Exits, exit)
        }
        if firstTimeExit != null {
            writeExits([]cg.Exit{firstTimeExit}, code.CodeLength)
            context.MakeStackMap(code, forState, code.CodeLength)
        }
        this.buildBlock(c, code, s.Block, context, forState)
        if s.Block.NotExecuteToLastStatement == false {
            jumpTo(code, s.ContinueCodeOffset)
        }
        return
    }

}

