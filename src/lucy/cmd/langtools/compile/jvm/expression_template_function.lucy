// all rights reserved , check the LICENSE file

import "lucy/cmd/langtools/compile/ast"
import "lucy/jvm/cg"

class BuildTemplateFunctionCall {
    eb BuildExpression
    bp BuildPackage   

    fn BuildTemplateFunctionCall(eb BuildExpression , bp BuildPackage) {
        this.super()
        this.eb = eb
        this.bp = bp
    }

    fn buildTemplateFunctionCall(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionFunctionCall)
        if call.Function.templateFunction.Class == null {
            // new a class 
            className := this.bp.newClassName(call.Function.name)
            templateFunctionClass := new cg.ClassHighLevel(this.bp.majorVersion , this.bp.minorVersion)
            templateFunctionClass.accessFlags |= cg.AccClassSynthetic
            templateFunctionClass.name = className
            call.Function.templateFunction.Class = templateFunctionClass
            call.Function.templateFunction.Class.superClass = ast.JavaRootClass
            this.bp.mkClassDefaultConstruction(templateFunctionClass) 
            this.bp.putClass(templateFunctionClass)
            templateFunctionClass.insertSourceFile(call.Function.pos.filename)
        }
        if call.templateFunctionCallPair.entrance == null {
            method := new cg.MethodHighLevel()
            method.classHighLevel = call.Function.templateFunction.Class
            method.name = call.Function.templateFunction.Class.
                newMethodName(nameTemplateFunction(call.templateFunctionCallPair.Function))
            method.accessFlags |= cg.AccClassPublic
            method.accessFlags |= cg.AccClassFinal
            method.accessFlags |= cg.AccMethodStatic
            method.accessFlags |= cg.AccMethodBridge
            if call.templateFunctionCallPair.Function.Type.vArgs != null {
                method.accessFlags |= cg.AccMethodVarargs
            }
            method.descriptor = Descriptor.methodDescriptor(call.templateFunctionCallPair.Function.Type)
            method.code = new cg.AttributeCode()
            call.Function.templateFunction.Class.appendMethod(method)
            call.templateFunctionCallPair.Function.entrance = method
            //build function
            this.bp.BuildFunction.buildFunction(call.Function.templateFunction.Class , null , method , call.templateFunctionCallPair.Function)
            call.templateFunctionCallPair.entrance = method
        }
        maxStack = this.eb.BuildExpressionCallArgs.buildCallArgs(c , code , call.args , call.vArgs , context , state)
        code.codes[code.codeLength] = cg.OP_invokestatic
        c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(call.templateFunctionCallPair.entrance.classHighLevel.name,
                call.templateFunctionCallPair.entrance.name,
                call.templateFunctionCallPair.entrance.descriptor),
            code.codes[code.codeLength + 1 : code.codeLength + 3])
        code.codeLength += 3
        if e.isStatementExpression {
            if call.templateFunctionCallPair.Function.Type.voidReturn() == false {
                if len(call.templateFunctionCallPair.Function.Type.returnList) > 1 {
                    code.codes[code.codeLength] = cg.OP_pop
                    code.codeLength++
                } else {
                    if jvmSlotSize(e.value) == 1 {
                        code.codes[code.codeLength] = cg.OP_pop
                        code.codeLength++
                    } else {
                        code.codes[code.codeLength] = cg.OP_pop2
                        code.codeLength++
                    }

                }

            }
        }
        return
    }

}


