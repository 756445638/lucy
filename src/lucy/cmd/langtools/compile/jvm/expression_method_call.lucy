
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"

class BuildExpressionMethodCall {

    eb BuildExpression
    
    fn BuildExpressionMethodCall(eb BuildExpression){
        this.super()
        this.eb = eb
    }


    fn  buildMethodCall(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionMethodCall)

        switch call.Expression.value.Type {
        case call.FieldMethodHandler != null:
            return this.buildMethodCallOnFieldHandler(c, code, e, context, state)
        case ast.VariableTypeArray:
            return this.eb.BuildExpressionArray.buildMethodCallOnArray(c, code, e, context, state)
        case ast.VariableTypeMap:
            return this.eb.BuildExpressionMap.buildMethodCallOnMap(c, code, e, context, state)
        case ast.VariableTypeJavaArray:
            return this.eb.BuildExpressionArray.buildMethodCallJavaOnArray(c, code, e, context, state)
        case ast.VariableTypePackage:
            return this.buildMethodCallOnPackage(c, code, e, context, state)
        case ast.VariableTypeDynamicSelector:
            return this.buildMethodCallOnDynamicSelector(c, code, e, context, state)
        case ast.VariableTypeClass:
            if call.Method.Function.jvmDescriptor == null ||
                call.Method.Function.jvmDescriptor == "" {
                call.Method.Function.jvmDescriptor = Descriptor.methodDescriptor(call.Method.Function.Type)
            }
            maxStack = this.eb.BuildExpressionCallArgs.buildCallArgs(c, code, call.args, call.vArgs, context, state)
            code.codes[code.codeLength] = cg.OP_invokestatic
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                call.Class.name,
                call.name,
                call.Method.Function.jvmDescriptor
            ), code.codes[code.codeLength+1:code.codeLength+3])
            code.codeLength += 3
            if t := jvmSize(e); t > maxStack {
                maxStack = t
            }
            if t := popCallResult(code, e,  call.Method.Function.Type); t > maxStack {
                maxStack = t
            }
            return
        case ast.VariableTypeObject, ast.VariableTypeString:
            if call.Method.Function.jvmDescriptor == null ||
                call.Method.Function.jvmDescriptor == "" {
                call.Method.Function.jvmDescriptor = Descriptor.methodDescriptor(call.Method.Function.Type)
            }
            maxStack = this.eb.build(c, code, call.Expression, context, state)
            // object ref
            state.pushStack(c, call.Expression.value)
            defer state.popStack(1)
            if call.name == ast.SpecialMethodInit {
                state.popStack(1)
                v := new cg.StackMapUninitializedThisVariableInfo() // make_node_objects it right
                t := new cg.StackMapVerificationTypeInfo()
                t.Verify = v
                state.stacks.append( t )
            }
            stack := this.eb.BuildExpressionCallArgs.buildCallArgs(c, code, call.args, call.vArgs, context, state)
            if t := stack + 1; t > maxStack {
                maxStack = t
            }
            if t := jvmSize(e); t > maxStack {
                maxStack = t
            }
            if call.name == ast.SpecialMethodInit { // call father construction method
                code.codes[code.codeLength] = cg.OP_invokespecial
                c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                    call.Class.name,
                    call.name,
                    call.Method.Function.jvmDescriptor
                ), code.codes[code.codeLength+1:code.codeLength+3])
                code.codeLength += 3
                return
            }
            if call.Class.IsInterface() {
                code.codes[code.codeLength] = cg.OP_invokeinterface
                c.insertInterfaceMethodrefConst(new cg.ConstantInfoInterfaceMethodrefHighLevel(
                    call.Class.name,
                    call.name,
                    call.Method.Function.jvmDescriptor
                ), code.codes[code.codeLength+1:code.codeLength+3])
                code.codes[code.codeLength+3] = interfaceMethodArgsCount(call.Method.Function.Type)
                code.codes[code.codeLength+4] = 0
                code.codeLength += 5
            } else {
                code.codes[code.codeLength] = cg.OP_invokevirtual
                c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                    call.Class.name,
                    call.name,
                    call.Method.Function.jvmDescriptor
                ), code.codes[code.codeLength+1:code.codeLength+3])
                code.codeLength += 3
            }
            if t := popCallResult(code, e, call.Method.Function.Type); t > maxStack {
                maxStack = t
            }
            return
        default:
            panic(call.Expression.value.typeString())
        }
        return
    }
    fn  buildMethodCallOnFieldHandler(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionMethodCall)
        if call.FieldMethodHandler.isStatic() == false {
            stack := this.eb.build(c, code, call.Expression, context, state)
            if stack > maxStack {
                maxStack = stack
            }
            code.codes[code.codeLength] = cg.OP_getfield
            code.codeLength++
        } else {
            code.codes[code.codeLength] = cg.OP_getstatic
            code.codeLength++
        }
        c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
            call.Expression.value.Class.name,
            call.name,
            Descriptor.typeDescriptor(call.FieldMethodHandler.Type)
        ), code.codes[code.codeLength:code.codeLength+2])
        code.codeLength += 2
        state.pushStack(c, state.newObjectVariableType(javaMethodHandleClass))
        defer state.popStack(1)
        stack := this.eb.BuildExpressionCallArgs.buildCallArgs(
            c, code, call.args, call.vArgs,
            context, state)
        if t := char(1) + stack; t > maxStack {
            maxStack = t
        }
        code.codes[code.codeLength] = cg.OP_invokevirtual
        c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
            javaMethodHandleClass,
            methodHandleInvokeMethodName,
            Descriptor.methodDescriptor(call.FieldMethodHandler.Type.functionType)
        ), code.codes[code.codeLength+1:code.codeLength+3])
        code.codeLength += 3
        if t := popCallResult(code, e, call.FieldMethodHandler.Type.functionType); t > maxStack {
            maxStack = t
        }
        return
    }
    fn  buildMethodCallOnDynamicSelector(c cg.ClassHighLevel, code cg.AttributeCode,
        e ast.Expression, context Context, state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionMethodCall)
        if call.FieldMethodHandler != null {
            if call.FieldMethodHandler.isStatic() == false {
                code.codes[code.codeLength] = cg.OP_aload_0
                code.codeLength++
                if 1 > maxStack {
                    maxStack = 1
                }
                code.codes[code.codeLength] = cg.OP_getfield
                code.codeLength++
            } else {
                code.codes[code.codeLength] = cg.OP_getstatic
                code.codeLength++
            }
            c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
                call.Expression.value.Class.name,
                call.name,
                Descriptor.typeDescriptor(call.FieldMethodHandler.Type)
            ), code.codes[code.codeLength:code.codeLength+2])
            code.codeLength += 2
            state.pushStack(c, state.newObjectVariableType(javaMethodHandleClass))
            defer state.popStack(1)
            stack := this.eb.BuildExpressionCallArgs.buildCallArgs(c, code, call.args, call.vArgs,
                context, state)
            if t := char(1) + stack; t > maxStack {
                maxStack = t
            }
            code.codes[code.codeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                javaMethodHandleClass,
                methodHandleInvokeMethodName,
                Descriptor.methodDescriptor(call.FieldMethodHandler.Type.functionType)
            ), code.codes[code.codeLength+1:code.codeLength+3])
            code.codeLength += 3
            if t := popCallResult(code, e, call.FieldMethodHandler.Type.functionType); t > maxStack {
                maxStack = t
            }
        } else {
            currentStack := char(0)
            if call.Method.isStatic() == false {
                code.codes[code.codeLength] = cg.OP_aload_0
                code.codeLength++
                state.pushStack(c, state.newObjectVariableType(call.Expression.value.Class.name))
                defer state.popStack(1)
                currentStack = 1
            }
            stack := this.eb.BuildExpressionCallArgs.buildCallArgs(c, code, call.args, call.vArgs,
                context, state)
            if t := currentStack + stack; t > maxStack {
                maxStack = t
            }
            if call.Method.isStatic() {
                code.codes[code.codeLength] = cg.OP_invokestatic
                code.codeLength++
            } else {
                code.codes[code.codeLength] = cg.OP_invokevirtual
                code.codeLength++
            }
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                call.Expression.value.Class.name,
                call.name,
                Descriptor.methodDescriptor(call.Method.Function.Type)
            ), code.codes[code.codeLength:code.codeLength+2])
            code.codeLength += 2
            if t := popCallResult(code, e, call.Method.Function.Type); t > maxStack {
                maxStack = t
            }
        }
        return
    }
    fn  buildMethodCallOnPackage(c cg.ClassHighLevel, code cg.AttributeCode,
        e ast.Expression, context Context, state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionMethodCall)
        if call.PackageFunction != null {
            stack := this.eb.BuildExpressionCallArgs.buildCallArgs(c, code, call.args, call.vArgs, context, state)
            if stack > maxStack {
                maxStack = stack
            }
            code.codes[code.codeLength] = cg.OP_invokestatic
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                call.Expression.value.Package.name + "/main",
                call.name,
                Descriptor.methodDescriptor(call.PackageFunction.Type)
            ), code.codes[code.codeLength+1:code.codeLength+3])
            code.codeLength += 3
            if t := popCallResult(code, e, call.PackageFunction.Type); t > maxStack {
                maxStack = t
            }
        } else {
            //call.PackageGlobalVariableFunction != null
            code.codes[code.codeLength] = cg.OP_getstatic
            c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
                call.Expression.value.Package.name + "/main",
                call.name,
                Descriptor.typeDescriptor(call.PackageGlobalVariableFunction.Type)
            ), code.codes[code.codeLength+1:code.codeLength+3])
            code.codeLength += 3
            state.pushStack(c, call.PackageGlobalVariableFunction.Type)
            defer state.popStack(1)
            stack := this.eb.BuildExpressionCallArgs.buildCallArgs(c, code, call.args, call.vArgs, context, state)
            if t := char(1) + stack; t > maxStack {
                maxStack = t
            }
            code.codes[code.codeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                "java/lang/invoke/MethodHandle",
                methodHandleInvokeMethodName,
                Descriptor.methodDescriptor(call.PackageGlobalVariableFunction.Type.functionType)
            ), code.codes[code.codeLength+1:code.codeLength+3])
            code.codeLength += 3
            if t := popCallResult(code, e, call.PackageGlobalVariableFunction.Type.functionType); t > maxStack {
                maxStack = t
            }
        }
        return
    }






}


