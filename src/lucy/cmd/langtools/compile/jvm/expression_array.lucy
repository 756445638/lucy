import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"
import "lucy/cmd/langtools/compile/common"



class BuildExpressionArray {
	eb BuildExpression
    
    fn BuildExpressionArray(eb BuildExpression){
        this.super()
        this.eb = eb
    }
    

	fn buildArray(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		e ast.Expression,
		context Context,
		state StackMapState) -> (maxStack char) {
		length := len(state.Stacks)
		defer {
			state.popStack(len(state.Stacks) - length)
		}
		arr := e.data.(ast.ExpressionArray)
		//	new array
		meta := ArrayMetas[e.value.array.Type]
		code.Codes[code.CodeLength] = cg.OP_new
		c.InsertClassConst(meta.className, code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.Codes[code.CodeLength+3] = cg.OP_dup
		code.CodeLength += 4
		{
			verify := new cg.StackMapVerificationTypeInfo()
			unInit := new cg.StackMapUninitializedVariableInfo(char(code.CodeLength - 4))
			verify.Verify = unInit
			state.Stacks = append(state.Stacks, verify, verify)
		}
		loadInt32(c, code, int(len(arr.Expressions)))
		newArrayBaseOnType(c, code, e.value.array)
		arrayObject := new ast.Type()
		arrayObject.Type = ast.VariableTypeJavaArray
		arrayObject.array = e.value.array
		state.pushStack(c, arrayObject)
		maxStack = 3
		storeOP := storeArrayElementOp(e.value.array.Type)
		var index int = 0
		for _, v := range arr.Expressions {
			code.Codes[code.CodeLength] = cg.OP_dup
			code.CodeLength++
			loadInt32(c, code, index) // load index
			state.pushStack(c, arrayObject)
			state.pushStack(c, typeInt)
			stack := this.eb.build(c, code, v, context, state)
			state.popStack(2)
			if t := 5 + stack; t > maxStack {
				maxStack = t
			}
			code.Codes[code.CodeLength] = storeOP
			code.CodeLength++
			index++
		}
		code.Codes[code.CodeLength] = cg.OP_invokespecial
		c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
			 meta.className,
			 specialMethodInit,
			 meta.constructorFuncDescriptor
		), code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.CodeLength += 3
		return
	}


   fn buildMethodCallJavaOnArray(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionMethodCall)
        maxStack = this.eb.build(c, code, call.Expression, context, state)
        switch call.name {
        case common.ArrayMethodSize:
            code.Codes[code.CodeLength] = cg.OP_arraylength
            code.CodeLength++
            if e.isStatementExpression {
                code.Codes[code.CodeLength] = cg.OP_pop
                code.CodeLength++
            }
        }
        return
    }

   fn buildMethodCallOnArray(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        length := len(state.Stacks)
        defer {
            state.popStack(len(state.Stacks) - length) // ref type
        }
        call := e.data.(ast.ExpressionMethodCall)
        maxStack = this.eb.build(c, code, call.Expression, context, state)
        state.pushStack(c, call.Expression.value)
        switch call.name {
        case common.ArrayMethodSize,
            common.ArrayMethodStart,
            common.ArrayMethodCap,
            common.ArrayMethodEnd:
            meta := ArrayMetas[call.Expression.value.array.Type]
            code.Codes[code.CodeLength] = cg.OP_invokevirtual
            c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                      meta.className,
                    call.name,
                "()I"
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
            if e.isStatementExpression {
                code.Codes[code.CodeLength] = cg.OP_pop
                code.CodeLength++
            }
        case common.ArrayMethodAppend:
            meta := ArrayMetas[call.Expression.value.array.Type]
            for k, v := range call.Args {
                currentStack := char(1)
                if k != len(call.Args)-1 {
                    code.Codes[code.CodeLength] = cg.OP_dup
                    code.CodeLength++
                    state.pushStack(c, call.Expression.value)
                    currentStack++
                }
                stack := this.eb.build(c, code, v, context, state)
                if t := stack + currentStack; t > maxStack {
                    maxStack = t
                }
                code.Codes[code.CodeLength] = cg.OP_invokevirtual
                c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                     meta.className,
                     "append",
                     meta.appendDescriptor
                ), code.Codes[code.CodeLength+1:code.CodeLength+3])
                code.CodeLength += 3
                if k != len(call.Args)-1 {
                    state.popStack(1)
                }
            }
        case common.ArrayMethodAppendAll:
            meta := ArrayMetas[call.Expression.value.array.Type]
            for k, v := range call.Args {
                currentStack := char(1)
                if k != len(call.Args)-1 {
                    code.Codes[code.CodeLength] = cg.OP_dup
                    code.CodeLength++
                    state.pushStack(c, call.Expression.value)
                    currentStack++
                }
                stack := this.eb.build(c, code, v, context, state)
                if t := stack + currentStack; t > maxStack {
                    maxStack = t
                }
                //get elements field
                code.Codes[code.CodeLength] = cg.OP_invokevirtual
                c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                    meta.className,
                    "append",
                    meta.appendAllDescriptor
                ), code.Codes[code.CodeLength+1:code.CodeLength+3])
                code.CodeLength += 3
                if k != len(call.Args)-1 {
                    state.popStack(1)
                }
            }
        case common.ArrayMethodGetUnderlyingArray:
            meta := ArrayMetas[call.Expression.value.array.Type]
            code.Codes[code.CodeLength] = cg.OP_getfield
            c.InsertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
                meta.className,
                "elements",
                meta.elementsFieldDescriptor
            ),
                code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
            if meta.elementsFieldDescriptor != Descriptor.typeDescriptor(e.value) {
                TypeConverterAndPrimitivePacker.castPointer(c, code, e.value)
            }
            if e.isStatementExpression {
                code.Codes[code.CodeLength] = cg.OP_pop
                code.CodeLength++
            }
        }

        return
    }












}

