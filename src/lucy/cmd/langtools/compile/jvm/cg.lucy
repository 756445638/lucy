import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg" 

class  BuildPackage {
	Package         ast.Package
	classes         map { string -> cg.ClassHighLevel }
	mainClass       cg.ClassHighLevel
	BuildExpression BuildExpression

    fn Make(p ast.Package) {
        this.Package = p
        mainClass := new cg.ClassHighLevel()
        this.mainClass = mainClass
        mainClass.accessFlags |= cg.AccClassPublic
        mainClass.accessFlags |= cg.AccClassFinal
        mainClass.accessFlags |= cg.AccClassSynthetic
        mainClass.superClass = ast.JavaRootClass
        mainClass.name = p.name + "/main"
        if p.block.Functions != null {
            for _, v := range p.block.Functions {
                mainClass.InsertSourceFile(v.pos.Filename)
                break
            }
        }
        mainClass.fields = new map {string -> cg.FieldHighLevel }()
        this.mkClassDefaultConstruction(this.mainClass)
        this.BuildExpression.BuildPackage = this
        this.classes = new map { string -> cg.ClassHighLevel } ()
        this.mkGlobalConstants()
        this.mkGlobalTypeAlias()
        this.mkGlobalVariables()
        this.mkGlobalFunctions()
        this.mkInitFunctions()
        for _, v := range p.block.Classes {
            this.putClass(this.buildClass(v))
        }
        for _, v := range p.block.Enums {
            this.putClass(this.mkEnum(v))
        }
        this.DumpClass()
    }

    fn newClassName(prefix string) -> (autoName string) {
        for i := 0; i < 65536; i++ {
            if i == 0 {
                //use prefix only
                autoName = prefix
            } else {
                autoName = sprintf("%s$%d", prefix, i)
            }
            if _, exists := this.Package.Block.NameExists(autoName); exists {
                continue
            }
            autoName = this.Package.name + "/" + autoName
            if this.classes != null && this.classes[autoName] != null {
                continue
            } else {
                return autoName
            }
        }
        panic("new class name overflow") // impossible
    }

    fn putClass(c cg.ClassHighLevel) {
        if ast.TypeName == "" {
            panic("missing name")
        }
        name := c.name
        if name == this.mainClass.name {
            panic("cannot have main class`s name")
        }
        if this.classes == null {
            this.classes = new map { string -> cg.ClassHighLevel }()
        }
        if this.classes.keyExist(name) {
            panic(sprintf("name:'%s' already been token", name))
        }
        this.classes[name] = c
    }

    fn mkEnum(e ast.Enum) -> (c cg.ClassHighLevel) {
        c := new cg.ClassHighLevel()
        ast.TypeName = e.name
        ast.TypeInsertSourceFile(e.pos.Filename)
        ast.TypeAccessFlags = e.accessFlags
        ast.TypeSuperClass = ast.JavaRootClass
        ast.TypeFields = new map { string -> cg.FieldHighLevel } ()
        ast.TypeClass.AttributeLucyEnum = new cg.AttributeLucyEnum()
        if e.comment != "" {
            ast.TypeClass.AttributeLucyComment = new cg.AttributeLucyComment()
            ast.TypeClass.AttributeLucyComment.comment = e.comment
        }
        for _, v := range e.Enums {
            field := new cg.FieldHighLevel()
            if e.accessFlags&cg.AccClassPublic != 0 {
                field.accessFlags |= cg.AccFieldPublic
            } else {
                field.accessFlags |= cg.AccFieldPrivate
            }
            if v.comment != "" {
                field.AttributeLucyComment = new cg.AttributeLucyComment()
                field.AttributeLucyComment.comment = v.comment
            }
            field.name = v.name
            field.Descriptor = "I"
            field.AttributeConstantValue = new cg.AttributeConstantValue()
            field.AttributeConstantValue.Index = c.InsertIntConst(v.value)
            ast.TypeFields[v.name] = field
        }
        return c
    }

    fn mkGlobalConstants() {
        for k, v := range this.Package.Block.constants {
            f := new cg.FieldHighLevel()
            f.accessFlags |= cg.AccFieldStatic
            f.accessFlags |= cg.AccFieldFinal
            if v.accessFlags&cg.AccFieldPublic != 0 {
                f.accessFlags |= cg.AccFieldPublic
            }
            f.name = v.name
            f.AttributeConstantValue = new cg.AttributeConstantValue()
            f.AttributeConstantValue.Index = this.insertDefaultValue(this.mainClass, v.Type, v.value)
            f.AttributeLucyConst = new cg.AttributeLucyConst()
            if v.comment != "" {
                f.AttributeLucyComment = new cg.AttributeLucyComment()
                f.AttributeLucyComment.comment = v.comment
            }
            f.Descriptor = Descriptor.typeDescriptor(v.Type)
            this.mainClass.fields[k] = f
        }
    }
    fn mkGlobalTypeAlias() {
        for name, v := range this.Package.Block.TypeAliases {
            t := new cg.AttributeLucyTypeAlias()
            t.alias = LucyTypeAlias.Encode(name, v)
            if v.alias != null {
                t.comment = v.alias.comment
            }
            this.mainClass.Class.TypeAlias = append(this.mainClass.Class.TypeAlias, t)
        }
    }

    fn mkGlobalVariables() {
        for k, v := range this.Package.Block.Variables {
            f := new cg.FieldHighLevel()
            f.accessFlags |= cg.AccFieldStatic
            f.Descriptor = Descriptor.typeDescriptor(v.Type)
            if v.accessFlags&cg.AccFieldPublic != 0 {
                f.accessFlags |= cg.AccFieldPublic
            }
            f.accessFlags |= cg.AccFieldVolatile
            if LucyFieldSignature.Need(v.Type) {
                f.AttributeLucyFieldDescriptor = new cg.AttributeLucyFieldDescriptor()
                f.AttributeLucyFieldDescriptor.Descriptor = LucyFieldSignature.Encode(v.Type)
                if v.Type.FunctionType.VArgs != null {
                    f.AttributeLucyFieldDescriptor.MethodAccessFlag |=
                        cg.AccMethodVarargs
                }
            }
            v.globalVarClassName = this.mainClass.name
            if v.comment != "" {
                f.AttributeLucyComment = new cg.AttributeLucyComment ()
                f.AttributeLucyComment.comment = v.comment
            }
            f.name = v.name
            this.mainClass.fields[k] = f
        }
    }

    fn mkInitFunctions() {
        if len(this.Package.InitFunctions) == 0 {
            needTrigger := false
            for _, v := range this.Package.LoadedPackages {
                if v.TriggerPackageInitMethodName != "" {
                    needTrigger = true
                    break
                }
            }
            if needTrigger == false {
                return
            }
        }
        blockMethods := []cg.MethodHighLevel{}
        for _, v := range this.Package.InitFunctions {
            method := new  cg.MethodHighLevel()
            blockMethods = append(blockMethods, method)
            method.accessFlags |= cg.AccMethodStatic
            method.accessFlags |= cg.AccMethodFinal
            method.accessFlags |= cg.AccMethodPrivate
            method.name = this.mainClass.NewMethodName("block")
            method.Class = this.mainClass
            method.Descriptor = "()V"
            method.Code = new cg.AttributeCode()
            this.buildFunction(this.mainClass, null, method, v)
            this.mainClass.AppendMethod(method)
        }
        method := new cg.MethodHighLevel()
        method.accessFlags |= cg.AccMethodStatic
        method.name = "<clinit>"
        method.Descriptor = "()V"
        codes := new []byte (65536)
        codeLength := int(0)
        method.Code = new cg.AttributeCode()
        for _, v := range this.Package.LoadedPackages {
            if v.TriggerPackageInitMethodName == "" {
                continue
            }
            codes[codeLength] = cg.OP_invokestatic
            this.mainClass.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                   v.name + "/main", // main c
                    v.TriggerPackageInitMethodName,
                "()V"
            ), codes[codeLength+1:codeLength+3])
            codeLength += 3
        }
        for _, v := range blockMethods {
            codes[codeLength] = cg.OP_invokestatic
            this.mainClass.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                   this.mainClass.name,
                    v.name,
                 "()V"
            ), codes[codeLength+1:codeLength+3])
            codeLength += 3
        }
        codes[codeLength] = cg.OP_return
        codeLength++
        codes = codes[0:codeLength]
        method.Code.Codes = codes
        method.Code.CodeLength = codeLength
        this.mainClass.AppendMethod(method)

        // trigger init
        trigger := new cg.MethodHighLevel()
        trigger.name = this.mainClass.NewMethodName("triggerPackageInit")
        trigger.accessFlags |= cg.AccMethodPublic
        trigger.accessFlags |= cg.AccMethodBridge
        trigger.accessFlags |= cg.AccMethodStatic
        trigger.accessFlags |= cg.AccMethodSynthetic
        trigger.Descriptor = "()V"
        trigger.Code = new cg.AttributeCode()
        trigger.Code.Codes = new []byte(1)
        trigger.Code.Codes[0] = cg.OP_return
        trigger.Code.CodeLength = 1
        trigger.AttributeLucyTriggerPackageInitMethod = new cg.AttributeLucyTriggerPackageInitMethod()
        this.mainClass.AppendMethod(trigger)
        this.mainClass.TriggerPackageInitMethod = trigger
    }
    /*
    fn insertDefaultValue(c cg.ClassHighLevel, t ast.Type, v interface{}) -> (index char) {
        switch t.Type {
        case ast.VariableTypeBool:
            if v.(bool) {
                index = c.Class.InsertIntConst(1)
            } else {
                index = c.Class.InsertIntConst(0)
            }
        case ast.VariableTypeByte:
            index = c.Class.InsertIntConst(int(v.(long)))
        case ast.VariableTypeShort:
            index = c.Class.InsertIntConst(int(v.(long)))
        case ast.VariableTypeChar:
            index = c.Class.InsertIntConst(int(v.(long)))
        case ast.VariableTypeInt:
            index = c.Class.InsertIntConst(int(v.(long)))
        case ast.VariableTypeLong:
            index = c.Class.InsertLongConst(v.(long))
        case ast.VariableTypeFloat:
            index = c.Class.InsertFloatConst(v.(float))
        case ast.VariableTypeDouble:
            index = c.Class.InsertDoubleConst(v.(double))
        case ast.VariableTypeString:
            index = c.Class.InsertStringConst(v.(string))
        default:
            panic("no match")
        }
        return
    }*/


    fn buildClass(astClass ast.Class) -> (c cg.ClassHighLevel) {
        c = new cg.ClassHighLevel()
        c.name = astClass.name
        c.InsertSourceFile(astClass.pos.Filename)
        c.accessFlags = astClass.accessFlags
        if astClass.superClass != null {
            c.superClass = astClass.superClass.name
        } else {
            c.superClass = astClass.superClassName.name
        }
        if astClass.comment != "" {
            c.Class.AttributeLucyComment = new cg.AttributeLucyComment()
            c.Class.AttributeLucyComment.comment = astClass.comment
        }
        if len(astClass.Block.constants) > 0 {
            attr := new cg.AttributeLucyClassConst()
            for _, v := range astClass.Block.constants {
                cos := new cg.LucyClassConst()
                cos.name = v.name
                cos.comment = v.comment
                cos.Descriptor = Descriptor.typeDescriptor(v.Type)
                cos.ValueIndex = this.insertDefaultValue(c, v.Type, v.value)
                attr.constants = append(attr.constants, c)
            }
            c.Class.AttributeLucyClassConst = attr
        }
        c.fields = new map {string -> cg.FieldHighLevel } ()
        c.methods = new map { string -> []cg.MethodHighLevel } ()
        for _, v := range astClass.interfaces {
            c.interfaces = append(c.interfaces, v.name)
        }
        for _, v := range astClass.fields {
            f := new cg.FieldHighLevel()
            f.name = v.name
            f.accessFlags = v.accessFlags
            if v.IsStatic() && v.DefaultValue != null {
                f.AttributeConstantValue = new cg.AttributeConstantValue()
                f.AttributeConstantValue.Index = this.insertDefaultValue(c, v.Type,
                    v.DefaultValue)
            }
            f.Descriptor = Descriptor.typeDescriptor(v.Type)
            if LucyFieldSignature.Need(v.Type) {
                t := new cg.AttributeLucyFieldDescriptor()
                t.Descriptor = LucyFieldSignature.Encode(v.Type)
                f.AttributeLucyFieldDescriptor = t
            }
            if v.comment != "" {
                f.AttributeLucyComment = new cg.AttributeLucyComment()
                f.AttributeLucyComment.comment = v.comment
            }
            c.fields[v.name] = f
        }
        for name, v := range astClass.methods {
            vv := v[0]
            method := new cg.MethodHighLevel()
            method.name = name
            method.accessFlags = vv.Function.accessFlags
            if vv.Function.Type.VArgs != null {
                method.accessFlags |= cg.AccMethodVarargs
            }
            if vv.IsCompilerAuto {
                method.accessFlags |= cg.AccMethodSynthetic
            }
            method.Class = c
            method.Descriptor = Descriptor.methodDescriptor(vv.Function.Type)
            method.IsConstruction = name == specialMethodInit
            if vv.IsAbstract() == false {
                method.Code = new cg.AttributeCode()
                this.buildFunction(c, astClass, method, vv.Function)
            }
            c.AppendMethod(method)
        }
    }


    fn mkGlobalFunctions() {
        ms := new map { string -> cg.MethodHighLevel }()
        for k, f := range this.Package.Block.Functions { // first round
            if f.TemplateFunction != null {
                t := new cg.AttributeTemplateFunction()
                t.name = f.name
                t.Filename = f.pos.Filename
                t.StartLine = char(f.pos.Line)
                t.StartColumn = char(f.pos.Column)
                t.Code = string(f.SourceCode)
                this.mainClass.TemplateFunctions = append(this.mainClass.TemplateFunctions,t)
                continue
            }
            if f.isBuildIn { //
                continue
            }
            c := this.mainClass
            method := new cg.MethodHighLevel()
            method.Class = c
            method.name = f.name
            if f.name == ast.MainFunctionName {
                method.Descriptor = "([Ljava/lang/String;)V"
            } else {
                method.Descriptor = Descriptor.methodDescriptor(f.Type)
            }
            method.accessFlags = 0
            method.accessFlags |= cg.AccMethodStatic
            if f.accessFlags&cg.AccMethodPublic != 0 || f.name == ast.MainFunctionName {
                method.accessFlags |= cg.AccMethodPublic
            }
            if f.comment != "" {
                method.AttributeLucyComment = new cg.AttributeLucyComment()
                method.AttributeLucyComment.comment = f.comment

            }
            if f.Type.VArgs != null {
                method.accessFlags |= cg.AccMethodVarargs
            }
            ms[k] = method
            f.Entrance = method
            method.Code = new cg.AttributeCode()
            this.mainClass.AppendMethod(method)
        }
        for k, f := range this.Package.Block.Functions {
            if f.isBuildIn || f.TemplateFunction != null { //
                continue
            }
            this.buildFunction(ms[k].Class, null, ms[k], f)
        }
    }

    fn DumpClass() {
        //dump main c
        f := io.OpenFile("main.class", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
        if err != null {
            return err
        }
        if err := this.mainClass.ToLow().OutPut(f); err != null {
            f.Close()
            return err
        }
        f.Close()
        for _, c := range this.classes {
            f, err = os.OpenFile(filepath.Base(c.name)+".c", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
            if err != null {
                return err
            }
            if err = c.ToLow().OutPut(f); err != null {
                f.Close()
                return err
            } else {
                f.Close()
            }
        }
    }

    /*
        make_node_objects a default construction
    */
    fn mkClassDefaultConstruction(c cg.ClassHighLevel) {
        method := new cg.MethodHighLevel()
        method.name = specialMethodInit
        method.Descriptor = "()V"
        method.accessFlags |= cg.AccMethodPublic
        method.Code = new cg.AttributeCode()
        method.Code.Codes = new []byte(5)
        method.Code.CodeLength = 5
        method.Code.MaxLocals = 1
        method.Code.Codes[0] = cg.OP_aload_0
        method.Code.Codes[1] = cg.OP_invokespecial
        c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
               ast.TypeSuperClass,
                specialMethodInit,
           "()V"
        ), method.Code.Codes[2:4])
        method.Code.MaxStack = 1
        method.Code.Codes[4] = cg.OP_return
        c.AppendMethod(method)
    }



}



