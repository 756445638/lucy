
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"

class BuildExpressionNew {


    eb BuildExpression
    
    fn BuildExpressionNew(eb BuildExpression){
        this.super()
        this.eb = eb
    }


    fn  buildNew(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        switch e.value.Type {
        case ast.VariableTypeArray:
            return this.buildNewArray(c, code, e, context, state)
        case ast.VariableTypeJavaArray:
            return this.buildNewJavaArray(c, code, e, context, state)
        case ast.VariableTypeMap:
            return this.buildNewMap(c, code, e, context)
        }
        stackLength := len(state.Stacks)
        defer  {
            state.popStack(len(state.Stacks) - stackLength)
        }
        //new object
        n := e.data.(ast.ExpressionNew)
        code.Codes[code.CodeLength] = cg.OP_new
        c.InsertClassConst(n.Type.Class.name, code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.Codes[code.CodeLength+3] = cg.OP_dup
        t := new cg.StackMapVerificationTypeInfo()
        t.Verify = new cg.StackMapUninitializedVariableInfo()
        t.Verify.(cg.StackMapUninitializedVariableInfo).CodeOffset = char(code.CodeLength)
        state.Stacks = append(state.Stacks, t, t)
        code.CodeLength += 4
        maxStack = 2
        maxStack += this.eb.buildCallArgs(c, code, n.Args, n.VArgs, context, state)
        code.Codes[code.CodeLength] = cg.OP_invokespecial
        d := n.Construction.Function.jvmDescriptor
        if d == "" {
            d = Descriptor.methodDescriptor(n.Construction.Function.Type)
        }
        c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
            n.Type.Class.name,
            specialMethodInit,
            d
        ), code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.CodeLength += 3
        return
    }

    fn  buildNewMap(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context) -> (maxStack char) {
        maxStack = 2
        code.Codes[code.CodeLength] = cg.OP_new
        c.InsertClassConst(mapClass, code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.Codes[code.CodeLength+3] = cg.OP_dup
        code.CodeLength += 4
        code.Codes[code.CodeLength] = cg.OP_invokespecial
        c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
            mapClass,
            specialMethodInit,
            "()V"
        ), code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.CodeLength += 3
        return
    }

    fn  buildNewJavaArray(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        dimensions := byte(0)
        {
            // get dimension
            t := e.value
            for t.Type == ast.VariableTypeJavaArray {
                dimensions++
                t = t.array
            }
        }
        n := e.data.(ast.ExpressionNew)
        maxStack = this.eb.build(c, code, n.Args[0], context, state) // must be a integer
        currentStack := char(1)
        for i := byte(0); i < dimensions-1; i++ {
            loadInt32(c, code, 0)
            currentStack++
            if currentStack > maxStack {
                maxStack = currentStack
            }
        }
        code.Codes[code.CodeLength] = cg.OP_multianewarray
        c.InsertClassConst(Descriptor.typeDescriptor(e.value), code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.Codes[code.CodeLength+3] = dimensions
        code.CodeLength += 4
        if e.value.array.Type == ast.VariableTypeEnum {
            state.pushStack(c, e.value)
            defer state.popStack(1)
            if t := 3 + setEnumArray(c, code, state, context, e.value.array.Enum); t > maxStack {
                maxStack = t
            }
        }
        return
    }
    fn  buildNewArray(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        //new
        n := e.data.(ast.ExpressionNew)
        meta := ArrayMetas[e.value.array.Type]
        code.Codes[code.CodeLength] = cg.OP_new
        c.InsertClassConst(meta.className, code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.Codes[code.CodeLength+3] = cg.OP_dup
        code.CodeLength += 4
        maxStack = 2
        {
            t := new cg.StackMapVerificationTypeInfo()
            unInit := new cg.StackMapUninitializedVariableInfo()
            unInit.CodeOffset = char(code.CodeLength - 4)
            t.Verify = unInit
            state.Stacks = append(state.Stacks, t, t) // 2 for dup
            defer state.popStack(2)
        }
        // get amount
        stack := this.eb.build(c, code, n.Args[0], context, state) // must be a integer
        if t := char(2) + stack; t > maxStack {
            maxStack = t
        }
        newArrayBaseOnType(c, code, e.value.array)
        if e.value.array.Type == ast.VariableTypeEnum {
            t := new ast.Type()
            t .Type = ast.VariableTypeJavaArray
            t .array = e.value.array
            state.pushStack(c, t)

            if t := 3 + setEnumArray(c, code, state, context, e.value.array.Enum); t > maxStack {
                maxStack = t
            }
            state.popStack(1)
        }
        code.Codes[code.CodeLength] = cg.OP_invokespecial
        c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
            meta.className,
            specialMethodInit,
            meta.constructorFuncDescriptor
        ), code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.CodeLength += 3
        return
    }






}


