
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"
import "lucy/binary"

class BuildSwitch {


    eb BuildExpression
    bb BuildBlock 
    
    fn BuildSwitch(eb BuildExpression , bb BuildBlock ){
        this.super()
        this.eb = eb
        this.bb = bb
    }

    fn buildSwitchStatement(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        s ast.StatementSwitch,
        context Context,
        state StackMapState) -> (maxStack char) {
        // if equal,leave 0 on stack
        compare := fn(t ast.Type) {
            switch t.Type {
            case ast.VariableTypeByte , ast.VariableTypeShort ,ast.VariableTypeEnum,
                ast.VariableTypeChar , ast.VariableTypeInt :
                code.Codes[code.CodeLength] = cg.OP_isub
                code.CodeLength++
            case ast.VariableTypeLong:
                code.Codes[code.CodeLength] = cg.OP_lcmp
                code.CodeLength++
            case ast.VariableTypeFloat:
                code.Codes[code.CodeLength] = cg.OP_fcmpg
                code.CodeLength++
            case ast.VariableTypeDouble:
                code.Codes[code.CodeLength] = cg.OP_dcmpg
                code.CodeLength++
            case ast.VariableTypeString:
                code.Codes[code.CodeLength] = cg.OP_invokevirtual
                c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                    javaStringClass,
                   "compareTo",
                    "(Ljava/lang/String;)I"
                ), code.Codes[code.CodeLength+1:code.CodeLength+3])
                code.CodeLength += 3
            default:
                context.MakeStackMap(code, state, code.CodeLength+7)
                state.pushStack(c, typeBool)
                context.MakeStackMap(code, state, code.CodeLength+8)
                state.popStack(1)
                code.Codes[code.CodeLength] = cg.OP_if_acmpeq
                binary.BigEndian.putChar(code.Codes[code.CodeLength+1:code.CodeLength+3], char(7))
                code.Codes[code.CodeLength+3] = cg.OP_iconst_1
                code.Codes[code.CodeLength+4] = cg.OP_goto
                binary.BigEndian.putChar(code.Codes[code.CodeLength+5:code.CodeLength+7], char(4))
                code.Codes[code.CodeLength+7] = cg.OP_iconst_0
                code.CodeLength += 8
            }
        }
        for _, v := range s.PrefixExpressions {
            stack := this.eb.build(c, code, v, context, state)
            if stack > maxStack {
                maxStack = stack
            }
        }
        stack := this.eb.build(c, code, s.condition, context, state)
        if stack > maxStack {
            maxStack = stack
        }
        //value is on stack
        var notMatch cg.Exit
        size := jvmSlotSize(s.condition.value)
        currentStack := size
        state.pushStack(c, s.condition.value)
        for _, c := range s.StatementSwitchCases {
            if notMatch != null {
                writeExits([]cg.Exit{notMatch}, code.CodeLength)
                context.MakeStackMap(code, state, code.CodeLength)
            }
            matches := []cg.Exit{}
            for _, ee := range c.matches {
                if ee.value.Type == ast.VariableTypeBool {
                    currentStack = size
                    stack := this.eb.build(__FUNCTION__.c, code, ee, context, state)
                    if t := currentStack + stack; t > maxStack {
                        maxStack = t
                    }
                    matches.append(new cg.Exit(cg.OP_ifne, code)) // comsume result on stack
                } else {
                    currentStack = size
                    // mk stack ready
                    if size == 1 {
                        code.Codes[code.CodeLength] = cg.OP_dup
                    } else {
                        code.Codes[code.CodeLength] = cg.OP_dup2
                    }
                    code.CodeLength++
                    currentStack += size
                    state.pushStack(__FUNCTION__.c, s.condition.value)
                    stack := this.eb.build(__FUNCTION__.c, code, ee, context, state)
                    if t := currentStack + stack; t > maxStack {
                        maxStack = t
                    }
                    state.popStack(1)
                    compare(s.condition.value)
                    matches.append(new cg.Exit(cg.OP_ifeq, code)) // comsume result on stack
                }
            }
            // should be goto next,here is no match
            notMatch = new cg.Exit(cg.OP_goto, code)
            // if match goto here
            writeExits(matches, code.CodeLength)
            //before block,pop off stack
            context.MakeStackMap(code, state, code.CodeLength)
            if size == 1 {
                code.Codes[code.CodeLength] = cg.OP_pop
            } else {
                code.Codes[code.CodeLength] = cg.OP_pop2
            }
            code.CodeLength++
            //block is here
            if c.block != null {
                ss := new StackMapState(state)
                this.bb.buildBlock(__FUNCTION__.c, code, c.block, context, ss)
                state.addTop(ss)
            }
            if c.block == null || c.block.notExecuteToLastStatement == false {
                s.exits.append(
                    new cg.Exit(cg.OP_goto, code)) // matched,goto switch outside
            }
        }
        writeExits([]cg.Exit{notMatch}, code.CodeLength)
        context.MakeStackMap(code, state, code.CodeLength)
        if size == 1 {
            code.Codes[code.CodeLength] = cg.OP_pop
        } else {
            code.Codes[code.CodeLength] = cg.OP_pop2
        }
        code.CodeLength++
        state.popStack(1)
        if s.Default != null {
            ss := new StackMapState(state)
            this.bb.buildBlock(c, code, s.Default, context, ss)
            state.addTop(ss)
        }
        return
    }


}


