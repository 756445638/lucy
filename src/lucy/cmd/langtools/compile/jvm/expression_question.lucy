// all rights reserved , check the LICENSE file

import "lucy/cmd/langtools/compile/ast"
import "lucy/jvm/cg"

class BuildExpressionQuestion {
    eb BuildExpression

    fn BuildExpressionQuestion(eb BuildExpression) {
        this.super()
        this.eb = eb
    }

    fn buildQuestion(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        question := e.data.(ast.ExpressionQuestion)
        maxStack = this.eb.build(c , code , question.selection , context , state)
        falseExit := new cg.Exit(cg.OP_ifeq , code)
        //true part
        stack := this.eb.build(c , code , question.theTrue , context , state)
        if stack > maxStack {
            maxStack = stack
        }
        trueExit := new cg.Exit(cg.OP_goto , code)
        context.MakeStackMap(code , state , code.codeLength)
        writeExits([]cg.Exit{falseExit} , code.codeLength)
        stack = this.eb.build(c , code , question.theFalse , context , state)
        if stack > maxStack {
            maxStack = stack
        }
        state.pushStack(c , e.value)
        context.MakeStackMap(code , state , code.codeLength)
        state.popStack(1)
        writeExits([]cg.Exit{trueExit} , code.codeLength)
        return
    }
}


