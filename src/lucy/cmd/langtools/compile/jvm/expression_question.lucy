import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"


class BuildExpressionQuestion {
    

    eb BuildExpression
    
    fn BuildExpressionQuestion(eb BuildExpression){
        this.super()
        this.eb = eb
    }

    fn buildQuestion(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        question := e.data.(ast.ExpressionQuestion)
        maxStack = this.eb.build(c, code, question.Selection, context, state)
        falseExit := new cg.Exit(cg.OP_ifeq, code)
        //true part
        stack := this.eb.build(c, code, question.True, context, state)
        if stack > maxStack {
            maxStack = stack
        }
        trueExit := new cg.Exit(cg.OP_goto, code)
        context.MakeStackMap(code, state, code.CodeLength)
        writeExits([]cg.Exit{falseExit}, code.CodeLength)
        stack = this.eb.build(c, code, question.False, context, state)
        if stack > maxStack {
            maxStack = stack
        }
        state.pushStack(c, e.value)
        context.MakeStackMap(code, state, code.CodeLength)
        state.popStack(1)
        writeExits([]cg.Exit{trueExit}, code.CodeLength)
        return
    }
}

