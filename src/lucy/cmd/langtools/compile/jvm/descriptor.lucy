package jvm

import (
	"bytes"
	"fmt"
	"gitee.com/yuyang-fine/lucy/src/cmd/compile/ast"
)

type Description struct {
}

func (this *Description) methodDescriptor(functionType *ast.FunctionType) string {
	s := "("
	for _, v := range functionType.ParameterList {
		s += this.typeDescriptor(v.Type)
	}
	if functionType.VArgs != nil {
		s += this.typeDescriptor(functionType.VArgs.Type)
	}
	s += ")"
	if functionType.VoidReturn() {
		s += "V"
	} else if len(functionType.ReturnList) == 1 {
		s += this.typeDescriptor(functionType.ReturnList[0].Type)
	} else {
		s += "[Ljava/lang/Object;" //always this type
	}
	return s
}

func (this *Description) typeDescriptor(typ *ast.Type) string {
	switch typ.Type {
	case ast.VariableTypeBool:
		return "Z"
	case ast.VariableTypeByte:
		return "B"
	case ast.VariableTypeShort:
		return "S"
	case ast.VariableTypeChar:
		return "C"
	case ast.VariableTypeInt, ast.VariableTypeEnum:
		return "I"
	case ast.VariableTypeLong:
		return "J"
	case ast.VariableTypeFloat:
		return "F"
	case ast.VariableTypeDouble:
		return "D"
	case ast.VariableTypeArray:
		meta := ArrayMetas[typ.Array.Type] // combination type
		return "L" + meta.className + ";"
	case ast.VariableTypeString:
		return "Ljava/lang/String;"
	case ast.VariableTypeVoid:
		return "V"
	case ast.VariableTypeObject:
		return "L" + typ.Class.Name + ";"
	case ast.VariableTypeMap:
		return "L" + mapClass + ";"
	case ast.VariableTypeFunction:
		return "L" + javaMethodHandleClass + ";"
	case ast.VariableTypeJavaArray:
		return "[" + this.typeDescriptor(typ.Array)
	}
	panic("unHandle type signature")
}

func (this *Description) ParseType(bs []byte) ([]byte, *ast.Type, error) {
	switch bs[0] {
	case 'V':
		bs = bs[1:]
		return bs, &ast.Type{
			Type: ast.VariableTypeVoid,
		}, nil
	case 'B':
		bs = bs[1:]
		return bs, &ast.Type{
			Type: ast.VariableTypeByte,
		}, nil
	case 'D':
		bs = bs[1:]
		return bs, &ast.Type{
			Type: ast.VariableTypeDouble,
		}, nil
	case 'F':
		bs = bs[1:]
		return bs, &ast.Type{
			Type: ast.VariableTypeFloat,
		}, nil
	case 'I':
		bs = bs[1:]
		return bs, &ast.Type{
			Type: ast.VariableTypeInt,
		}, nil
	case 'J':
		bs = bs[1:]
		return bs, &ast.Type{
			Type: ast.VariableTypeLong,
		}, nil
	case 'C':
		bs = bs[1:]
		return bs, &ast.Type{
			Type: ast.VariableTypeChar,
		}, nil
	case 'S':
		bs = bs[1:]
		return bs, &ast.Type{
			Type: ast.VariableTypeShort,
		}, nil
	case 'Z':
		bs = bs[1:]
		return bs, &ast.Type{
			Type: ast.VariableTypeBool,
		}, nil
	case 'L':
		bs = bs[1:]
		index := bytes.Index(bs, []byte{';'}) // end token
		t := &ast.Type{}
		t.Type = ast.VariableTypeObject
		t.Class = &ast.Class{}
		t.Class.Name = string(bs[:index])
		bs = bs[index+1:] // skip ;
		t.Class.NotImportedYet = true
		if t.Class.Name == javaStringClass {
			t.Type = ast.VariableTypeString
		}
		return bs, t, nil
	case '[':
		bs = bs[1:]
		var t *ast.Type
		var err error
		bs, t, err = this.ParseType(bs)
		ret := &ast.Type{}
		if err == nil {
			ret.Type = ast.VariableTypeJavaArray
			ret.Array = t
		}
		return bs, ret, err
	}
	return bs, nil, new error(sprintf("unkown type:%v", string(bs))
}

func (this *Description) ParseFunctionType(bs []byte) (ast.FunctionType, error) {
	t := ast.FunctionType{}
	if bs[0] != '(' {
		return t, new error(sprintf("function descriptor does not start with '('")
	}
	bs = bs[1:]
	var err error
	for bs[0] != ')' {
		vd := &ast.Variable{}
		bs, vd.Type, err = this.ParseType(bs)
		if err != nil {
			return t, err
		}
		t.ParameterList = append(t.ParameterList, vd)
	}
	bs = bs[1:] // skip )
	vd := &ast.Variable{}
	vd.Name = "returnValue"
	_, vd.Type, err = this.ParseType(bs)
	if err != nil {
		return t, err
	}
	t.ReturnList = append(t.ReturnList, vd)
	return t, nil
}
