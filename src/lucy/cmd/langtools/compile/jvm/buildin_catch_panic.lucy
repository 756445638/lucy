
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"


class BuildinFunctionCatchPanic {
    
    eb BuildExpression
    
    fn BuildinFunctionCatchPanic(eb BuildExpression){
        this.super()
        this.eb = eb
    }
    
    fn mkBuildInPanic(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionFunctionCall)
        meta := call.BuildInFunctionMeta.(ast.BuildInFunctionPanicMeta)
        if meta.ArgThrowable {
            if call.Args[0].Type == ast.ExpressionTypeNew { // not new expression
                maxStack = this.eb.build(c, code, call.Args[0], context, state)
            } else {
                code.Codes[code.CodeLength] = cg.OP_new
                className := call.Args[0].value.Class.name
                c.InsertClassConst(className, code.Codes[code.CodeLength+1:code.CodeLength+3])
                code.Codes[code.CodeLength+3] = cg.OP_dup
                code.CodeLength += 4
                {
                    verificationTypeInfo := new cg.StackMapVerificationTypeInfo()
                    uninitializedVariableInfo := new cg.StackMapUninitializedVariableInfo()
                    uninitializedVariableInfo.codeOffset = char(code.CodeLength - 4)
                    verificationTypeInfo.Verify = uninitializedVariableInfo
                    state.Stacks.append(verificationTypeInfo)
                    state.Stacks.append(verificationTypeInfo)
                }
                stack := this.eb.build(c, code, call.Args[0], context, state)
                state.popStack(2)
                maxStack = char(2) + stack
                code.Codes[code.CodeLength] = cg.OP_invokespecial
                c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(  className,  specialMethodInit ,"(Ljava/lang/Throwable;)V"),
                 code.Codes[code.CodeLength+1:code.CodeLength+3])
                code.CodeLength += 3
            }
        } else {
            code.Codes[code.CodeLength] = cg.OP_new
            c.InsertClassConst(javaExceptionClass, code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.Codes[code.CodeLength+3] = cg.OP_dup
            code.CodeLength += 4
            {
                verificationTypeInfo := new cg.StackMapVerificationTypeInfo()
                uninitializedVariableInfo := new cg.StackMapUninitializedVariableInfo()
                uninitializedVariableInfo.codeOffset = char(code.CodeLength - 4)
                verificationTypeInfo.Verify = uninitializedVariableInfo
                state.Stacks = append(state.Stacks, verificationTypeInfo)
                state.Stacks = append(state.Stacks, verificationTypeInfo)
            }
            stack := this.eb.build(c, code, call.Args[0], context, state)
            state.popStack(2)
            if t := char(2) + stack; t > maxStack {
                maxStack = t
            }
            if t := 2 + this.stackTop2String(c, code, call.Args[0].value, context, state); t > maxStack {
                maxStack = t
            }
            code.Codes[code.CodeLength] = cg.OP_invokespecial
            c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel( javaExceptionClass, specialMethodInit, "(Ljava/lang/String;)V"),
                code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
        }
        code.Codes[code.CodeLength] = cg.OP_athrow
        code.CodeLength++
        context.MakeStackMap(code, state, code.CodeLength)
        return
    }

    fn mkBuildInCatch(c cg.ClassHighLevel, code cg.AttributeCode,
        e ast.Expression, context Context) -> (maxStack char) {
        if e.isStatementExpression { // statement call
            maxStack = 1
            code.Codes[code.CodeLength] = cg.OP_aconst_null
            code.CodeLength++
            copyOPs(code,
                storeLocalVariableOps(ast.VariableTypeObject, context.exceptionVarOffset))
        } else {
            maxStack = 2
            //load to stack
            copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, context.exceptionVarOffset)) // load
            //set 2 null
            code.Codes[code.CodeLength] = cg.OP_aconst_null
            code.CodeLength++
            copyOPs(code, storeLocalVariableOps(ast.VariableTypeObject, context.exceptionVarOffset)) // store
            //check cast
            code.Codes[code.CodeLength] = cg.OP_checkcast
            if context.Defer.exceptionClass != null {
                c.InsertClassConst(context.Defer.exceptionClass.name, code.Codes[code.CodeLength+1:code.CodeLength+3])
            } else {
                c.InsertClassConst(ast.DefaultExceptionClass, code.Codes[code.CodeLength+1:code.CodeLength+3])
            }
            code.CodeLength += 3
        }
        return
    }



}
