

class TypeConverterAndPrimitivePacker {



	static fn unPackPrimitives(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		t ast.Type) {
		switch t.Type {
		case ast.VariableTypeBool:
			c := "java/lang/Boolean"
			code.Codes[code.CodeLength] = cg.OP_checkcast
			ast.TypeInsertClassConst(c, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			code.Codes[code.CodeLength] = cg.OP_invokevirtual
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      c,
				Method:     "booleanValue",
				Descriptor: "()Z",
			}, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeByte:
			c := "java/lang/Byte"
			code.Codes[code.CodeLength] = cg.OP_checkcast
			ast.TypeInsertClassConst(c, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			code.Codes[code.CodeLength] = cg.OP_invokevirtual
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      c,
				Method:     "byteValue",
				Descriptor: "()B",
			}, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeShort:
			c := "java/lang/Short"
			code.Codes[code.CodeLength] = cg.OP_checkcast
			ast.TypeInsertClassConst(c, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			code.Codes[code.CodeLength] = cg.OP_invokevirtual
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      c,
				Method:     "shortValue",
				Descriptor: "()S",
			}, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeChar:
			c := "java/lang/Character"
			code.Codes[code.CodeLength] = cg.OP_checkcast
			ast.TypeInsertClassConst(c, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			code.Codes[code.CodeLength] = cg.OP_invokevirtual
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      c,
				Method:     "shortValue",
				Descriptor: "()C",
			}, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeEnum:
			fallthrough
		case ast.VariableTypeInt:
			code.Codes[code.CodeLength] = cg.OP_checkcast
			ast.TypeInsertClassConst("java/lang/Integer", code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			code.Codes[code.CodeLength] = cg.OP_invokevirtual
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      javaIntegerClass,
				Method:     "intValue",
				Descriptor: "()I",
			}, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeLong:
			code.Codes[code.CodeLength] = cg.OP_checkcast
			ast.TypeInsertClassConst(javaLongClass, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			code.Codes[code.CodeLength] = cg.OP_invokevirtual
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      javaLongClass,
				Method:     "longValue",
				Descriptor: "()J",
			}, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeFloat:
			code.Codes[code.CodeLength] = cg.OP_checkcast
			ast.TypeInsertClassConst(javaFloatClass, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			code.Codes[code.CodeLength] = cg.OP_invokevirtual
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      javaFloatClass,
				Method:     "floatValue",
				Descriptor: "()F",
			}, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeDouble:
			code.Codes[code.CodeLength] = cg.OP_checkcast
			ast.TypeInsertClassConst(javaDoubleClass, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			code.Codes[code.CodeLength] = cg.OP_invokevirtual
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      javaDoubleClass,
				Method:     "doubleValue",
				Descriptor: "()D",
			}, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		}
	}

	static fn packPrimitives(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		t ast.Type) {
		copyOPs(code, c.packPrimitivesBytes(class, t)...)
	}

	static fn packPrimitivesBytes(
		c cg.ClassHighLevel,
		t ast.Type) (bs []byte) {
		bs = make([]byte, 3)
		bs[0] = cg.OP_invokestatic
		switch t.Type {
		case ast.VariableTypeBool:
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      "java/lang/Boolean",
				Method:     "valueOf",
				Descriptor: "(Z)Ljava/lang/Boolean;",
			}, bs[1:3])
		case ast.VariableTypeByte:
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      "java/lang/Byte",
				Method:     "valueOf",
				Descriptor: "(B)Ljava/lang/Byte;",
			}, bs[1:3])
		case ast.VariableTypeShort:
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      "java/lang/Short",
				Method:     "valueOf",
				Descriptor: "(S)Ljava/lang/Short;",
			}, bs[1:3])
		case ast.VariableTypeChar:
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      "java/lang/Character",
				Method:     "valueOf",
				Descriptor: "(C)Ljava/lang/Character;",
			}, bs[1:3])
		case ast.VariableTypeEnum:
			fallthrough
		case ast.VariableTypeInt:
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      javaIntegerClass,
				Method:     "valueOf",
				Descriptor: "(I)Ljava/lang/Integer;",
			}, bs[1:3])
		case ast.VariableTypeLong:
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      javaLongClass,
				Method:     "valueOf",
				Descriptor: "(J)Ljava/lang/Long;",
			}, bs[1:3])
		case ast.VariableTypeFloat:
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      javaFloatClass,
				Method:     "valueOf",
				Descriptor: "(F)Ljava/lang/Float;",
			}, bs[1:3])
		case ast.VariableTypeDouble:
			ast.TypeInsertMethodRefConst(cg.ConstantInfoMethodrefHighLevel{
				Class:      javaDoubleClass,
				Method:     "valueOf",
				Descriptor: "(D)Ljava/lang/Double;",
			}, bs[1:3])
		default:
			panic("not a primitive")
		}
		return
	}

	static fn castPointer(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		t ast.Type) {
		if t.IsPointer() == false {
			panic("not pointer at all , compiler error")
		}
		if t.Type == ast.VariableTypeObject && t.Class.Name == javaRootClass {
			// no need  ,try to cast to root class
			return
		}
		code.Codes[code.CodeLength] = cg.OP_checkcast
		switch t.Type {
		case ast.VariableTypeString:
			ast.TypeInsertClassConst(javaStringClass, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeObject:
			if t.Class.Name != ast.JavaRootClass {
				ast.TypeInsertClassConst(t.Class.Name, code.Codes[code.CodeLength+1:code.CodeLength+3])
				code.CodeLength += 3
			}
		case ast.VariableTypeArray:
			meta := ArrayMetas[t.Array.Type]
			ast.TypeInsertClassConst(meta.className, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeMap:
			ast.TypeInsertClassConst(mapClass, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeJavaArray:
			ast.TypeInsertClassConst(Descriptor.typeDescriptor(t), code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		case ast.VariableTypeFunction:
			ast.TypeInsertClassConst(javaMethodHandleClass, code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		default:
			panic("1")
		}
	}
}

