import "lucy/cmd/langtools/compile/ast"
import "lucy/jvm/cg"
import "lucy/binary"

class AutoVariableForRangeJavaArray {
    protected Elements char
    protected end      char
    protected K , V    char
}


class BuildForRangeJavaArray {
    eb BuildExpression
    bb BuildBlock

    fn BuildForRangeJavaArray(eb BuildExpression , bb BuildBlock) {
        this.super()
        this.eb = eb
        this.bb = bb
    }

    fn build(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        s ast.StatementFor,
        context Context,
        state StackMapState) -> (maxStack char) {
        //build array expression
        maxStack = this.eb.build(c , code , s.rangeAttr.rangeOn , context , state) // array on stack
        code.codes[code.codeLength] = cg.OP_dup
        code.codeLength++
        noNullExit := new cg.Exit(cg.OP_ifnonnull , code)
        code.codes[code.codeLength] = cg.OP_pop
        code.codeLength++
        s.exits.append(new cg.Exit(cg.OP_goto , code))
        writeExits([]cg.Exit{noNullExit} , code.codeLength)
        state.pushStack(c , s.rangeAttr.rangeOn.value)
        context.MakeStackMap(code , state , code.codeLength)
        state.popStack(1)
        forState := new StackMapState(state)
        defer {
            state.addTop(forState)
        }
        attr := s.rangeAttr
        var autoVar = new AutoVariableForRangeJavaArray()
        {
            autoVar.Elements = code.maxLocals
            code.maxLocals++
            forState.appendLocals(c , attr.rangeOn.value)
            // K
            autoVar.K = code.maxLocals
            code.maxLocals++
            forState.appendLocals(c , typeInt)
            //end
            autoVar.end = code.maxLocals
            code.maxLocals++
            forState.appendLocals(c , typeInt)
        }

        //get length
        code.codes[code.codeLength] = cg.OP_dup //dup top
        code.codeLength++
        if 2 > maxStack {
            maxStack = char(2)
        }
        code.codes[code.codeLength] = cg.OP_arraylength
        code.codeLength++
        copyOPs(code , storeLocalVariableOps(ast.VariableTypeInt , autoVar.end))
        copyOPs(code , storeLocalVariableOps(ast.VariableTypeJavaArray , autoVar.Elements))

        code.codes[code.codeLength] = cg.OP_iconst_m1
        code.codeLength++
        copyOPs(code , storeLocalVariableOps(ast.VariableTypeInt , autoVar.K))

        //handle captured vars
        if s.condition.Type == ast.ExpressionTypeVarAssign {
            if attr.identifierValue != null &&
                attr.identifierValue.Variable.beenCapturedAsLeftValue > 0 {
                closure.createClosureVar(c , code , attr.identifierValue.Variable.Type)
                attr.identifierValue.Variable.localValOffset = code.maxLocals
                code.maxLocals++
                copyOPs(code,
                    storeLocalVariableOps(ast.VariableTypeObject , attr.identifierValue.Variable.localValOffset))
                forState.appendLocals(c,
                    forState.newObjectVariableType(closure.getMeta(attr.rangeOn.value.array.Type).className))
            }
            if attr.identifierKey != null &&
                attr.identifierKey.Variable.beenCapturedAsLeftValue > 0 {
                closure.createClosureVar(c , code , attr.identifierKey.Variable.Type)
                attr.identifierKey.Variable.localValOffset = code.maxLocals
                code.maxLocals++
                copyOPs(code,
                    storeLocalVariableOps(ast.VariableTypeObject , attr.identifierKey.Variable.localValOffset))
                forState.appendLocals(c,
                    forState.newObjectVariableType(closure.getMeta(ast.VariableTypeInt).className))
            }
        }
        s.continueCodeOffset = code.codeLength
        context.MakeStackMap(code , forState , code.codeLength)
        blockState := new StackMapState(forState)

        if autoVar.K > 255 {
            code.codes[code.codeLength] = cg.OP_wide
            code.codes[code.codeLength + 1] = cg.OP_iinc
            binary.BigEndian.putChar(code.codes[code.codeLength + 2:] , autoVar.K)
            binary.BigEndian.putChar(code.codes[code.codeLength + 4:] , char(1))
            code.codeLength += 6
        } else {
            code.codes[code.codeLength] = cg.OP_iinc
            code.codes[code.codeLength + 1] = byte(autoVar.K)
            code.codes[code.codeLength + 2] = 1b
            code.codeLength += 3
        }

        // load  k
        copyOPs(code , loadLocalVariableOps(ast.VariableTypeInt , autoVar.K))

        // load end
        copyOPs(code , loadLocalVariableOps(ast.VariableTypeInt , autoVar.end))
        if 2 > maxStack {
            maxStack = 2
        }
        s.exits.append(new cg.Exit(cg.OP_if_icmpge , code))
        //load elements
        if attr.identifierValue != null || attr.expressionValue != null {
            copyOPs(code , loadLocalVariableOps(ast.VariableTypeObject , autoVar.Elements))
            copyOPs(code , loadLocalVariableOps(ast.VariableTypeInt , autoVar.K))
            if 2 > maxStack {
                maxStack = 2
            }
            // load value
            switch attr.rangeOn.value.array.Type {
                case ast.VariableTypeBool , ast.VariableTypeByte:
                    code.codes[code.codeLength] = cg.OP_baload
                case ast.VariableTypeShort:
                    code.codes[code.codeLength] = cg.OP_saload
                case ast.VariableTypeChar:
                    code.codes[code.codeLength] = cg.OP_caload
                case ast.VariableTypeEnum,
                    ast.VariableTypeInt:
                    code.codes[code.codeLength] = cg.OP_iaload
                case ast.VariableTypeLong:
                    code.codes[code.codeLength] = cg.OP_laload
                case ast.VariableTypeFloat:
                    code.codes[code.codeLength] = cg.OP_faload
                case ast.VariableTypeDouble:
                    code.codes[code.codeLength] = cg.OP_daload
                default:
                    code.codes[code.codeLength] = cg.OP_aaload
            }
            code.codeLength++
            // v
            autoVar.V = code.maxLocals
            code.maxLocals += jvmSlotSize(attr.rangeOn.value.array)
            //store to v tmp
            copyOPs(code,
                storeLocalVariableOps(attr.rangeOn.value.array.Type,
                    autoVar.V))

            blockState.appendLocals(c , attr.rangeOn.value.array)
        }
        //current stack is 0
        if s.condition.Type == ast.ExpressionTypeVarAssign {
            if attr.identifierValue != null {
                if attr.identifierValue.Variable.beenCapturedAsLeftValue > 0 {
                    copyOPs(code , loadLocalVariableOps(ast.VariableTypeObject , attr.identifierValue.Variable.localValOffset))
                    copyOPs(code,
                        loadLocalVariableOps(attr.rangeOn.value.array.Type,
                            autoVar.V))
                    this.eb.storeLocalVar(c , code , attr.identifierValue.Variable)
                } else {
                    attr.identifierValue.Variable.localValOffset = autoVar.V
                }
            }
            if attr.identifierKey != null {
                if attr.identifierKey.Variable.beenCapturedAsLeftValue > 0 {
                    copyOPs(code , loadLocalVariableOps(ast.VariableTypeObject,
                            attr.identifierKey.Variable.localValOffset))
                    copyOPs(code,
                        loadLocalVariableOps(ast.VariableTypeInt , autoVar.K))
                    this.eb.storeLocalVar(c , code , attr.identifierKey.Variable)
                } else {
                    attr.identifierKey.Variable.localValOffset = autoVar.K
                }
            }
        } else {
            // store v
            //get ops,make_node_objects ops ready
            if attr.expressionValue != null {
                stackLength := len(blockState.stacks)
                stack , remainStack , ops , _ := this.eb.BuildExpressionLeftValue.getLeftValue(c,
                    code , attr.expressionValue , context , blockState)
                if stack > maxStack {
                    maxStack = stack
                }
                //load v
                copyOPs(code , loadLocalVariableOps(attr.rangeOn.value.array.Type,
                        autoVar.V))
                if t := remainStack + jvmSlotSize(attr.rangeOn.value.array) ; t > maxStack {
                    maxStack = t
                }
                copyOPs(code , ops)
                blockState.popStack(len(blockState.stacks) - stackLength)
            }
            if attr.expressionKey != null {
                stackLength := len(blockState.stacks)
                stack , remainStack , ops , _ := this.eb.BuildExpressionLeftValue.getLeftValue(c,
                    code , attr.expressionKey , context , blockState)
                if stack > maxStack {
                    maxStack = stack
                }
                if t := remainStack + 1 ; t > maxStack {
                    maxStack = t
                }
                // load k
                copyOPs(code , loadLocalVariableOps(ast.VariableTypeInt , autoVar.K))
                copyOPs(code , ops)
                blockState.popStack(len(blockState.stacks) - stackLength)
            }
        }

        // build block
        this.bb.buildBlock(c , code , s.block , context , blockState)
        forState.addTop(blockState)
        if s.block.notExecuteToLastStatement == false {
            jumpTo(code , s.continueCodeOffset)
        }
        return
    }

}


