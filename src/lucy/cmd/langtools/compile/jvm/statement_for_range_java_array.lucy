
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"

class AutoVariableForRangeJavaArray {
	protected Elements char
	protected End      char
	protected K, V     char
}

class BuildForRangeJavaArray {

    eb BuildExpression
    bb  BuildBlock

    fn BuildForRangeJavaArray(eb BuildExpression , bb  BuildBlock){
        this.super()
        this.eb = eb
        this.bb = bb
    }

    fn build(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        s ast.StatementFor,
        context Context,
        state StackMapState) -> (maxStack char) {
        //build array expression
        maxStack = this.BuildExpression.build(c, code, s.RangeAttr.RangeOn, context, state) // array on stack
        code.Codes[code.CodeLength] = cg.OP_dup
        code.CodeLength++
        noNullExit := new cg.Exit(cg.OP_ifnonnull, code)
        code.Codes[code.CodeLength] = cg.OP_pop
        code.CodeLength++
        s.Exits = append(s.Exits, new cg.Exit(cg.OP_goto, code))
        writeExits([]cg.Exit{noNullExit}, code.CodeLength)
        state.pushStack(c, s.RangeAttr.RangeOn.value)
        context.MakeStackMap(code, state, code.CodeLength)
        state.popStack(1)
        forState := new StackMapState(state)
        defer state.addTop(forState) // add top
        attr := s.RangeAttr
        var autoVar AutoVariableForRangeJavaArray
        {
            autoVar.Elements = code.MaxLocals
            code.MaxLocals++
            forState.appendLocals(c, attr.RangeOn.value)
            // K
            autoVar.K = code.MaxLocals
            code.MaxLocals++
            forState.appendLocals(c, typeInt)
            //end
            autoVar.End = code.MaxLocals
            code.MaxLocals++
            forState.appendLocals(c, typeInt)

        }

        //get length
        code.Codes[code.CodeLength] = cg.OP_dup //dup top
        code.CodeLength++
        if 2 > maxStack {
            maxStack = 2
        }
        code.Codes[code.CodeLength] = cg.OP_arraylength
        code.CodeLength++
        copyOPs(code, storeLocalVariableOps(ast.VariableTypeInt, autoVar.End))
        copyOPs(code, storeLocalVariableOps(ast.VariableTypeJavaArray, autoVar.Elements))

        code.Codes[code.CodeLength] = cg.OP_iconst_m1
        code.CodeLength++
        copyOPs(code, storeLocalVariableOps(ast.VariableTypeInt, autoVar.K))

        //handle captured vars
        if s.Condition.Type == ast.ExpressionTypeVarAssign {
            if attr.IdentifierValue != null &&
                attr.IdentifierValue.Variable.beenCapturedAsLeftValue > 0 {
                closure.createClosureVar(c, code, attr.IdentifierValue.Variable.Type)
                attr.IdentifierValue.Variable.localValOffset = code.MaxLocals
                code.MaxLocals++
                copyOPs(code,
                    storeLocalVariableOps(ast.VariableTypeObject, attr.IdentifierValue.Variable.localValOffset))
                forState.appendLocals(c,
                    forState.newObjectVariableType(closure.getMeta(attr.RangeOn.value.array.Type).className))
            }
            if attr.IdentifierKey != null &&
                attr.IdentifierKey.Variable.beenCapturedAsLeftValue > 0 {
                closure.createClosureVar(c, code, attr.IdentifierKey.Variable.Type)
                attr.IdentifierKey.Variable.localValOffset = code.MaxLocals
                code.MaxLocals++
                copyOPs(code,
                    storeLocalVariableOps(ast.VariableTypeObject, attr.IdentifierKey.Variable.localValOffset))
                forState.appendLocals(c,
                    forState.newObjectVariableType(closure.getMeta(ast.VariableTypeInt).className))
            }
        }
        s.ContinueCodeOffset = code.CodeLength
        context.MakeStackMap(code, forState, code.CodeLength)
        blockState := new StackMapState(forState)

        code.Codes[code.CodeLength] = cg.OP_iinc
        if autoVar.K > 255 {
            panic("over 255")
        }
        code.Codes[code.CodeLength+1] = byte(autoVar.K)
        code.Codes[code.CodeLength+2] = 1
        code.CodeLength += 3

        // load  k
        copyOPs(code, loadLocalVariableOps(ast.VariableTypeInt, autoVar.K))

        // load end
        copyOPs(code, loadLocalVariableOps(ast.VariableTypeInt, autoVar.End))
        if 2 > maxStack {
            maxStack = 2
        }
        s.Exits = append(s.Exits, new cg.Exit(cg.OP_if_icmpge, code))
        //load elements
        if attr.IdentifierValue != null || attr.ExpressionValue != null {
            copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, autoVar.Elements))
            copyOPs(code, loadLocalVariableOps(ast.VariableTypeInt, autoVar.K))
            if 2 > maxStack {
                maxStack = 2
            }
            // load value
            switch attr.RangeOn.value.array.Type {
            case ast.VariableTypeBool:
                fallthrough
            case ast.VariableTypeByte:
                code.Codes[code.CodeLength] = cg.OP_baload
            case ast.VariableTypeShort:
                code.Codes[code.CodeLength] = cg.OP_saload
            case ast.VariableTypeChar:
                code.Codes[code.CodeLength] = cg.OP_caload
            case ast.VariableTypeEnum:
                fallthrough
            case ast.VariableTypeInt:
                code.Codes[code.CodeLength] = cg.OP_iaload
            case ast.VariableTypeLong:
                code.Codes[code.CodeLength] = cg.OP_laload
            case ast.VariableTypeFloat:
                code.Codes[code.CodeLength] = cg.OP_faload
            case ast.VariableTypeDouble:
                code.Codes[code.CodeLength] = cg.OP_daload
            default:
                code.Codes[code.CodeLength] = cg.OP_aaload
            }
            code.CodeLength++
            // v
            autoVar.V = code.MaxLocals
            code.MaxLocals += jvmSlotSize(attr.RangeOn.value.array)
            //store to v tmp
            copyOPs(code,
                storeLocalVariableOps(attr.RangeOn.value.array.Type,
                    autoVar.V)...)

            blockState.appendLocals(c, attr.RangeOn.value.array)
        }
        //current stack is 0
        if s.Condition.Type == ast.ExpressionTypeVarAssign {
            if attr.IdentifierValue != null {
                if attr.IdentifierValue.Variable.beenCapturedAsLeftValue > 0 {
                    copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, attr.IdentifierValue.Variable.localValOffset))
                    copyOPs(code,
                        loadLocalVariableOps(attr.RangeOn.value.array.Type,
                            autoVar.V)...)
                    this.storeLocalVar(c, code, attr.IdentifierValue.Variable)
                } else {
                    attr.IdentifierValue.Variable.localValOffset = autoVar.V
                }
            }
            if attr.IdentifierKey != null {
                if attr.IdentifierKey.Variable.beenCapturedAsLeftValue > 0 {
                    copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject,
                        attr.IdentifierKey.Variable.localValOffset)...)
                    copyOPs(code,
                        loadLocalVariableOps(ast.VariableTypeInt, autoVar.K)...)
                    this.storeLocalVar(c, code, attr.IdentifierKey.Variable)
                } else {
                    attr.IdentifierKey.Variable.localValOffset = autoVar.K
                }
            }
        } else { // for k,v = range arr
            // store v
            //get ops,make_node_objects ops ready
            if attr.ExpressionValue != null {
                stackLength := len(blockState.Stacks)
                stack, remainStack, ops, _ := this.BuildExpression.getLeftValue(c,
                    code, attr.ExpressionValue, context, blockState)
                if stack > maxStack {
                    maxStack = stack
                }
                //load v
                copyOPs(code, loadLocalVariableOps(attr.RangeOn.value.array.Type,
                    autoVar.V)...)
                if t := remainStack + jvmSlotSize(attr.RangeOn.value.array); t > maxStack {
                    maxStack = t
                }
                copyOPs(code, ops...)
                blockState.popStack(len(blockState.Stacks) - stackLength)
            }
            if attr.ExpressionKey != null { // set to k
                stackLength := len(blockState.Stacks)
                stack, remainStack, ops, _ := this.BuildExpression.getLeftValue(c,
                    code, attr.ExpressionKey, context, blockState)
                if stack > maxStack {
                    maxStack = stack
                }
                if t := remainStack + 1; t > maxStack {
                    maxStack = t
                }
                // load k
                copyOPs(code, loadLocalVariableOps(ast.VariableTypeInt, autoVar.K)...)
                copyOPs(code, ops...)
                blockState.popStack(len(blockState.Stacks) - stackLength)
            }
        }

        // build block
        this.buildBlock(c, code, s.block, context, blockState)
        forState.addTop(blockState)
        if s.block.notExecuteToLastStatement == false {
            jumpTo(code, s.ContinueCodeOffset)
        }

        return
    }


}


