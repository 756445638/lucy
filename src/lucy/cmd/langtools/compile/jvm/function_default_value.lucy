
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"
import "lucy/binary"

class DefaultValueParse {

	static fn Encode(
		c cg.ClassHighLevel,
		f ast.Function) -> (d cg.AttributeDefaultParameters) {
		ret := new cg.AttributeDefaultParameters()
		ret.start = char(f.DefaultValueStartAt)
		ret.constants = []int{}
		for i := ret.start; i < char(len(f.Type.ParameterList)); i++ {
			switch f.Type.ParameterList[i].defaultValueExpression.Type {
			case ast.ExpressionTypeBool:
				if f.Type.ParameterList[i].defaultValueExpression.data.(bool) {
					ret.constants.append( c.InsertIntConst(1))
				} else {
					ret.constants.append( c.InsertIntConst(0))
				}
			case ast.ExpressionTypeByte:
				fallthrough
			case ast.ExpressionTypeShort:
				fallthrough
			case ast.ExpressionTypeInt:
				t := f.Type.ParameterList[i].defaultValueExpression.data.(long)
				ret.constants.append( c.InsertIntConst(int(t)))
			case ast.ExpressionTypeLong:
				ret.constants.append( ast.TypeClass.InsertLongConst(
					f.Type.ParameterList[i].defaultValueExpression.data.(long)))
			case ast.ExpressionTypeFloat:
				ret.constants.append( ast.TypeClass.InsertFloatConst(
					f.Type.ParameterList[i].defaultValueExpression.data.(float)))
			case ast.ExpressionTypeDouble:
				ret.constants.append( ast.TypeClass.InsertDoubleConst(
					f.Type.ParameterList[i].defaultValueExpression.data.(double)))
			case ast.ExpressionTypeString:
				ret.constants.append( ast.TypeClass.InsertStringConst(
					f.Type.ParameterList[i].defaultValueExpression.data.(string)))
			}
		}
		return ret
	}

	static fn Decode(c cg.Class, f ast.Function, dp cg.AttributeDefaultParameters) {
		f.HaveDefaultValue = true
		f.DefaultValueStartAt = int(dp.start)
		for i := char(0); i < char(len(dp.constants)); i++ {
			v := f.Type.ParameterList[dp.start+i]
			v.defaultValueExpression = new ast.Expression()
			v.defaultValueExpression.value = v.Type
			switch v.Type.Type {
			case ast.VariableTypeBool:
				v.defaultValueExpression.Type = ast.ExpressionTypeBool
				v.defaultValueExpression.boolValue =
					binary.BigEndian.getInt(ast.TypeConstPool[dp.constants[i]].Info) != 0
			case ast.VariableTypeByte:
				v.defaultValueExpression.Type = ast.ExpressionTypeByte
				v.defaultValueExpression.data =
					long(binary.BigEndian.getInt(ast.TypeConstPool[dp.constants[i]].Info))
			case ast.VariableTypeShort:
				v.defaultValueExpression.Type = ast.ExpressionTypeShort
				v.defaultValueExpression.data =
					long(binary.BigEndian.getInt(ast.TypeConstPool[dp.constants[i]].Info))
			case ast.VariableTypeChar:
				v.defaultValueExpression.Type = ast.ExpressionTypeChar
				v.defaultValueExpression.data =
					long(binary.BigEndian.getInt(ast.TypeConstPool[dp.constants[i]].Info))
			case ast.VariableTypeInt:
				v.defaultValueExpression.Type = ast.ExpressionTypeInt
				v.defaultValueExpression.data =
					long(binary.BigEndian.getInt(ast.TypeConstPool[dp.constants[i]].Info))
			case ast.VariableTypeLong:
				v.defaultValueExpression.Type = ast.ExpressionTypeLong
				v.defaultValueExpression.data =
					long(binary.BigEndian.Uint64(ast.TypeConstPool[dp.constants[i]].Info))
			case ast.VariableTypeFloat:
				v.defaultValueExpression.Type = ast.ExpressionTypeFloat
				v.defaultValueExpression.data =
					float(binary.BigEndian.getInt(ast.TypeConstPool[dp.constants[i]].Info))
			case ast.VariableTypeDouble:
				v.defaultValueExpression.Type = ast.ExpressionTypeDouble
				v.defaultValueExpression.data =
					double(binary.BigEndian.getInt(ast.TypeConstPool[dp.constants[i]].Info))
			case ast.VariableTypeString:
				v.defaultValueExpression.Type = ast.ExpressionTypeString
				utf8Index := binary.BigEndian.Uint16(ast.TypeConstPool[dp.constants[i]].Info)
				v.defaultValueExpression.data =
					string(ast.TypeConstPool[utf8Index].Info)
			}
			v.defaultValueExpression.op = sprintf("%v", v.defaultValueExpression.data)
		}
	}


}
