
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"
import "lucy/binary"

class DefaultValueParse {

	static fn Encode(
		c cg.ClassHighLevel,
		f ast.Function) -> (d cg.AttributeDefaultParameters) {
		ret := new cg.AttributeDefaultParameters()
		ret.start = char(f.DefaultValueStartAt)
		ret.constants = []char{}
		for i := ret.start; i < char(len(f.Type.ParameterList)); i++ {
			switch f.Type.ParameterList[i].defaultValueExpression.Type {
			case ast.ExpressionTypeBool:
				if f.Type.ParameterList[i].defaultValueExpression.boolValue {
					ret.constants.append( c.Class.insertIntConst(1))
				} else {
					ret.constants.append( c.Class.insertIntConst(0))
				}
			case ast.ExpressionTypeByte ,ast.ExpressionTypeShort,ast.ExpressionTypeChar, ast.ExpressionTypeInt:
				t := f.Type.ParameterList[i].defaultValueExpression.longValue
				ret.constants.append( c.Class.insertIntConst(int(t)))
			case ast.ExpressionTypeLong:
				ret.constants.append( c.Class.insertLongConst(
					f.Type.ParameterList[i].defaultValueExpression.longValue))
			case ast.ExpressionTypeFloat:
				ret.constants.append( c.Class.insertFloatConst(
					float(f.Type.ParameterList[i].defaultValueExpression.doubleValue)))
			case ast.ExpressionTypeDouble:
				ret.constants.append( c.Class.insertDoubleConst(
					f.Type.ParameterList[i].defaultValueExpression.doubleValue))
			case ast.ExpressionTypeString:
				ret.constants.append( c.Class.insertStringConst(
					f.Type.ParameterList[i].defaultValueExpression.stringValue))
			}
		}
		return ret
	}

	static fn Decode(c cg.Class, f ast.Function, dp cg.AttributeDefaultParameters) {
		f.HaveDefaultValue = true
		f.DefaultValueStartAt = int(dp.start)
		for i := char(0); i < char(len(dp.constants)); i++ {
			v := f.Type.ParameterList[dp.start+i]
			v.defaultValueExpression = new ast.Expression()
			v.defaultValueExpression.value = v.Type
			switch v.Type.Type {
			case ast.VariableTypeBool:
				v.defaultValueExpression.Type = ast.ExpressionTypeBool
				v.defaultValueExpression.boolValue =
					binary.BigEndian.getInt(c.ConstPool[dp.constants[i]].Info) != 0
			case ast.VariableTypeByte:
				v.defaultValueExpression.Type = ast.ExpressionTypeByte
				v.defaultValueExpression.longValue =
					long(binary.BigEndian.getInt(c.ConstPool[dp.constants[i]].Info))
			case ast.VariableTypeShort:
				v.defaultValueExpression.Type = ast.ExpressionTypeShort
				v.defaultValueExpression.longValue =
					long(binary.BigEndian.getInt(c.ConstPool[dp.constants[i]].Info))
			case ast.VariableTypeChar:
				v.defaultValueExpression.Type = ast.ExpressionTypeChar
				v.defaultValueExpression.longValue =
					long(binary.BigEndian.getInt(c.ConstPool[dp.constants[i]].Info))
			case ast.VariableTypeInt:
				v.defaultValueExpression.Type = ast.ExpressionTypeInt
				v.defaultValueExpression.longValue =
					long(binary.BigEndian.getInt(c.ConstPool[dp.constants[i]].Info))
			case ast.VariableTypeLong:
				v.defaultValueExpression.Type = ast.ExpressionTypeLong
				v.defaultValueExpression.longValue =
					long(binary.BigEndian.getLong(c.ConstPool[dp.constants[i]].Info))
			case ast.VariableTypeFloat:
				v.defaultValueExpression.Type = ast.ExpressionTypeFloat
				v.defaultValueExpression.doubleValue =
					double(binary.BigEndian.getInt(c.ConstPool[dp.constants[i]].Info))
			case ast.VariableTypeDouble:
				v.defaultValueExpression.Type = ast.ExpressionTypeDouble
				v.defaultValueExpression.doubleValue =
					double(binary.BigEndian.getInt(c.ConstPool[dp.constants[i]].Info))
			case ast.VariableTypeString:
				v.defaultValueExpression.Type = ast.ExpressionTypeString
				utf8Index := binary.BigEndian.getChar(c.ConstPool[dp.constants[i]].Info)
				v.defaultValueExpression.stringValue =
					string(c.ConstPool[utf8Index].Info)
			}
			v.defaultValueExpression.op = sprintf("%v", v.defaultValueExpression.data)
		}
	}


}
