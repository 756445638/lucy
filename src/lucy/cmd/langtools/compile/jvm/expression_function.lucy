import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"




class  BuildExpressionFunction {
	

	eb BuildExpression
	bp BuildPackage
	
    fn BuildExpressionFunction(eb BuildExpression,bp BuildPackage ){
        this.super()
        this.eb = eb
        this.bp = bp
    }

	fn  buildFunctionExpression(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		e ast.Expression,
		context Context,
		state StackMapState) -> (maxStack char) {
		function := e.data.(ast.Function)
		defer {
			if e.isStatementExpression == false  {
				stack := this.packFunction2MethodHandle(c, code, function, context)
                if stack > maxStack {
                    maxStack = stack
                }
			}
		}
		if function.name == "" {
			function.name = function.nameLiteralFunction()
		}
		if function.IsClosureFunction == false {
			function.name = c.newMethodName(function.name) // new a function name
			method := new cg.MethodHighLevel()
			method.name = function.name
			method.accessFlags |= cg.AccMethodFinal
			method.accessFlags |= cg.AccMethodPrivate
			method.accessFlags |= cg.AccMethodStatic
			method.accessFlags |= cg.AccMethodBridge
			if function.Type.VArgs != null {
				method.accessFlags |= cg.AccMethodVarargs
			}
			function.Entrance = method
			method.Class = c
			method.Descriptor = Descriptor.methodDescriptor(function.Type)
			method.code = new cg.AttributeCode()
			this.buildFunction(c, null, method, function)
			c.appendMethod(method)
			return
		}

		// function have captured vars
		className := this.bp.newClassName("closureFunction$" + function.name)
		closureClass := new cg.ClassHighLevel()
		closureClass.name = className
		closureClass.superClass = ast.LucyRootClass
		closureClass.accessFlags = 0
		closureClass.accessFlags |= cg.AccClassSynthetic
		closureClass.accessFlags |= cg.AccClassFinal
		this.bp.mkClassDefaultConstruction(closureClass)
		this.bp.putClass(closureClass)
		method := new cg.MethodHighLevel()
		method.name = function.name
		method.accessFlags |= cg.AccMethodFinal
		method.accessFlags |= cg.AccMethodBridge
		if function.Type.VArgs != null {
			method.accessFlags |= cg.AccMethodVarargs
		}
		method.Descriptor = Descriptor.methodDescriptor(function.Type)
		method.Class = closureClass
		function.Entrance = method
		closureClass.appendMethod(method)
		//new a object to hold this closure function
		code.Codes[code.CodeLength] = cg.OP_new
		c.insertClassConst(closureClass.name, code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.Codes[code.CodeLength+3] = cg.OP_dup
		code.CodeLength += 4
		maxStack = 2 // maxStack is 2 right now
		code.Codes[code.CodeLength] = cg.OP_invokespecial
		c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
			className,
			specialMethodInit,
			"()V"
		), code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.CodeLength += 3
		code.Codes[code.CodeLength] = cg.OP_dup
		code.CodeLength++
		// store  to,wait for call
		function.ClosureVariableOffSet = code.maxLocals
		code.maxLocals++
		state.appendLocals(c, state.newObjectVariableType(className))
		copyOPs(code, storeLocalVariableOps(ast.VariableTypeObject, function.ClosureVariableOffSet))
		//set filed
		closureClass.fields = new map { string -> cg.FieldHighLevel} ()
		total := len(function.Closure.Variables) + len(function.Closure.Functions) - 1
		for v, _ := range function.Closure.Variables {
			field := new cg.FieldHighLevel()
			field.accessFlags |= cg.AccFieldSynthetic
			field.name = v.name
			closureClass.fields[v.name] = field
			if total != 0 {
				code.Codes[code.CodeLength] = cg.OP_dup
				code.CodeLength++
			}
			if v.beenCapturedAsLeftValue > 0 {
				meta := closure.getMeta(v.Type.Type)
				field.descriptor = "L" + meta.className + ";"
				if context.function.Closure.closureVariableExist(v) {
					// I Know c object at offset 0
					copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, char(0)))
					if 3 > maxStack {
						maxStack = 3
					}
					code.Codes[code.CodeLength] = cg.OP_getfield
					c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
					    c.name,
						v.name,
						field.descriptor
					), code.Codes[code.CodeLength+1:code.CodeLength+3])
					code.CodeLength += 3
				} else { // not exits
					copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, v.localValOffset))
					if 3 > maxStack {
						maxStack = 3
					}
				}
			} else {
				field.descriptor = Descriptor.typeDescriptor(v.Type)
				if context.function.Closure.closureVariableExist(v) {
					// I Know c object at offset 0
					copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, char(0)))
					if 3 > maxStack {
						maxStack = 3
					}
					code.Codes[code.CodeLength] = cg.OP_getfield
					c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
						c.name,
						v.name,
						field.descriptor
					), code.Codes[code.CodeLength+1:code.CodeLength+3])
					code.CodeLength += 3
				} else { // not exits
					copyOPs(code, loadLocalVariableOps(v.Type.Type, v.localValOffset))
					if 3 > maxStack {
						maxStack = 3
					}
				}
			}
			code.Codes[code.CodeLength] = cg.OP_putfield
			c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
				className,
				v.name,
				field.descriptor
			), code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			total--
		}
		for v, _ := range function.Closure.Functions {
			if v.IsClosureFunction == false {
				continue
			}
			filed := new cg.FieldHighLevel()
			filed.accessFlags |= cg.AccFieldPublic
			filed.accessFlags |= cg.AccFieldSynthetic
			filed.name = v.name
			filed.Descriptor = "L" + v.Entrance.Class.name + ";"
			closureClass.fields[v.name] = filed
			if total != 0 {
				code.Codes[code.CodeLength] = cg.OP_dup
				code.CodeLength++
			}
			if context.function.Closure.closureFunctionExist(v) {
				// I Know this at 0 offset
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, 0))
				if 3 > maxStack {
					maxStack = 3
				}
				code.Codes[code.CodeLength] = cg.OP_getfield
				c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
					ast.TypeName,
					v.name,
					filed.Descriptor
				), code.Codes[code.CodeLength+1:code.CodeLength+3])
				code.CodeLength += 3
			} else { // not exits
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, v.ClosureVariableOffSet))
				if 3 > maxStack {
					maxStack = 3
				}
			}
			code.Codes[code.CodeLength] = cg.OP_putfield
			c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
				className,
				v.name,
				filed.Descriptor
			), code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			total--
		}
		method.code = new cg.AttributeCode()
		// build function
		this.buildFunction(closureClass, null, method, function)
		return

	}
	fn  packFunction2MethodHandle(c cg.ClassHighLevel, code cg.AttributeCode,
		function ast.Function, context Context) -> (maxStack char) {
		code.Codes[code.CodeLength] = cg.OP_invokestatic
		c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
			"java/lang/invoke/MethodHandles",
			"lookup",
			"()Ljava/lang/invoke/MethodHandles$Lookup;"
		), code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.CodeLength += 3
		code.Codes[code.CodeLength] = cg.OP_ldc_w
		c.insertClassConst(function.Entrance.Class.name, code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.CodeLength += 3
		code.Codes[code.CodeLength] = cg.OP_ldc_w
		c.insertStringConst(function.Entrance.name, code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.CodeLength += 3
		code.Codes[code.CodeLength] = cg.OP_ldc_w
		c.insertMethodTypeConst(new cg.ConstantInfoMethodTypeHighLevel(
			function.Entrance.Descriptor),code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.CodeLength += 3
		code.Codes[code.CodeLength] = cg.OP_invokevirtual
		if function.IsClosureFunction {
			c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
				"java/lang/invoke/MethodHandles$Lookup",
				"findVirtual",
				 "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;"
			), code.Codes[code.CodeLength+1:code.CodeLength+3])
		} else {
			c.insertMethodRefConst(new       cg.ConstantInfoMethodrefHighLevel(
				"java/lang/invoke/MethodHandles$Lookup",
				"findStatic",
				"(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;"
			), code.Codes[code.CodeLength+1:code.CodeLength+3])
		}
		code.CodeLength += 3
		if 4 > maxStack {
			maxStack = 4
		}
		if function.IsClosureFunction {
			if context.function.Closure.closureFunctionExist(function) {
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, char(0)))
				code.Codes[code.CodeLength] = cg.OP_getfield
				c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
					c.name,
					function.name,
					"L" + function.Entrance.Class.name + ";"
				), code.Codes[code.CodeLength+1:code.CodeLength+3])
				code.CodeLength += 3
			} else {
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, function.ClosureVariableOffSet))
			}
			code.Codes[code.CodeLength] = cg.OP_invokevirtual
			c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
				"java/lang/invoke/MethodHandle",
				"bindTo",
				"(Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;"
			), code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
		}
		return
	}
	
}



