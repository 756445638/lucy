
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"

class BuildFunction {

    fn  mkParametersOffset(c cg.ClassHighLevel, code cg.AttributeCode,
        f ast.Function, state StackMapState) {
        for _, v := range f.Type.ParameterList { // insert into locals
            v.localValOffset = code.MaxLocals
            code.MaxLocals += jvmSlotSize(v.Type)
            state.appendLocals(c, v.Type)
        }
        if f.Type.VArgs != null {
            f.Type.VArgs.localValOffset = code.MaxLocals
            code.MaxLocals++
            state.appendLocals(c, f.Type.VArgs.Type)
        }
    }

    fn  mkCapturedParameters(c cg.ClassHighLevel, code cg.AttributeCode,
        f ast.Function, state StackMapState) -> (maxStack char) {
        for _, v := range f.Type.ParameterList {
            if v.beenCapturedAsLeftValue == 0 { // not capture
                continue
            }
            stack := closure.createClosureVar(c, code, v.Type)
            if stack > maxStack {
                maxStack = stack
            }
            code.Codes[code.CodeLength] = cg.OP_dup
            code.CodeLength++
            if t := 2 + jvmSlotSize(v.Type); t > maxStack {
                maxStack = t
            }
            copyOPs(code, loadLocalVariableOps(v.Type.Type, v.localValOffset)...)
            this.storeLocalVar(c, code, v)
            v.localValOffset = code.MaxLocals //rewrite offset
            code.MaxLocals++
            copyOPs(code, storeLocalVariableOps(v.Type.Type, v.localValOffset)...)
            state.appendLocals(c, state.newObjectVariableType(closure.getMeta(v.Type.Type).className))
        }
        return
    }

    fn  buildFunctionParameterAndReturnList(c cg.ClassHighLevel, code cg.AttributeCode,
        f ast.Function, context Context, state StackMapState) -> (maxStack char) {
        this.mkParametersOffset(c, code, f, state)
        maxStack = this.mkCapturedParameters(c, code, f, state)
        if f.Type.VoidReturn() == false {
            for _, v := range f.Type.ReturnList {
                currentStack := char(0)
                if v.beenCapturedAsLeftValue > 0 { //create closure object
                    v.localValOffset = code.MaxLocals
                    code.MaxLocals++
                    stack := closure.createClosureVar(c, code, v.Type)
                    if stack > maxStack {
                        maxStack = stack
                    }
                    // then load
                    code.Codes[code.CodeLength] = cg.OP_dup
                    code.CodeLength++
                    if 2 > maxStack {
                        maxStack = 2
                    }
                    copyOPs(code, storeLocalVariableOps(ast.VariableTypeObject, v.localValOffset))
                    currentStack = 1
                    state.pushStack(c,
                        state.newObjectVariableType(closure.getMeta(v.Type.Type).className))
                } else {
                    v.localValOffset = code.MaxLocals
                    code.MaxLocals += jvmSlotSize(v.Type)
                }
                stack := this.BuildExpression.build(c, code, v.defaultValueExpression, context, state)
                if t := currentStack + stack; t > maxStack {
                    maxStack = t
                }
                this.storeLocalVar(c, code, v)
                if v.beenCapturedAsLeftValue > 0 {
                    state.popStack(1)
                    state.appendLocals(c, state.newObjectVariableType(closure.getMeta(v.Type.Type).className))
                } else {
                    state.appendLocals(c, v.Type)
                }
            }
        }
        return
    }

    fn  buildFunction(c cg.ClassHighLevel, astClass ast.Class, method cg.MethodHighLevel,
        f ast.Function) {
        context := new Context()
        context.lastStackMapOffset = -1
        context.c = astClass
        context.function = f
        method.code.Codes = new []byte (65536)
        method.code.CodeLength = 0
        defer{
            method.code.Codes = method.code.Codes[0:method.code.CodeLength]
        }
        state := new StackMapState()
        if method.accessFlags&cg.AccMethodStatic == 0 {
            if method.isConstruction { // construction method
                method.code.MaxLocals = 1
                t := new cg.StackMapVerificationTypeInfo()
                t.Verify = new cg.StackMapUninitializedThisVariableInfo()
                state.Locals = append(state.Locals, t)
                this.mkParametersOffset(c, method.code, f, state)
                stack := this.BuildExpression.build(c, method.code, f.CallFatherConstructionExpression,
                    context, state)
                if stack > method.code.MaxStack {
                    method.code.MaxStack = stack
                }
                state.Locals[0] = state.newStackMapVerificationTypeInfo(c, state.newObjectVariableType(ast.TypeName))
                this.mkFieldDefaultValue(c, method.code, astClass, context, state)
                this.mkCapturedParameters(c, method.code, f, state)
            } else {
                method.code.MaxLocals = 1
                state.appendLocals(c, state.newObjectVariableType(ast.TypeName))
            }
        }
        if f.IsGlobalMain() { // main function
            code := method.code
            code.Codes[code.CodeLength] = cg.OP_new
            meta := ArrayMetas[ast.VariableTypeString]
            c.InsertClassConst(meta.className, code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.Codes[code.CodeLength+3] = cg.OP_dup
            code.CodeLength += 4
            copyOPs(code, loadLocalVariableOps(ast.VariableTypeString, 0)...)
            if 3 > code.MaxStack {
                code.MaxStack = 3
            }
            code.Codes[code.CodeLength] = cg.OP_invokespecial
            c.InsertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                meta.className,
                specialMethodInit,
                meta.constructorFuncDescriptor
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
            copyOPs(code, storeLocalVariableOps(ast.VariableTypeObject, 1)...)
            {
                // String[] java style
                t := new ast.Type()
                t.Type = ast.VariableTypeJavaArray
                t.array = new ast.Type()
                t.array.Type = ast.VariableTypeString
                state.appendLocals(c, t)
            }
            method.code.MaxLocals = 1
        }
        if LucyMethodSignatureParser.Need(f.Type) {
            d := new cg.AttributeLucyMethodDescriptor()
            d.Descriptor = LucyMethodSignature.Encode(f.Type)
            method.AttributeLucyMethodDescriptor = d
        }
        if f.HaveDefaultValue {
            method.AttributeDefaultParameters = DefaultValueParser.Encode(c, f)
        }
        if method.isConstruction == false {
            if t := this.buildFunctionParameterAndReturnList(c, method.code, f, context, state); t > method.code.MaxStack {
                method.code.MaxStack = t
            }
        }
        {
            method.AttributeMethodParameters = new cg.AttributeMethodParameters()
            for _, v := range f.Type.ParameterList {
                p := new cg.MethodParameter()
                p.name = v.name
                p.accessFlags = cg.MethodParameterTypeAccMandated
                method.AttributeMethodParameters.Parameters = append(method.AttributeMethodParameters.Parameters, p)
            }
        }
        if f.Type.VoidReturn() == false {
            method.AttributeLucyReturnListNames = new cg.AttributeMethodParameters()
            for _, v := range f.Type.ReturnList {
                p := new cg.MethodParameter()
                p.name = v.name
                p.accessFlags = cg.MethodParameterTypeAccMandated
                method.AttributeLucyReturnListNames.Parameters =
                    append(method.AttributeLucyReturnListNames.Parameters, p)
            }
        }
        if len(f.Type.ReturnList) > 1 {
            if t := this.buildFunctionMultiReturnOffset(c, method.code,
                f, context, state); t > method.code.MaxStack {
                method.code.MaxStack = t
            }
        }
        if f.HasDefer {
            context.exceptionVarOffset = method.code.MaxLocals
            method.code.MaxLocals++
            method.code.Codes[method.code.CodeLength] = cg.OP_aconst_null
            method.code.CodeLength++
            copyOPs(method.code, storeLocalVariableOps(ast.VariableTypeObject, context.exceptionVarOffset)...)
            state.appendLocals(c, state.newObjectVariableType(ast.JavaThrowableClass))
        }
        this.buildBlock(c, method.code, f.block, context, state)
        return
    }
    fn  buildFunctionMultiReturnOffset(c cg.ClassHighLevel, code cg.AttributeCode,
        f ast.Function, context Context, state StackMapState) -> (maxStack char) {
        code.Codes[code.CodeLength] = cg.OP_aconst_null
        code.CodeLength++
        context.multiValueVarOffset = code.MaxLocals
        code.MaxLocals++
        copyOPs(code, storeLocalVariableOps(ast.VariableTypeObject,
            context.multiValueVarOffset)...)
        state.appendLocals(c, state.newObjectVariableType(javaRootObjectArray))
        maxStack = 1
        return
    }

    fn  mkFieldDefaultValue(c cg.ClassHighLevel, code cg.AttributeCode,
        astClass ast.Class, context Context, state StackMapState) {
        for _, v := range astClass.fields {
            if v.isStatic() || v.defaultValueExpression == null {
                continue
            }
            code.Codes[code.CodeLength] = cg.OP_aload_0
            code.CodeLength++
            state.pushStack(c, state.newObjectVariableType(ast.TypeName))
            stack := this.BuildExpression.build(c, code, v.defaultValueExpression, context, state)
            if t := char(1) + stack; t > code.MaxStack {
                code.MaxStack = t
            }
            state.popStack(1)
            code.Codes[code.CodeLength] = cg.OP_putfield
            c.InsertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
                ast.TypeName,
                v.name,
                Descriptor.typeDescriptor(v.Type)
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
        }
    }


    fn loadLocalVar(c cg.ClassHighLevel,
        code cg.AttributeCode, v ast.Variable) -> (maxStack char) {
        if v.beenCapturedAsLeftValue > 0 {
            return closure.loadLocalClosureVar(c, code, v)
        }
        maxStack = jvmSlotSize(v.Type)
        copyOPs(code, loadLocalVariableOps(v.Type.Type, v.localValOffset))
        return
    }

    fn storeLocalVar(c cg.ClassHighLevel,
        code cg.AttributeCode, v ast.Variable) -> (maxStack char) {
        if v.beenCapturedAsLeftValue > 0 {
            closure.storeLocalClosureVar(c, code, v)
            return
        }
        maxStack = jvmSlotSize(v.Type)
        copyOPs(code, storeLocalVariableOps(v.Type.Type, v.localValOffset)...)
        return
    }


}


