import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"

class  BuildExpressionIdentifier {
	

	eb BuildExpression
    
    fn BuildExpressionIdentifier(eb BuildExpression){
        this.super()
        this.eb = eb
    }

	fn  buildCapturedIdentifier(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		e ast.Expression,
		context Context) -> (maxStack char) {
		identifier := e.data.(ast.ExpressionIdentifier)
		//print(identifier.name, identifier.Variable.beenCapturedAsLeftValue,
		//	context.function.Closure.closureVariableExist(identifier.Variable))
		maxStack = jvmSlotSize(identifier.Variable.Type)
		if context.function.Closure.closureVariableExist(identifier.Variable) {
			if identifier.Variable.beenCapturedAsLeftValue > 0 {
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, char(0)))
				meta := closure.getMeta(identifier.Variable.Type.Type)
				code.codes[code.codeLength] = cg.OP_getfield
				c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
					c.name,
					identifier.Variable.name,
					"L" + meta.className + ";"
				), code.codes[code.codeLength+1:code.codeLength+3])
				code.codeLength += 3
				closure.unPack(c, code, identifier.Variable.Type)
			} else {
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, char(0)))
				code.codes[code.codeLength] = cg.OP_getfield
				c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
					c.name,
					identifier.Variable.name,
					Descriptor.typeDescriptor(identifier.Variable.Type)
				), code.codes[code.codeLength+1:code.codeLength+3])
				code.codeLength += 3
			}
		} else {
			if identifier.Variable.beenCapturedAsLeftValue > 0 {
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, identifier.Variable.localValOffset))
				closure.unPack(c, code, identifier.Variable.Type)
			} else {
				copyOPs(code, loadLocalVariableOps(e.value.Type, identifier.Variable.localValOffset))
			}
		}
		return
	}

	fn  buildIdentifier(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		e ast.Expression,
		context Context) -> (maxStack char) {
		if e.value.Type == ast.VariableTypeClass {
			panic("this is not happening")
		}
		identifier := e.data.(ast.ExpressionIdentifier)
		switch identifier{
		case e.value.Type == ast.VariableTypeEnum && identifier.enumName != null:
			loadInt32(c, code, identifier.enumName.value)
			maxStack = 1
			return
		case identifier.Function != null:
			return this.eb.BuildExpressionFunction.packFunction2MethodHandle(c, code, identifier.Function, context)
		case identifier.Variable.isGlobal:
			code.codes[code.codeLength] = cg.OP_getstatic
			c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
				this.eb.bp.mainClass.name,
				identifier.name,
				Descriptor.typeDescriptor(identifier.Variable.Type)
			), code.codes[code.codeLength+1:code.codeLength+3])
			code.codeLength += 3
			maxStack = jvmSlotSize(identifier.Variable.Type)
			return
		case identifier.Variable.beenCapturedAsLeftValue+identifier.Variable.beenCapturedAsRightValue > 0:
			return this.buildCapturedIdentifier(c, code, e, context)
		default:
			maxStack = jvmSlotSize(e.value)
			copyOPs(code, loadLocalVariableOps(e.value.Type, identifier.Variable.localValOffset))
			return
		}
	}	
}

