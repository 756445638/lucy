import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"

class  BuildExpressionIdentifier {
	

	eb BuildExpression
    
    fn BuildExpressionIdentifier(eb BuildExpression){
        this.super()
        this.eb = eb
    }

	fn  buildCapturedIdentifier(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		e ast.Expression,
		context Context) -> (maxStack char) {
		identifier := e.Data.(ast.ExpressionIdentifier)
		//fmt.Println(identifier.Name, identifier.Variable.BeenCapturedAsLeftValue,
		//	context.function.Closure.ClosureVariableExist(identifier.Variable))
		maxStack = jvmSlotSize(identifier.Variable.Type)
		if context.function.Closure.ClosureVariableExist(identifier.Variable) {
			if identifier.Variable.BeenCapturedAsLeftValue > 0 {
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, 0)...)
				meta := closure.getMeta(identifier.Variable.Type.Type)
				code.Codes[code.CodeLength] = cg.OP_getfield
				c.InsertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
					c.Name,
					identifier.Variable.Name,
					"L" + meta.className + ";"
				), code.Codes[code.CodeLength+1:code.CodeLength+3])
				code.CodeLength += 3
				closure.unPack(c, code, identifier.Variable.Type)
			} else {
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, 0)...)
				code.Codes[code.CodeLength] = cg.OP_getfield
				c.InsertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
					c.Name,
					identifier.Variable.Name,
					Descriptor.typeDescriptor(identifier.Variable.Type)
				), code.Codes[code.CodeLength+1:code.CodeLength+3])
				code.CodeLength += 3
			}
		} else {
			if identifier.Variable.BeenCapturedAsLeftValue > 0 {
				copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, identifier.Variable.LocalValOffset)...)
				closure.unPack(c, code, identifier.Variable.Type)
			} else {
				copyOPs(code, loadLocalVariableOps(e.Value.Type, identifier.Variable.LocalValOffset)...)
			}
		}
		return
	}

	fn  buildIdentifier(
		c cg.ClassHighLevel,
		code cg.AttributeCode,
		e ast.Expression,
		context Context) -> (maxStack char) {
		if e.Value.Type == ast.VariableTypeClass {
			panic("this is not happening")
		}
		identifier := e.Data.(ast.ExpressionIdentifier)
		switch identifier{
		case e.Value.Type == ast.VariableTypeEnum && identifier.EnumName != null:
			loadInt32(c, code, identifier.EnumName.Value)
			maxStack = 1
			return
		case identifier.Function != null:
			return this.BuildPackage.packFunction2MethodHandle(c, code, identifier.Function, context)
		case identifier.Variable.IsGlobal:
			code.Codes[code.CodeLength] = cg.OP_getstatic
			c.InsertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(
				this.BuildPackage.mainClass.Name,
				identifier.Name,
				Descriptor.typeDescriptor(identifier.Variable.Type)
			), code.Codes[code.CodeLength+1:code.CodeLength+3])
			code.CodeLength += 3
			maxStack = jvmSlotSize(identifier.Variable.Type)
			return
		case identifier.Variable.BeenCapturedAsLeftValue+identifier.Variable.BeenCapturedAsRightValue > 0:
			return this.buildCapturedIdentifier(c, code, e, context)
		default:
			maxStack = jvmSlotSize(e.Value)
			copyOPs(code, loadLocalVariableOps(e.Value.Type, identifier.Variable.LocalValOffset)...)
			return
		}
	}	
}

