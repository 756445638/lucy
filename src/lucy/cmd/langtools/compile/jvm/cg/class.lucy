
import "java/io"
import "lucy/binary"
import "lucy/cmd/langtools/compile/common"

public const	AccClassPublic     char = 0x0001 // 可以被包的类外访问。
public const	AccClassFinal      char = 0x0010 //不允许有子类。
public const	AccClassSuper      char = 0x0020 //当用到invokespecial指令时，需要特殊处理③的父类方法。
public const	AccClassInterface  char = 0x0200 // 标识定义的是接口而不是类。
public const	AccClassAbstract   char = 0x0400 //  不能被实例化。
public const	AccClassSynthetic  char = 0x1000 //标识并非Java源码生成的代码。
public const	AccClassAnnotation char = 0x2000 // 标识注解类型
public const	AccClassEnum       char = 0x4000 // 标识枚举类型


public class Class {
	writer                  io.FileOutputStream
	magic                   int //0xCAFEBABE
	public MinorVersion            char
	public MajorVersion            char
	public ConstPool               []ConstPool
	public accessFlags              char
	public ThisClass               char
	public superClass              char
	public interfaces              []char
	public fields                  []FieldInfo
	public methods                 []MethodInfo
	public attributes              []AttributeInfo
	public AttributeGroupedByName  AttributeGroupedByName
	public TypeAlias               []AttributeLucyTypeAlias
	public AttributeLucyEnum       AttributeLucyEnum
	public AttributeLucyComment    AttributeLucyComment
	public AttributeLucyClassConst AttributeLucyClassConst
	public AttributeInnerClasses   AttributeInnerClasses
	//const caches
	public Utf8Constants               map{string -> ConstPool }
	public IntConstants                map{int-> ConstPool }
	public LongConstants               map{long-> ConstPool }
	public FloatConstants              map{float-> ConstPool }
	public DoubleConstants             map{double-> ConstPool }
	public ClassConstants              map{string-> ConstPool }
	public StringConstants             map{string-> ConstPool }
	public FieldRefConstants           map{string-> ConstPool }
	public NameAndTypeConstants        map{string-> ConstPool }
	public MethodrefConstants          map{string-> ConstPool }
	public InterfaceMethodrefConstants map{string-> ConstPool }
	public MethodTypeConstants         map{string-> ConstPool }

	fn IsSynthetic() -> (is bool) {
		return (this.accessFlags & AccClassSynthetic) != 0
	}

	fn InsertMethodTypeConst(n ConstantInfoMethodTypeHighLevel) -> (index char) {
		if this.MethodTypeConstants == null {
			this.MethodTypeConstants = new  map{string -> ConstPool}()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.MethodTypeConstants[n.toString()]; con != null {
			return con.selfIndex
		}
		info := new ConstantInfoMethodType ( this.InsertUtf8Const(n.descriptor) ).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info)
		this.MethodTypeConstants[n.toString()] = info
		return info.selfIndex
	}

	fn InsertInterfaceMethodrefConst(n ConstantInfoInterfaceMethodrefHighLevel) -> (index char) {
		if this.InterfaceMethodrefConstants == null {
			this.InterfaceMethodrefConstants = new map {string -> ConstPool} ()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.InterfaceMethodrefConstants[n.toString()]; con != null {
			return con.selfIndex
		}
		info :=  new ConstantInfoInterfaceMethodref(
			this.InsertClassConst(n.Class),
			this.InsertNameAndType( new ConstantInfoNameAndTypeHighLevel(     n.Method,  n.descriptor ) )
		).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info)
		this.InterfaceMethodrefConstants[n.toString()] = info
		return info.selfIndex
	}

	fn InsertMethodrefConst(n ConstantInfoMethodrefHighLevel) -> (index char) {
		if this.MethodrefConstants == null {
			this.MethodrefConstants = new map{string -> ConstPool} ()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.MethodrefConstants[n.toString()]; con != null {
			return con.selfIndex
		}
		info := new ConstantInfoMethodref(
                    this.InsertClassConst(n.Class),
                    this.InsertNameAndType( new ConstantInfoNameAndTypeHighLevel (
                       n.Method,
                       n.descriptor) )
			) .ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info)
		this.MethodrefConstants[n.toString()] = info
		return info.selfIndex
	}

	fn InsertNameAndType(n ConstantInfoNameAndTypeHighLevel) -> (index char) {
		if this.NameAndTypeConstants == null {
			this.NameAndTypeConstants = new map{string -> ConstPool} ()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.NameAndTypeConstants[n.toString()]; con != null {
			return con.selfIndex
		}
		info := new ConstantInfoNameAndType(
			       this.InsertUtf8Const(n.name),
			    this.InsertUtf8Const(n.descriptor)
		    ).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info)
		this.NameAndTypeConstants[n.toString()] = info
		return info.selfIndex
	}
	fn InsertFieldRefConst(f ConstantInfoFieldrefHighLevel) -> (index char) {
		if this.FieldRefConstants == null {
			this.FieldRefConstants = new map{string -> ConstPool}()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.FieldRefConstants[f.toString()]; con != null {
			return con.selfIndex
		}
		info := new ConstantInfoFieldref(
			this.InsertClassConst(f.Class),
			this.InsertNameAndType(new ConstantInfoNameAndTypeHighLevel(   f.Field,  f.descriptor)
			)
		).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info)
		this.FieldRefConstants[f.toString()] = info
		return info.selfIndex
	}
	fn InsertUtf8Const(s string) -> (index char) {
		if this.Utf8Constants == null {
			this.Utf8Constants = new map {string -> ConstPool}( )
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.Utf8Constants[s]; con != null  {
			return con.selfIndex
		}
		info := (new ConstantInfoUtf8(s)).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info)
		this.Utf8Constants[s] = info
		return info.selfIndex
	}

	fn InsertIntConst(i int) -> (index char) {
		if this.IntConstants == null {
			this.IntConstants = new map{ int -> ConstPool }()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.IntConstants[i];   con != null {
			return con.selfIndex
		}
		info := new ConstantInfoInteger(i).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info)
		this.IntConstants[i] = info
		return info.selfIndex
	}
	fn InsertLongConst(i long) -> (index char) {
		if this.LongConstants == null {
			this.LongConstants = new map{ long -> ConstPool } ()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.LongConstants[i]; con != null {
			return con.selfIndex
		}
		info := new ConstantInfoLong(i).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info , null )
		this.LongConstants[i] = info
		return info.selfIndex
	}

	fn InsertFloatConst(f float) -> (index char) {
		if this.FloatConstants == null {
			this.FloatConstants = new map {float -> ConstPool} ()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.FloatConstants[f]; con != null {
			return con.selfIndex
		}
		info := new ConstantInfoFloat(f).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info)
		this.FloatConstants[f] = info
		return info.selfIndex
	}

	fn InsertDoubleConst(f double) -> (index char) {
		if this.DoubleConstants == null {
			this.DoubleConstants = new map{double -> ConstPool}()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.DoubleConstants[f]; con != null {
			return con.selfIndex
		}
		info := (new ConstantInfoDouble(f)).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info , null )
		this.DoubleConstants[f] = info
		return info.selfIndex
	}

	fn InsertClassConst(name string) -> (index char) {
		if this.ClassConstants == null {
			this.ClassConstants = new map {string -> ConstPool} ()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.ClassConstants[name]; con != null {
			return con.selfIndex
		}
		info := new ConstantInfoClass(this.InsertUtf8Const(name)).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool.append(info  )
		this.ClassConstants[name] = info
		return info.selfIndex
	}

	fn InsertStringConst(s string) -> (index char) {
		if this.StringConstants == null {
			this.StringConstants = new map{string -> ConstPool }()
		}
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null}
		}
		if con := this.StringConstants[s]; con != null {
			return con.selfIndex
		}
		info := new ConstantInfoString(this.InsertUtf8Const(s)).ToConstPool()
		info.selfIndex = this.constPoolUint16Length()
		this.ConstPool . append( info)
		this.StringConstants[s] = info
		return info.selfIndex
	}



	fn fromHighLevel(high ClassHighLevel) {
		this.MajorVersion = char(common.CompileFlags.JvmMajorVersion.getValue())
		this.MinorVersion = char(common.CompileFlags.JvmMajorVersion.getValue())
		if len(this.ConstPool) == 0 {
			this.ConstPool = []ConstPool{null} // jvm const pool index begin at 1
		}
		this.accessFlags = high.accessFlags
		this.ThisClass = this.InsertClassConst(high.name)
		this.superClass = this.InsertClassConst(high.superClass)
		this.interfaces = []char {}
		for _, i := range high.interfaces {
			inter := (new ConstantInfoClass(this.InsertUtf8Const(i))).ToConstPool()
			index := this.constPoolUint16Length()
			this.interfaces . append(index)
			this.ConstPool . append(inter)
		}
		this.fields = []FieldInfo{}
		for _, f := range high.fields {
			field := new FieldInfo()
			field.accessFlags = f.accessFlags
			field.nameIndex = this.InsertUtf8Const(f.name)
            field.attributes = []AttributeInfo{}
			if f.AttributeConstantValue != null {
				field.attributes . append(  f.AttributeConstantValue.ToAttributeInfo(this))
			}
			field.descriptorIndex = this.InsertUtf8Const(f.descriptor)
			if f.AttributeLucyFieldDescriptor != null {
				field.attributes . append(  f.AttributeLucyFieldDescriptor.ToAttributeInfo(this))
			}
			if f.AttributeLucyConst != null {
				field.attributes . append(  f.AttributeLucyConst.ToAttributeInfo(this))
			}
			if f.AttributeLucyComment != null {
				field.attributes . append(  f.AttributeLucyComment.ToAttributeInfo(this))
			}
			this.fields.append(field)
		}
		this.methods = []MethodInfo{}
		for _, ms := range high.methods {
			for _, m := range ms {
				info := new MethodInfo()
				info.accessFlags = m.accessFlags
				info.nameIndex = this.InsertUtf8Const(m.name)
				info.descriptorIndex = this.InsertUtf8Const(m.Descriptor)
				info.attributes = []AttributeInfo{}
				if m.code != null {
					info.attributes . append( m.code.ToAttributeInfo(this))
				}
				if m.AttributeLucyMethodDescriptor != null {
					info.attributes . append( m.AttributeLucyMethodDescriptor.ToAttributeInfo(this))
				}
				if m.AttributeLucyTriggerPackageInitMethod != null {
					info.attributes . append(  m.AttributeLucyTriggerPackageInitMethod.ToAttributeInfo(this))
				}
				if m.AttributeDefaultParameters != null {
					info.attributes . append(  m.AttributeDefaultParameters.ToAttributeInfo(this))
				}
				if m.AttributeLucyComment != null {
					info.attributes . append(  m.AttributeLucyComment.ToAttributeInfo(this))
				}
				if m.AttributeMethodParameters != null {
					t := m.AttributeMethodParameters.ToAttributeInfo(this)
					if t != null {
						info.attributes . append(t)
					}
				}
				if m.AttributeLucyReturnListNames != null {
					t := m.AttributeLucyReturnListNames.ToAttributeInfo(this, AttributeNameLucyReturnListNames)
					if t != null {
						info.attributes.append(t)
					}
				}
				this.methods . append(info)
			}
		}
		if this.attributes == null {
			this.attributes = []AttributeInfo{}
		}
		//source file
		this.attributes . append(new AttributeSourceFile(high.getSourceFile()).ToAttributeInfo(this))
		for _, v := range this.TypeAlias {
			this.attributes . append( v.ToAttributeInfo(this))
		}
		if this.AttributeLucyEnum != null {
			this.attributes . append( this.AttributeLucyEnum.ToAttributeInfo(this))
		}
		if this.AttributeLucyComment != null {
			this.attributes . append(  this.AttributeLucyComment.ToAttributeInfo(this))
		}
		if this.AttributeLucyClassConst != null {
			this.attributes . append( this.AttributeLucyClassConst.ToAttributeInfo(this))
		}
		if a := this.AttributeInnerClasses.ToAttributeInfo(this); a != null {
			this.attributes . append(  a)
		}
		for _, v := range high.TemplateFunctions {
			this.attributes.append(  v.ToAttributeInfo(this))
		}
		this.ifConstPoolOverMaxSize()
		return
	}

	fn constPoolUint16Length() -> (length char){
		return char(len(this.ConstPool))
	}
	fn ifConstPoolOverMaxSize() {
		if len(this.ConstPool) > ConstantPoolMaxSize {
			panic(sprintf("const pool max size is:%d", ConstantPoolMaxSize))
		}
	}

	fn IsInnerClass() -> (is bool) {
		if len(this.AttributeGroupedByName[AttributeNameInnerClasses]) == 0 {
			return
		}
		innerClass := this.AttributeGroupedByName[AttributeNameInnerClasses][0]
		var attr AttributeInnerClasses
		thisClassName := string(this.ConstPool[binary.BigEndian.getChar(this.ConstPool[this.ThisClass].Info)].Info)
		attr.FromBs(this, innerClass.Info)
		for _, v := range attr.Classes {
			if thisClassName == v.innerClass {
				return true
			}
		}
		return
	}


	fn OutPut(writer io.FileOutputStream)  {
		this.writer = writer
		//magic number
		{
		    bs := new byte[](4)
		    bs[0] = 0xca
		    bs[1] = 0xfe
		    bs[2] = 0xba
		    bs[3] = 0xbe
		    writer.write(bs)
		}

		// minor version
		bs2 := new []byte(2)
		binary.BigEndian.putChar(bs2, char(this.MinorVersion))
		writer.write(bs2.getUnderlyingArray())
		// major version
		binary.BigEndian.putChar(bs2, char(this.MajorVersion))
		writer.write(bs2.getUnderlyingArray())
		//const pool
		binary.BigEndian.putChar(bs2, this.constPoolUint16Length())
		writer.write(bs2.getUnderlyingArray())
		for _, v := range this.ConstPool {
			if v == null {
				continue
			}
			writer.write([]byte{byte(v.Tag)}.getUnderlyingArray())
			writer.write(v.Info.getUnderlyingArray())
		}
		//access flag
		binary.BigEndian.putChar(bs2, char(this.accessFlags))
		writer.write(bs2.getUnderlyingArray())

		binary.BigEndian.putChar(bs2, this.ThisClass)
		//this class
		writer.write(bs2.getUnderlyingArray())

		//super Class
		binary.BigEndian.putChar(bs2, this.superClass)
		writer.write(bs2.getUnderlyingArray())

		// interface
		binary.BigEndian.putChar(bs2, char(len(this.interfaces)))
		writer.write(bs2.getUnderlyingArray())

		for _, v := range this.interfaces {
			binary.BigEndian.putChar(bs2, char(v))
			writer.write(bs2.getUnderlyingArray())
		}
		this.writeFields()
		//methods
		this.writeMethods()
		// attribute
		this.writeAttributeInfo(this.attributes)
	}

	fn writeMethods()  {
		bs2 := new []byte(2)
		binary.BigEndian.putChar(bs2, char(len(this.methods)))
		this.writer.write(bs2.getUnderlyingArray())
		for _, v := range this.methods {
			binary.BigEndian.putChar(bs2, char(v.accessFlags))
			this.writer.write(bs2.getUnderlyingArray())
			binary.BigEndian.putChar(bs2, v.nameIndex)
			this.writer.write(bs2.getUnderlyingArray())
			binary.BigEndian.putChar(bs2, v.descriptorIndex)
			this.writer.write(bs2.getUnderlyingArray())
			this.writeAttributeInfo(v.attributes)
		}
	}

	fn writeFields()  {
		bs2 := new []byte(2)
		binary.BigEndian.putChar(bs2, char(len(this.fields)))
		this.writer.write(bs2.getUnderlyingArray())
		for _, v := range this.fields {
			binary.BigEndian.putChar(bs2, char(v.accessFlags))
			this.writer.write(bs2.getUnderlyingArray())
			binary.BigEndian.putChar(bs2, v.nameIndex)
			this.writer.write(bs2.getUnderlyingArray())
			binary.BigEndian.putChar(bs2, v.descriptorIndex)
			this.writer.write(bs2.getUnderlyingArray())
			this.writeAttributeInfo(v.attributes)
		}
	}

	fn writeAttributeInfo(attrs []AttributeInfo)   {
		bs2 := new []byte(2)
		binary.BigEndian.putChar(bs2, char(len(attrs)))
		this.writer.write(bs2.getUnderlyingArray())
		bs4 := new []byte(4)
		for _, v := range attrs {
			binary.BigEndian.putChar(bs2 , v.nameIndex)
			this.writer.write(bs2.getUnderlyingArray())
			binary.BigEndian.putInt(bs4 , v.attributeLength)
			this.writer.write(bs4.getUnderlyingArray())
			this.writer.write(v.Info.getUnderlyingArray())
		}
	}	
}

