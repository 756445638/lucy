import "lucy/binary"


class InnerClass {
	public InnerClass  string
	public OuterClass  string
	public Name        string
	public AccessFlags char
	
	fn FromBs(c Class, bs []byte) {
    		nameIndex := binary.BigEndian.getChar(c.ConstPool[binary.BigEndian.getChar(bs)].Info)
    		this.InnerClass = string(c.ConstPool[nameIndex].Info)
    		if 0 == binary.BigEndian.getChar(bs[2:]) {
    			//TODO:: what zero means???
    		} else {
    			nameIndex = binary.BigEndian.getChar(c.ConstPool[binary.BigEndian.getChar(bs[2:])].Info)
    			this.OuterClass = string(c.ConstPool[nameIndex].Info)
    		}
    		if 0 == binary.BigEndian.getChar(bs[4:]) {
    			//TODO:: what zero means???
    		} else {
    			this.Name = string(c.ConstPool[binary.BigEndian.getChar(bs[4:])].Info)
    		}
    		this.AccessFlags = binary.BigEndian.getChar(bs[6:])
    }
}


class AttributeInnerClasses {
	Classes []InnerClass
	fn FromBs(c Class, bs []byte) {
		length := binary.BigEndian.getChar(bs)
		bs = bs[2:]
		if int(length*8) != len(bs) {
			panic("length not match")
		}
		this.Classes = []InnerClass{}
		for len(bs) > 0 {
			inner := new InnerClass()
			inner.FromBs(c, bs[:8])
			this.Classes.append( inner)
			bs = bs[8:]
		}
	}

	fn ToAttributeInfo(c Class) -> (ret AttributeInfo) {
		if this == null || len(this.Classes) == 0 {
			return null
		}
		ret = new AttributeInfo()
		ret.NameIndex = c.InsertUtf8Const(AttributeNameInnerClasses)
		ret.Info = new []byte(2)
		binary.BigEndian.putChar(ret.Info, char(len(this.Classes)))
		for _, v := range this.Classes {
			bs8 := new []byte(8)
			binary.BigEndian.putChar(bs8, c.InsertClassConst(v.InnerClass))
			binary.BigEndian.putChar(bs8[2:], c.InsertClassConst(v.OuterClass))
			binary.BigEndian.putChar(bs8[4:], c.InsertUtf8Const(v.Name))
			binary.BigEndian.putChar(bs8[6:], v.AccessFlags)
			ret.Info.appendAll(bs8)
		}
		ret.attributeLength = (len(ret.Info))
		return ret
	}

}












