import "lucy/binary"


public class innerClass {
	public innerClass  string
	public outerClass  string
	public name        string
	public accessFlags char
	
	fn FromBs(c Class, bs []byte) {
    		nameIndex := binary.BigEndian.getChar(c.ConstPool[binary.BigEndian.getChar(bs)].Info)
    		this.innerClass = string(c.ConstPool[nameIndex].Info)
    		if 0 == binary.BigEndian.getChar(bs[2:]) {
    			//TODO:: what zero means???
    		} else {
    			nameIndex = binary.BigEndian.getChar(c.ConstPool[binary.BigEndian.getChar(bs[2:])].Info)
    			this.outerClass = string(c.ConstPool[nameIndex].Info)
    		}
    		if 0 == binary.BigEndian.getChar(bs[4:]) {
    			//TODO:: what zero means???
    		} else {
    			this.name = string(c.ConstPool[binary.BigEndian.getChar(bs[4:])].Info)
    		}
    		this.accessFlags = binary.BigEndian.getChar(bs[6:])
    }
}


class AttributeInnerClasses {
	Classes []innerClass
	fn FromBs(c Class, bs []byte) {
		length := binary.BigEndian.getChar(bs)
		bs = bs[2:]
		if int(length*8) != len(bs) {
			panic("length not match")
		}
		this.Classes = []innerClass{}
		for len(bs) > 0 {
			inner := new innerClass()
			inner.FromBs(c, bs[:8])
			this.Classes.append( inner)
			bs = bs[8:]
		}
	}

	fn ToAttributeInfo(c Class) -> (ret AttributeInfo) {
		if this == null || len(this.Classes) == 0 {
			return null
		}
		ret = new AttributeInfo()
		ret.nameIndex = c.InsertUtf8Const(AttributeNameInnerClasses)
		ret.Info = new []byte(2)
		binary.BigEndian.putChar(ret.Info, char(len(this.Classes)))
		for _, v := range this.Classes {
			bs8 := new []byte(8)
			binary.BigEndian.putChar(bs8, c.InsertClassConst(v.innerClass))
			binary.BigEndian.putChar(bs8[2:], c.InsertClassConst(v.outerClass))
			binary.BigEndian.putChar(bs8[4:], c.InsertUtf8Const(v.name))
			binary.BigEndian.putChar(bs8[6:], v.accessFlags)
			ret.Info.appendAll(bs8)
		}
		ret.attributeLength = (len(ret.Info))
		return ret
	}

}












