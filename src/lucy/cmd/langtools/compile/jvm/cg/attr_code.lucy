import "lucy/binary"
 

public class AttributeCode  {
	public	MaxStack          char
	public	maxLocals         char
	public	CodeLength        int
	public	Codes             []byte
	public	LineNumbers       AttributeLineNumber
	public	Exceptions        []ExceptionTable
			attributes        []AttributeInfo
	public	AttributeStackMap AttributeStackMap
	
	fn ToAttributeInfo(c Class) -> (ret AttributeInfo)  {
		ret = new AttributeInfo()
		ret.nameIndex = c.insertUtf8Const("Code")
		ret.Info = new []byte( 8)
		binary.BigEndian.putChar(ret.Info[0:2], this.MaxStack)
		binary.BigEndian.putChar(ret.Info[2:4], this.maxLocals)
		binary.BigEndian.putInt(ret.Info[4:8], (this.CodeLength))
		ret.Info . appendAll( this.Codes)
		ret.Info . appendAll(this.mkExceptions())
		if this.attributes == null {
		    this.attributes =  []AttributeInfo{}
		}
		if info := this.LineNumbers.ToAttributeInfo(c); info != null {
			this.attributes.append(info)
		}
		if info := this.AttributeStackMap.ToAttributeInfo(c); info != null {
			this.attributes . append(info)
		}
		ret.Info . appendAll(this.mkAttributes(c))
		ret.attributeLength = (len(ret.Info))
		return ret
	}

	/*
		mk line number attribute
	*/
	public fn MKLineNumber(lineNumber int) {
	    if this.LineNumbers == null {
	        this.LineNumbers = new AttributeLineNumber()
	    }
		line := new AttributeLinePc()
		line.startPc = char(this.CodeLength)
		line.lineNumber = char(lineNumber)
		this.LineNumbers.lineNumbers.append(line)
	}

	fn mkAttributes(c Class) -> (bs []byte)  {
		bs = new []byte (2)
		binary.BigEndian.putChar(bs, char(len(this.attributes)))

		if len(this.attributes) > 0 {
			b := new []byte(0)
			for _, v := range this.attributes {
				bb := new []byte(2)
				binary.BigEndian.putChar(bb, v.nameIndex)
				bs4 := new []byte(4)
				binary.BigEndian.putInt(bs4, (v.attributeLength))
				bb.appendAll(bs4)
				bb.appendAll(v.Info)
				b.appendAll(bb)
			}
			bs.appendAll(b)
		}
		return bs
	}

	fn mkExceptions() -> (bs []byte)  {
		bs = new []byte (2)
		binary.BigEndian.putChar(bs, char(len(this.Exceptions)))
		if len(this.Exceptions) > 0 {
			b := new []byte (8*len(this.Exceptions))
			for k, v := range this.Exceptions {
				binary.BigEndian.putChar(b[k*8:], v.startPc)
				binary.BigEndian.putChar(b[k*8+2:], v.endPc)
				binary.BigEndian.putChar(b[k*8+4:], v.handlerPc)
				binary.BigEndian.putChar(b[k*8+6:], v.catchType)
			}
			bs.appendAll(b)
		}
		return bs
	}
}





public class ExceptionTable  {
	public startPc   char
	public endPc     char
	public handlerPc char
	public catchType char
}
