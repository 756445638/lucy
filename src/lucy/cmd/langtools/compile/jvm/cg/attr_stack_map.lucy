
import "java/lang/Object"
import "lucy/binary"

interface StackMap  {
	fn ToBytes() -> ([]byte)
}

public class AttributeStackMap {
	public StackMaps []StackMap
	fn ToAttributeInfo(c Class) -> (ret AttributeInfo) {
		if this == null || len(this.StackMaps) == 0 {
			return null
		}
		info := new AttributeInfo() 
		info.NameIndex = c.InsertUtf8Const(AttributeNameStackMap)
		bs := new []byte(2)
		binary.BigEndian.putChar(bs, char(len(this.StackMaps)))
		for _, v := range this.StackMaps {
			bs . appendAll(v.ToBytes())
		}
		info.Info = bs
		info.attributeLength = (len(info.Info))
		return info
	}
}



public class StackMapSameFrame {
	public FrameType byte
	public fn StackMapSameFrame(FrameType byte){
		this.super()
		this.FrameType = FrameType
	}
	fn ToBytes() -> (bs []byte) {
		return []byte{this.FrameType}
	}
}


public class StackMapSameLocals1StackItemFrame {
	public FrameType byte
	Stack     StackMapVerificationTypeInfo
	fn StackMapSameLocals1StackItemFrame(FrameType byte ,Stack     StackMapVerificationTypeInfo ){
        this.super()
        this.FrameType = FrameType
        this.Stack = Stack
	}
	fn ToBytes() -> (bs []byte) {
		bs  = []byte{this.FrameType}
		bs.appendAll(this.Stack.ToBytes())
		return bs
	}
}



public class StackMapSameLocals1StackItemFrameExtended {
	public FrameType byte
	public Delta     char
	public Stack     StackMapVerificationTypeInfo
	fn ToBytes() -> (bs []byte) {
		bs = new []byte(3)
		bs[0] = this.FrameType
		binary.BigEndian.putChar(bs[1:], this.Delta)
		bs. appendAll(this.Stack.ToBytes())
		return
	}
}



public class StackMapChopFrame  {
	public FrameType byte
	public Delta     char
	public fn StackMapChopFrame(FrameType byte ,Delta     char ){
        this.super()
        this.FrameType = FrameType
        this.Delta = Delta
	}
	fn ToBytes() -> (bs []byte) {
		bs = new []byte(3)
		bs[0] = this.FrameType
		binary.BigEndian.putChar(bs[1:], this.Delta)
		return bs
	}
}



public class StackMapSameFrameExtended {
	public FrameType byte
	public Delta     char
	public fn StackMapSameFrameExtended(FrameType byte ,Delta char ){
        this.super()
        this.FrameType = FrameType
        this.Delta = Delta
	}
	fn ToBytes() -> (bs []byte) {
		bs  = new []byte(3)
		bs[0] = this.FrameType
		binary.BigEndian.putChar(bs[1:], this.Delta)
		return bs
	}
}



public class StackMapAppendFrame {
	public FrameType byte
	public Delta     char
	public Locals    []StackMapVerificationTypeInfo
	fn ToBytes() -> (bs []byte) {
		bs = new []byte(3)
		bs[0] = this.FrameType
		binary.BigEndian.putChar(bs[1:], this.Delta)
		for _, v := range this.Locals {
			bs .appendAll ( v.ToBytes())
		}
		return bs
	}
}



public class StackMapFullFrame {
	public FrameType byte
	public Delta     char
	public Locals    []StackMapVerificationTypeInfo
	public Stacks    []StackMapVerificationTypeInfo

    public fn StackMapFullFrame(FrameType byte , Delta     char ,Locals ,  Stacks []StackMapVerificationTypeInfo ){
        this.super()
        this.FrameType = FrameType
        this.Delta = Delta
        this.Locals = Locals
        this.Stacks = Stacks
    }

	fn ToBytes() -> (bs []byte) {
		bs = new []byte(5)
		bs[0] = this.FrameType
		binary.BigEndian.putChar(bs[1:], this.Delta)
		binary.BigEndian.putChar(bs[3:], char(len(this.Locals)))
		for _, v := range this.Locals {
			bs .appendAll( v.ToBytes())
		}
		bs2 := new []byte(2)
		binary.BigEndian.putChar(bs2, char(len(this.Stacks)))
		bs .appendAll(bs2)
		for _, v := range this.Stacks {
			bs .appendAll (v.ToBytes())
		}
		return bs
	}
}



public class StackMapTopVariableInfo {}
public class StackMapIntegerVariableInfo {}
public class StackMapFloatVariableInfo {}
public class StackMapLongVariableInfo {}
public class StackMapDoubleVariableInfo {}
public class StackMapNullVariableInfo {}
public class StackMapUninitializedThisVariableInfo {}
public class StackMapObjectVariableInfo  {
	public Index    char
	public Readable string
}
public class StackMapUninitializedVariableInfo  {
	public CodeOffset char
	public fn StackMapUninitializedVariableInfo(CodeOffset char){
		this.super()
		this.CodeOffset = CodeOffset
	}
}

public class StackMapVerificationTypeInfo  {
	public Verify Object
	fn ToBytes() -> (bs []byte)  {
		if _,ok := this.Verify.(StackMapTopVariableInfo) ; ok {
			return []byte{0}
		}
		if _,ok := this.Verify.(StackMapIntegerVariableInfo) ; ok {
			return []byte{1}
		}
		if _,ok := this.Verify.(StackMapFloatVariableInfo) ; ok {
			return []byte{2}
		}
		if _,ok := this.Verify.(StackMapDoubleVariableInfo) ; ok {
			return []byte{3}
		}
		if _,ok := this.Verify.(StackMapLongVariableInfo) ; ok {
			return []byte{4}
		}
		if _,ok := this.Verify.(StackMapNullVariableInfo) ; ok {
			return []byte{5}
		}
		if _,ok := this.Verify.(StackMapUninitializedThisVariableInfo) ; ok {
			return []byte{6}
		}
		if v,ok := this.Verify.(StackMapObjectVariableInfo) ; ok {
			bs := new []byte(3)
			bs[0] = 7
			binary.BigEndian.putChar(bs[1:], v.Index)
			return bs
		}
		if v,ok := this.Verify.(StackMapUninitializedVariableInfo) ; ok {
			bs := new []byte (3)
			bs[0] = 8
			binary.BigEndian.putChar(bs[1:], v.CodeOffset)
			return bs
		}
	}	
}



