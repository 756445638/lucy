 import "lucy/binary"

 
public const	MethodParameterTypeAccFinal     = 0x0010
public const	MethodParameterTypeAccSynthetic = 0x1000
public const	MethodParameterTypeAccMandated  = 0x8000
 

public class AttributeMethodParameters  {
	public Parameters []MethodParameter
	public fn FromBs(c Class, bs []byte) {
		if len(bs) != int(bs[0])*4+1 {
			panic("impossible")
		}
		bs = bs[1:]
		this.Parameters = []MethodParameter{}
		for len(bs) > 0 {
			p := new MethodParameter()
			p.Name = string(c.ConstPool[binary.BigEndian.getChar(bs)].Info)
			p.AccessFlags = binary.BigEndian.getChar(bs[2:])
			this.Parameters . append(p)
			bs = bs[4:]
		}
	}

	fn ToAttributeInfo(c Class, attrName string...) -> (ret AttributeInfo)  {
		if this == null || len(this.Parameters) == 0 {
			return null
		}
		ret = new AttributeInfo()
		if len(attrName) > 0 {
			ret.NameIndex = c.InsertUtf8Const(attrName[0])
		} else {
			ret.NameIndex = c.InsertUtf8Const(AttributeNameMethodParameters)
		}
		ret.attributeLength = (len(this.Parameters)*4 + 1)
		ret.Info = new []byte(ret.attributeLength)
		ret.Info[0] = byte(len(this.Parameters))
		for k, v := range this.Parameters {
			binary.BigEndian.putChar(ret.Info[4*k+1:], c.InsertUtf8Const(v.Name))
			binary.BigEndian.putChar(ret.Info[4*k+3:], v.AccessFlags)
		}
		return ret
	}
}


class MethodParameter  {
	Name        string
	AccessFlags char
}


