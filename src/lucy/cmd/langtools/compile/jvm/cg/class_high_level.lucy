import "lucy/binary"

public class ClassHighLevel {
	Class Class
	/*
		one class file can be compile form multi source file
	*/
	public sourceFiles              map { string -> bool }
	public name                     string
	public accessFlags              char
	public superClass               string
	public interfaces               []string
	public fields                   map { string -> FieldHighLevel }
	public methods                  map { string -> []MethodHighLevel }
	public TriggerPackageInitMethod MethodHighLevel
	public TemplateFunctions        []AttributeTemplateFunction

	public fn InsertSourceFile(filename string) {
		if this.sourceFiles == null {
			this.sourceFiles = {filename -> true}
		    return
		}
		this.sourceFiles[filename] = true
	}

	public fn InsertMethodRefConst(mr ConstantInfoMethodrefHighLevel,
		location []byte) {
		binary.BigEndian.putChar(location, this.Class.InsertMethodrefConst(mr))
	}

	public fn InsertMethodCall(code AttributeCode, op byte,
		className, method, descriptor string) {
		code.Codes[code.CodeLength] = op
		this.InsertMethodRefConst(
		    new ConstantInfoMethodrefHighLevel(     className,     method,  descriptor),
		    code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.CodeLength += 3
	}
	
	/*
		new a method name,make_node_objects sure it does exists before
	*/
	public fn NewMethodName(prefix string) -> (name string)  {
		if this.methods == null ||
			this.methods[prefix] == null {
			return prefix
		}
		for i := 0; i < 65535 ; i++ {
			var name string
			if i == 0 {
				name = prefix
			} else {
				name = sprintf("%s$%d", prefix, i)
			}
			if false == this.methods.keyExist(name) {
				return name
			}
		}
		panic("names over flow") // this is not happening
	}

	public fn InsertStringConst(s string, location []byte) {
		binary.BigEndian.putChar(location, this.Class.InsertStringConst(s))
	}

	public fn AppendMethod(ms MethodHighLevel...) {
		if this.methods == null {
			this.methods = new map {string -> []MethodHighLevel}()
		}
		for _, v := range ms {
			if v.name == "" {
				panic("null name")
			}
			if  this.methods.keyExist(v.name) {
				this.methods[v.name].append(v)
			} else {
				this.methods[v.name] = []MethodHighLevel{v}
			}
		}
	}

	public fn InsertInterfaceMethodrefConst(
		constant ConstantInfoInterfaceMethodrefHighLevel,
		location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertInterfaceMethodrefConst(constant))
	}

	public fn InsertMethodTypeConst(constant ConstantInfoMethodTypeHighLevel,
		location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertMethodTypeConst(constant))
	}

	public fn InsertFieldRefConst(constant ConstantInfoFieldrefHighLevel,
		location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertFieldRefConst(constant))
	}

	public fn InsertClassConst(className string, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertClassConst(className))
	}
	public fn InsertIntConst(i int, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertIntConst(i))
	}

	public fn InsertLongConst(value long, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertLongConst(value))
	}

	public fn InsertFloatConst(value float, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertFloatConst(value))
	}

	public fn InsertDoubleConst(value double, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertDoubleConst(value))
	}

	/*
		source files
	*/
	fn getSourceFile() -> (name string) {
		if len(this.sourceFiles) == 0 {
			return ""
		}
		if len(this.sourceFiles) == 1 {
			for k, _ := range this.sourceFiles {
				return k
			}
		}
		var s string
		for k, _ := range this.sourceFiles {
		    index := len(k)
		    for index > 0 {
		        if s[index] == '/' || s[index] == '\\'{
		            break
		        }
		        index --
		    }
			s = k[:index]
			break
		}
		s += "\\{"
		i := 0
		for f, _ := range this.sourceFiles {
		    index := len(f)
            for index > 0 {
                if s[index] == '/' || s[index] == '\\'{
                    break
                }
                index--
            }
			s += f[index:]
			if i != len(this.sourceFiles)-1 {
				s += ","
			}
			i++
		}
		s += "}"
		return s
	}

	fn ToLow() ->(c Class) {
    	this.Class.fromHighLevel(this)
    	return this.Class
    }
}

