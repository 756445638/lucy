import "lucy/binary"

class ClassHighLevel {
	Class Class
	/*
		one class file can be compile form multi source file
	*/
	SourceFiles              map { string -> bool }
	Name                     string
	AccessFlags              char
	SuperClass               string
	Interfaces               []string
	Fields                   map { string -> FieldHighLevel }
	Methods                  map { string -> []MethodHighLevel }
	TriggerPackageInitMethod MethodHighLevel
	TemplateFunctions        []AttributeTemplateFunction

	fn InsertSourceFile(filename string) {
		if this.SourceFiles == null {
			this.SourceFiles = {filename -> true}
		    return
		}
		this.SourceFiles[filename] = true
	}

	fn InsertMethodRefConst(mr ConstantInfoMethodrefHighLevel,
		location []byte) {
		binary.BigEndian.putChar(location, this.Class.InsertMethodrefConst(mr))
	}

	fn InsertMethodCall(code AttributeCode, op byte,
		className, method, descriptor string) {
		code.Codes[code.CodeLength] = op
		this.InsertMethodRefConst(
		    new ConstantInfoMethodrefHighLevel(     className,     method,  descriptor),
		    code.Codes[code.CodeLength+1:code.CodeLength+3])
		code.CodeLength += 3
	}
	
	/*
		new a method name,make_node_objects sure it does exists before
	*/
	fn NewMethodName(prefix string) -> (name string)  {
		if this.Methods == null ||
			this.Methods[prefix] == null {
			return prefix
		}
		for i := 0; i < 65535 ; i++ {
			var name string
			if i == 0 {
				name = prefix
			} else {
				name = sprintf("%s$%d", prefix, i)
			}
			if false == this.Methods.keyExist(name) {
				return name
			}
		}
		panic("names over flow") // this is not happening
	}

	fn InsertStringConst(s string, location []byte) {
		binary.BigEndian.putChar(location, this.Class.InsertStringConst(s))
	}

	fn AppendMethod(ms MethodHighLevel...) {
		if this.Methods == null {
			this.Methods = new map {string -> []MethodHighLevel}()
		}
		for _, v := range ms {
			if v.Name == "" {
				panic("null name")
			}
			if  this.Methods.keyExist(v.Name) {
				this.Methods[v.Name].append(v)
			} else {
				this.Methods[v.Name] = []MethodHighLevel{v}
			}
		}
	}

	fn InsertInterfaceMethodrefConst(
		constant ConstantInfoInterfaceMethodrefHighLevel,
		location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertInterfaceMethodrefConst(constant))
	}

	fn InsertMethodTypeConst(constant ConstantInfoMethodTypeHighLevel,
		location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertMethodTypeConst(constant))
	}

	fn InsertFieldRefConst(constant ConstantInfoFieldrefHighLevel,
		location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertFieldRefConst(constant))
	}

	fn InsertClassConst(className string, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertClassConst(className))
	}
	fn InsertIntConst(i int, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertIntConst(i))
	}

	fn InsertLongConst(value long, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertLongConst(value))
	}

	fn InsertFloatConst(value float, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertFloatConst(value))
	}

	fn InsertDoubleConst(value double, location []byte) {
		binary.BigEndian.putChar(location,
			this.Class.InsertDoubleConst(value))
	}

	/*
		source files
	*/
	fn getSourceFile() -> (name string) {
		if len(this.SourceFiles) == 0 {
			return ""
		}
		if len(this.SourceFiles) == 1 {
			for k, _ := range this.SourceFiles {
				return k
			}
		}
		var s string
		for k, _ := range this.SourceFiles {
		    index := len(k)
		    for index > 0 {
		        if s[index] == '/' || s[index] == '\\'{
		            break
		        }
		        index --
		    }
			s = k[:index]
			break
		}
		s += "\\{"
		i := 0
		for f, _ := range this.SourceFiles {
		    index := len(f)
            for index > 0 {
                if s[index] == '/' || s[index] == '\\'{
                    break
                }
                index--
            }
			s += f[index:]
			if i != len(this.SourceFiles)-1 {
				s += ","
			}
			i++
		}
		s += "}"
		return s
	}

	fn ToLow() ->(c Class) {
    	this.Class.fromHighLevel(this)
    	return this.Class
    }
}

