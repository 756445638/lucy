
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"
import "lucy/cmd/langtools/compile/common"



class BuildinFunctionCall {
    
    eb BuildExpression
    BuildinFunctionAssert BuildinFunctionAssert
    BuildinFunctionCatchPanic BuildinFunctionCatchPanic
    BuildinFunctionLen BuildinFunctionLen
    BuildinFunctionPrint BuildinFunctionPrint
    BuildinFunctionPrintf BuildinFunctionPrintf
    BuildinFunctionSprintf BuildinFunctionSprintf


    fn BuildinFunctionCall(eb BuildExpression){
        this.super()
        this.eb = eb
        this.BuildinFunctionAssert = new BuildinFunctionAssert(eb)
        this.BuildinFunctionCatchPanic = new BuildinFunctionCatchPanic(eb)
        this.BuildinFunctionLen = new BuildinFunctionLen(eb)
        this.BuildinFunctionPrint = new BuildinFunctionPrint(eb)
        this.BuildinFunctionPrintf = new BuildinFunctionPrintf(eb)
        this.BuildinFunctionSprintf = new BuildinFunctionSprintf(eb)
        this.BuildinFunctionAssert = new BuildinFunctionAssert(eb)
    }


    fn mkBuildInFunctionCall(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionFunctionCall)
        if call.Function.loadedFromCorePackage {
            maxStack = this.eb.BuildExpressionCallArgs.buildCallArgs(c, code, call.Args, call.VArgs, context, state)
            code.codes[code.codeLength] = cg.OP_invokestatic
            c.insertMethodRefConst(
                new cg.ConstantInfoMethodrefHighLevel(
                    call.Function.entrance.Class.name,
                    call.Function.name,
                    call.Function.entrance.Descriptor
            ), code.codes[code.codeLength+1:code.codeLength+3])
            code.codeLength += 3
            if e.isStatementExpression {
                if call.Function.Type.VoidReturn() == false {
                    if len(call.Function.Type.ReturnList) > 1 {
                        code.codes[code.codeLength] = cg.OP_pop
                        code.codeLength++
                    } else {
                        if jvmSlotSize(e.value) == 1 {
                            code.codes[code.codeLength] = cg.OP_pop
                            code.codeLength++
                        } else {
                            code.codes[code.codeLength] = cg.OP_pop2
                            code.codeLength++
                        }
                    }
                }
            }
            return
        }
        switch call.Function.name {
        case common.BuildInFunctionPrint:
            return this.BuildinFunctionPrint.mkBuildInPrint(c, code, e, context, state)
        case common.BuildInFunctionPanic:
            return this.BuildinFunctionCatchPanic.mkBuildInPanic(c, code, e, context, state)
        case common.BuildInFunctionCatch:
            return this.BuildinFunctionCatchPanic.mkBuildInCatch(c, code, e, context)
        /*
        case common.BuildInFunctionMonitorEnter, common.BuildInFunctionMonitorExit:
            maxStack = this.build(c, code, call.Args[0], context, state)
            if call.Function.name == common.BuildInFunctionMonitorEnter {
                code.codes[code.codeLength] = cg.OP_monitorenter
            } else { // monitor enter on exit
                code.codes[code.codeLength] = cg.OP_monitorexit
            }
            code.codeLength++
          */
        case common.BuildInFunctionPrintf:
            return this.BuildinFunctionPrintf.build(c, code, e, context, state)
        case common.BuildInFunctionSprintf:
            return this.BuildinFunctionSprintf.build(c, code, e, context, state)
        case common.BuildInFunctionLen:
            return this.BuildinFunctionLen.build(c, code, e, context, state)
        //case common.BuildInFunctionBlockHole:
        //    return this.mkBuildInBlackHole(c, code, e, context, state)
        case common.BuildInFunctionAssert:
            return this.BuildinFunctionAssert.build(c, code, e, context, state)
        default:
            panic("unknown  buildIn function:" + call.Function.name)
        }
        return
    }

}

