
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"
 
class Context {
	c                   	ast.Class
	function                ast.Function
	exceptionVarOffset      char
	multiValueVarOffset     char
	currentSourceFile       string
	currentLineNumber       int
	Defer                   ast.StatementDefer
	lastStackMapState       StackMapState
	lastStackMapStateLocals []cg.StackMapVerificationTypeInfo
	lastStackMapStateStacks []cg.StackMapVerificationTypeInfo
	lastStackMapOffset      int
	stackMapOffsets         []int

	fn MakeStackMap(code cg.AttributeCode, state StackMapState, offset int) {
		if this.lastStackMapOffset == offset {
			code.AttributeStackMap.StackMaps =
				code.AttributeStackMap.StackMaps[0 : len(code.AttributeStackMap.StackMaps)-1]
			this.stackMapOffsets = this.stackMapOffsets[0 : len(this.stackMapOffsets)-1]
			this.lastStackMapState = null
			if len(this.stackMapOffsets) > 0 {
				this.lastStackMapOffset = this.stackMapOffsets[len(this.stackMapOffsets)-1]
			} else {
				this.lastStackMapOffset = -1
			}
		}
		var delta char
		if this.lastStackMapOffset == -1 {
			/*
				first one
			*/
			delta = char(offset)
		} else {
			delta = char(offset - this.lastStackMapOffset - 1)
		}
		defer {
			this.lastStackMapOffset = offset // rewrite
			this.lastStackMapState = state
			this.lastStackMapStateLocals = new []cg.StackMapVerificationTypeInfo(len(state.locals))
			copy(this.lastStackMapStateLocals, state.locals)
			this.lastStackMapStateStacks = new []cg.StackMapVerificationTypeInfo(len(state.stacks))
			copy(this.lastStackMapStateStacks, state.stacks)
			this.stackMapOffsets.append( offset)
		}
		if state == this.lastStackMapState { // same state
			if len(state.locals) == len(this.lastStackMapStateLocals) && len(state.stacks) == 0 {
				/*
					same frame or same frame extended
				*/
				if delta <= 63 {
					code.AttributeStackMap.StackMaps.append(new cg.StackMapSameFrame(byte(delta)))
				} else {
					code.AttributeStackMap.StackMaps.append(new cg.StackMapSameFrameExtended(251b, delta))
				}
				return
			}
			if len(this.lastStackMapStateLocals) == len(state.locals) && len(state.stacks) == 1 { // 1 stack or 1 stack extended
				if delta <= 64 {
					code.AttributeStackMap.StackMaps.append(
						new cg.StackMapSameLocals1StackItemFrame(
							byte(delta + 64),
							state.stacks[0]
						))
				} else {
					code.AttributeStackMap.StackMaps.append(
						new cg.StackMapSameLocals1StackItemFrameExtended(
							247,
							delta,
							state.stacks[0]
						))
				}
				return
			}
			if len(this.lastStackMapStateLocals) < len(state.locals) && len(state.stacks) == 0 { // append frame
				num := len(state.locals) - len(this.lastStackMapStateLocals)
				if num <= 3 {
					appendFrame := new cg.StackMapAppendFrame()
					appendFrame.frameType = byte(num + 251)
					appendFrame.delta = delta
					appendFrame.locals = new []cg.StackMapVerificationTypeInfo(num)
					copy(appendFrame.locals, state.locals[len(state.locals)-num:])
					code.AttributeStackMap.StackMaps.append(appendFrame)
					return
				}
			}
		}
		// full frame
		fullFrame := new cg.StackMapFullFrame()
		fullFrame.frameType = 255
		fullFrame.delta = delta
		fullFrame.locals = new []cg.StackMapVerificationTypeInfo(len(state.locals))
		copy(fullFrame.locals, state.locals)
		fullFrame.stacks = new []cg.StackMapVerificationTypeInfo(len(state.stacks))
		copy(fullFrame.stacks, state.stacks)
		code.AttributeStackMap.StackMaps.append(fullFrame)
		return
	}

	fn  appendLimeNumberAndSourceFile(
		pos ast.Pos,
		code cg.AttributeCode,
		c cg.ClassHighLevel) {
		if pos == null {
			return
		}
		if pos.filename != this.currentSourceFile {
			c.insertSourceFile(pos.filename)
			this.currentSourceFile = pos.filename
			this.currentLineNumber = pos.line
			code.MKLineNumber(pos.line)
			return
		}
		if this.currentLineNumber != pos.line {
			code.MKLineNumber(pos.line)
			this.currentLineNumber = pos.line
		}
	}

}

