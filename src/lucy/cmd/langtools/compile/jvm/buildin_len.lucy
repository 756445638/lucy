import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"
import "lucy/binary"


class BuildinFunctionLen {



    eb BuildExpression
    
    fn BuildinFunctionLen(eb BuildExpression){
        this.super()
        this.eb = eb
    }

    

    fn build(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionFunctionCall)
        a0 := call.Args[0]
        maxStack = this.eb.build(c, code, a0, context, state)
        code.Codes[code.CodeLength] = cg.OP_dup
        code.CodeLength++
        if 2 > maxStack {
            maxStack = 2
        }
        code.Codes[code.CodeLength] = cg.OP_ifnonnull
        binary.BigEndian.putChar(code.Codes[code.CodeLength+1:code.CodeLength+3], char(8))
        code.Codes[code.CodeLength+3] = cg.OP_pop
        code.Codes[code.CodeLength+4] = cg.OP_iconst_0
        code.CodeLength += 5
        noNullExit := (new cg.Exit(cg.OP_goto, code))
        state.pushStack(c, a0.value)
        context.MakeStackMap(code, state, code.CodeLength)
        state.popStack(1)
        if a0.value.Type == ast.VariableTypeJavaArray {
            code.Codes[code.CodeLength] = cg.OP_arraylength
            code.CodeLength++
        } else if a0.value.Type == ast.VariableTypeArray {
            meta := ArrayMetas[a0.value.array.Type]
            code.Codes[code.CodeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                    meta.className,
                   "size",
                "()I"), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
        } else if a0.value.Type == ast.VariableTypeMap {
            code.Codes[code.CodeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                 mapClass,
                 "size",
                 "()I"
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
        } else if a0.value.Type == ast.VariableTypeString {
            code.Codes[code.CodeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                 javaStringClass,
                 "length",
                 "()I"
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
        }
        writeExits([]cg.Exit{noNullExit}, code.CodeLength)
        state.pushStack(c, typeInt)
        context.MakeStackMap(code, state, code.CodeLength)
        state.popStack(1)
        if e.isStatementExpression {
            code.Codes[code.CodeLength] = cg.OP_pop
            code.CodeLength++
        }
        return
    }
}

