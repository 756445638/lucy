import "lucy/cmd/langtools/compile/ast"
import "lucy/jvm/cg"

class BuildExpressionFunctionCall {
    eb  BuildExpression    
    bfc BuildinFunctionCall

    fn BuildExpressionFunctionCall(eb BuildExpression) {
        this.super()
        this.eb = eb
        this.bfc = new BuildinFunctionCall(eb)
    }

    fn buildFunctionPointerCall(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionFunctionCall)
        maxStack = this.eb.build(c , code , call.Expression , context , state)
        stack := this.eb.BuildExpressionCallArgs.buildCallArgs(c , code , call.args , call.vArgs , context , state)
        if t := char(1) + stack ; t > maxStack {
            maxStack = t
        }
        code.codes[code.codeLength] = cg.OP_invokevirtual
        c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel("java/lang/invoke/MethodHandle",
            methodHandleInvokeMethodName,
            Descriptor.methodDescriptor(call.Expression.value.functionType)) , code.codes[code.codeLength + 1 : code.codeLength + 3])
        code.codeLength += 3
        if t := popCallResult(code , e , call.Expression.value.functionType) ; t > maxStack {
            maxStack = t
        }
        return
    }
    fn buildFunctionCall(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        e ast.Expression,
        context Context,
        state StackMapState) -> (maxStack char) {
        call := e.data.(ast.ExpressionFunctionCall)
        if call.Function == null {
            return this.buildFunctionPointerCall(c , code , e , context , state)
        }
        if call.Function.templateFunction != null {
            return this.eb.BuildTemplateFunctionCall.buildTemplateFunctionCall(c , code , e , context , state)
        }
        if call.Function.isBuildIn {
            return this.bfc.mkBuildInFunctionCall(c , code , e , context , state)
        }
        if call.Expression != null &&
            call.Expression.Type == ast.ExpressionTypeFunctionLiteral {
            maxStack = this.eb.build(c , code , call.Expression , context , state)
        }
        if call.Function.isClosureFunction == false {
            maxStack = this.eb.BuildExpressionCallArgs.buildCallArgs(c , code , call.args , call.vArgs , context , state)
            code.codes[code.codeLength] = cg.OP_invokestatic
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(call.Function.entrance.Class.name,
                call.Function.entrance.name,
                call.Function.entrance.Descriptor) , code.codes[code.codeLength + 1 : code.codeLength + 3])
            code.codeLength += 3
        } else {
            //closure function call
            if context.function.closure.closureFunctionExist(call.Function) {
                copyOPs(code , loadLocalVariableOps(ast.VariableTypeObject , char(0)))
                code.codes[code.codeLength] = cg.OP_getfield
                c.insertFieldRefConst(new cg.ConstantInfoFieldrefHighLevel(c.name,
                    call.Function.name,
                    "L" + call.Function.entrance.Class.name + ";") , code.codes[code.codeLength + 1 : code.codeLength + 3])
                code.codeLength += 3
            } else {
                copyOPs(code , loadLocalVariableOps(ast.VariableTypeObject , call.Function.closureVariableOffSet))
            }

            state.pushStack(c , state.newObjectVariableType(call.Function.entrance.Class.name))
            defer {

                state.popStack(1)
            }

            stack := this.eb.BuildExpressionCallArgs.buildCallArgs(c , code , call.args , call.vArgs , context , state)
            if t := char(1) + stack ; t > maxStack {
                maxStack = t
            }
            code.codes[code.codeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(call.Function.entrance.Class.name,
                call.Function.name,
                call.Function.entrance.Descriptor) , code.codes[code.codeLength + 1 : code.codeLength + 3])
            code.codeLength += 3
        }

        if t := popCallResult(code , e , call.Function.Type) ; t > maxStack {
            maxStack = t
        }
        return
    }

}


