
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/compile/jvm/cg"


class AutoVariableForRangeMap {
	MapObject               char
	KeySets                 char
	KeySetsK, KeySetsLength char
	K, V                    char
}

class BuildForRangeMap {
    
    eb BuildExpression
    bb  BuildBlock

    fn BuildForRangeMap(eb BuildExpression , bb  BuildBlock){
        this.super()
        this.eb = eb
        this.bb = bb
    }
    
    fn build(
        c cg.ClassHighLevel,
        code cg.AttributeCode,
        s ast.StatementFor,
        context Context,
        state StackMapState) -> (maxStack char) {
        attr := s.RangeAttr
        maxStack = this.eb.build(
            c,
            code,
            attr.RangeOn,
            context,
            state) // map instance on stack
        // if null skip
        code.Codes[code.CodeLength] = cg.OP_dup
        code.CodeLength++
        noNullExit := new cg.Exit(cg.OP_ifnonnull, code)
        code.Codes[code.CodeLength] = cg.OP_pop
        code.CodeLength++
        s.exits.append( new cg.Exit(cg.OP_goto, code))
        writeExits([]cg.Exit{noNullExit}, code.CodeLength)
        state.pushStack(c, attr.RangeOn.value)
        context.MakeStackMap(code, state, code.CodeLength)
        state.popStack(1)
        forState := new StackMapState(state)
        defer state.addTop(forState) // add top
        //keySets
        code.Codes[code.CodeLength] = cg.OP_dup
        if 2 > maxStack {
            maxStack = 2
        }
        code.CodeLength++
        code.Codes[code.CodeLength] = cg.OP_invokevirtual
        c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
            mapClass,
            "keySet",
            "()Ljava/util/Set;"
        ), code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.CodeLength += 3
        code.Codes[code.CodeLength] = cg.OP_invokeinterface
        c.insertInterfaceMethodrefConst(new cg.ConstantInfoInterfaceMethodrefHighLevel(
            "java/util/Set",
            "toArray",
            "()[Ljava/lang/Object;"
        ), code.Codes[code.CodeLength+1:code.CodeLength+3])
        code.Codes[code.CodeLength+3] = 1
        code.Codes[code.CodeLength+4] = 0
        code.CodeLength += 5
        // get length
        code.Codes[code.CodeLength] = cg.OP_dup
        code.CodeLength++
        if 3 > maxStack {
            maxStack = 3
        }
        var autoVar AutoVariableForRangeMap
        {
            autoVar.KeySetsLength = code.maxLocals
            code.maxLocals++
            forState.appendLocals(c, typeInt)
            t := new ast.Type()
            t.Type = ast.VariableTypeJavaArray
            t.array = forState.newObjectVariableType(javaRootClass)
            autoVar.KeySets = code.maxLocals
            code.maxLocals++
            forState.appendLocals(c, t)
            autoVar.MapObject = code.maxLocals
            code.maxLocals++
            forState.appendLocals(c, forState.newObjectVariableType(mapClass))
            autoVar.KeySetsK = code.maxLocals
            code.maxLocals++
            forState.appendLocals(c, typeInt)

        }
        code.Codes[code.CodeLength] = cg.OP_arraylength
        code.CodeLength++
        copyOPs(code, storeLocalVariableOps(ast.VariableTypeInt, autoVar.KeySetsLength))
        copyOPs(code, storeLocalVariableOps(ast.VariableTypeObject, autoVar.KeySets))
        copyOPs(code, storeLocalVariableOps(ast.VariableTypeObject, autoVar.MapObject))
        // k set to -1
        code.Codes[code.CodeLength] = cg.OP_iconst_m1
        code.CodeLength++
        copyOPs(code, storeLocalVariableOps(ast.VariableTypeInt, autoVar.KeySetsK))
        //handle captured vars
        if s.condition.Type == ast.ExpressionTypeVarAssign {
            if attr.IdentifierValue != null && attr.IdentifierValue.Variable.beenCapturedAsLeftValue > 0 {
                closure.createClosureVar(c, code, attr.IdentifierValue.Variable.Type)
                attr.IdentifierValue.Variable.localValOffset = code.maxLocals
                code.maxLocals++
                copyOPs(code,
                    storeLocalVariableOps(ast.VariableTypeObject, attr.IdentifierValue.Variable.localValOffset))
                forState.appendLocals(c,
                    forState.newObjectVariableType(closure.getMeta(attr.IdentifierValue.Variable.Type.Type).className))
            }
            if attr.IdentifierKey != null &&
                attr.IdentifierKey.Variable.beenCapturedAsLeftValue > 0 {
                closure.createClosureVar(c, code, attr.IdentifierKey.Variable.Type)
                attr.IdentifierKey.Variable.localValOffset = code.maxLocals
                code.maxLocals++
                copyOPs(code,
                    storeLocalVariableOps(ast.VariableTypeObject, attr.IdentifierKey.Variable.localValOffset))
                forState.appendLocals(c,
                    forState.newObjectVariableType(closure.getMeta(attr.IdentifierKey.Variable.Type.Type).className))
            }
        }

        s.ContinueCodeOffset = code.CodeLength
        context.MakeStackMap(code, forState, code.CodeLength)
        blockState := new StackMapState(forState)
        code.Codes[code.CodeLength] = cg.OP_iinc
        if autoVar.K > 255 {
            panic("over 255")
        }
        code.Codes[code.CodeLength+1] = byte(autoVar.KeySetsK)
        code.Codes[code.CodeLength+2] = 1
        code.CodeLength += 3
        // load k
        copyOPs(code, loadLocalVariableOps(ast.VariableTypeInt, autoVar.KeySetsK))

        // load length
        copyOPs(code, loadLocalVariableOps(ast.VariableTypeInt, autoVar.KeySetsLength))
        if 2 > maxStack {
            maxStack = 2
        }
        s.exits.append(new cg.Exit(cg.OP_if_icmpge, code))
        if attr.IdentifierValue != null || attr.ExpressionValue != null {
            // load k sets
            copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, autoVar.KeySets))

            // swap
            copyOPs(code, loadLocalVariableOps(ast.VariableTypeInt, autoVar.KeySetsK))
            //get object for hashMap
            code.Codes[code.CodeLength] = cg.OP_aaload
            code.CodeLength++
            // load  map object
            copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, autoVar.MapObject))
            // swap
            code.Codes[code.CodeLength] = cg.OP_swap
            code.CodeLength++
            code.Codes[code.CodeLength] = cg.OP_invokevirtual
            c.insertMethodRefConst(new cg.ConstantInfoMethodrefHighLevel(
                mapClass,
                "get",
                "(Ljava/lang/Object;)Ljava/lang/Object;"
            ), code.Codes[code.CodeLength+1:code.CodeLength+3])
            code.CodeLength += 3
            if attr.RangeOn.value.Map.V.isPointer() == false {
                TypeConverterAndPrimitivePacker.unPackPrimitives(c, code, attr.RangeOn.value.Map.V)
            } else {
                TypeConverterAndPrimitivePacker.castPointer(c, code, attr.RangeOn.value.Map.V)
            }
            autoVar.V = code.maxLocals
            code.maxLocals += jvmSlotSize(attr.RangeOn.value.Map.V)
            //store to V
            copyOPs(code, storeLocalVariableOps(attr.RangeOn.value.Map.V.Type, autoVar.V))
            blockState.appendLocals(c, attr.RangeOn.value.Map.V)
        }

        // store to k,if need
        if attr.IdentifierKey != null || attr.ExpressionKey != null {
            // load k sets
            copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, autoVar.KeySets))
            // load k
            copyOPs(code, loadLocalVariableOps(ast.VariableTypeInt, autoVar.KeySetsK))
            code.Codes[code.CodeLength] = cg.OP_aaload
            code.CodeLength++
            if attr.RangeOn.value.Map.K.isPointer() == false {
                TypeConverterAndPrimitivePacker.unPackPrimitives(c, code, attr.RangeOn.value.Map.K)
            } else {
                TypeConverterAndPrimitivePacker.castPointer(c, code, attr.RangeOn.value.Map.K)
            }
            autoVar.K = code.maxLocals
            code.maxLocals += jvmSlotSize(attr.RangeOn.value.Map.K)
            copyOPs(code, storeLocalVariableOps(attr.RangeOn.value.Map.K.Type, autoVar.K))
            blockState.appendLocals(c, attr.RangeOn.value.Map.K)
        }

        // store k and v into user defined variable
        //store v in real v
        if s.condition.Type == ast.ExpressionTypeVarAssign {
            if attr.IdentifierValue != null {
                if attr.IdentifierValue.Variable.beenCapturedAsLeftValue > 0 {
                    copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject,
                        attr.IdentifierValue.Variable.localValOffset))
                    copyOPs(code,
                        loadLocalVariableOps(attr.IdentifierValue.Variable.Type.Type,
                            autoVar.V))
                    this.eb.storeLocalVar(c, code, attr.IdentifierValue.Variable)
                } else {
                    attr.IdentifierValue.Variable.localValOffset = autoVar.V
                }
            }
            if attr.IdentifierKey != null {
                if attr.IdentifierKey.Variable.beenCapturedAsLeftValue > 0 {
                    copyOPs(code, loadLocalVariableOps(ast.VariableTypeObject, attr.IdentifierKey.Variable.localValOffset))
                    copyOPs(code,
                        loadLocalVariableOps(attr.IdentifierKey.Variable.Type.Type, autoVar.K))
                    this.eb.storeLocalVar(c, code, attr.IdentifierKey.Variable)
                } else {
                    attr.IdentifierKey.Variable.localValOffset = autoVar.K
                }
            }
        } else { // for k,v  = range xxx
            // store v
            if attr.ExpressionValue != null {
                stackLength := len(blockState.stacks)
                stack, remainStack, op, _ :=
                    this.eb.BuildExpressionLeftValue.getLeftValue(c, code, attr.ExpressionValue, context, blockState)
                if stack > maxStack { // this means  current stack is 0
                    maxStack = stack
                }
                copyOPs(code,
                    loadLocalVariableOps(attr.RangeOn.value.Map.V.Type, autoVar.V))
                if t := remainStack + jvmSlotSize(attr.RangeOn.value.Map.V); t > maxStack {
                    maxStack = t
                }
                copyOPs(code, op)
                forState.popStack(len(blockState.stacks) - stackLength)
            }
            if attr.ExpressionKey != null {
                stackLength := len(blockState.stacks)
                stack, remainStack, op, _ :=
                    this.eb.BuildExpressionLeftValue.getLeftValue(c, code, attr.ExpressionKey, context, blockState)
                if stack > maxStack { // this means  current stack is 0
                    maxStack = stack
                }
                copyOPs(code,
                    loadLocalVariableOps(attr.RangeOn.value.Map.K.Type, autoVar.K))
                if t := remainStack + jvmSlotSize(attr.RangeOn.value.Map.K); t > maxStack {
                    maxStack = t
                }
                copyOPs(code, op)
                blockState.popStack(len(blockState.stacks) - stackLength)
            }
        }
        // build block
        this.bb.buildBlock(c, code, s.block, context, blockState)
        forState.addTop(blockState)
        if s.block.notExecuteToLastStatement == false {
            jumpTo(code, s.ContinueCodeOffset)
        }

        return
    }


}

