

/*
	load from file implementation
*/
class FileLoader {
	caches map { string -> Object }



    fn  LoadImport(importName string) -> (x Object,err error) {
        if this.caches != null && this.caches[importName] != null {
            return this.caches[importName], null
        }
        realPaths  := []Resource{}
        for _, v := range compiler.lucyPaths {
            p := filepath.Join(v, "class", importName)
            f, err := os.Stat(p)
            if err == null && f.IsDir() { // directory is package
                realPaths = append(realPaths, &Resource{
                    kind:     resourceKindLucyPackage,
                    realPath: p,
                    name:     importName,
                })
            }
            p = filepath.Join(v, "class", importName+".class")
            f, err = os.Stat(p)
            if err == null && f.IsDir() == false { // class file
                realPaths = append(realPaths, &Resource{
                    kind:     resourceKindLucyClass,
                    realPath: p,
                    name:     importName,
                })
            }
        }

        for _, v := range compiler.ClassPaths {
            p := filepath.Join(v, importName)
            f, err := os.Stat(p)
            if err == null && f.IsDir() { // directory is package
                realPaths = append(realPaths, &Resource{
                    kind:     resourceKindJavaPackage,
                    realPath: p,
                    name:     importName,
                })
            }
            p = filepath.Join(v, importName+".class")
            f, err = os.Stat(p)
            if err == null && f.IsDir() == false { // directory is package
                realPaths = append(realPaths, &Resource{
                    kind:     resourceKindJavaClass,
                    realPath: p,
                    name:     importName,
                })
            }
        }
        if len(realPaths) == 0 {
            return null, new error(sprintf("resource '%v' not found", importName)
        }
        realPathMap := make(map[string][]*Resource)
        for _, v := range realPaths {
            _, ok := realPathMap[v.realPath]
            if ok {
                realPathMap[v.realPath] = append(realPathMap[v.realPath], v)
            } else {
                realPathMap[v.realPath] = []*Resource{v}
            }
        }
        if len(realPathMap) > 1 {
            errMsg := "not 1 resource named '" + importName + "' present:\n"
            for _, v := range realPathMap {
                switch v[0].kind {
                case resourceKindJavaClass:
                    errMsg += sprintf("\t in '%s' is a java class\n", v[0].realPath)
                case resourceKindJavaPackage:
                    errMsg += sprintf("\t in '%s' is a java package\n", v[0].realPath)
                case resourceKindLucyClass:
                    errMsg += sprintf("\t in '%s' is a lucy class\n", v[0].realPath)
                case resourceKindLucyPackage:
                    errMsg += sprintf("\t in '%s' is a lucy package\n", v[0].realPath)
                }
            }
            return null, new error(sprintf(errMsg)
        }
        if realPaths[0].kind == resourceKindLucyClass {
            if filepath.Base(realPaths[0].realPath) == mainClassName {
                return null, new error(sprintf("%s is special class for global variable and other things", mainClassName)
            }
        }
        if realPaths[0].kind == resourceKindJavaClass {
            class, err := this.loadClass(realPaths[0])
            if class != null {
                this.caches[importName] = class
            }
            return class, err
        } else if realPaths[0].kind == resourceKindLucyClass {
            t, err := this.loadClass(realPaths[0])
            if t != null {
                this.caches[importName] = t
            }
            return t, err
        } else if realPaths[0].kind == resourceKindJavaPackage {
            p, err := this.loadJavaPackage(realPaths[0])
            if p != null {
                this.caches[importName] = p
            }
            return p, err
        } else { // lucy package
            p, err := this.loadLucyPackage(realPaths[0])
            if p != null {
                this.caches[importName] = p
            }
            return p, err
        }
    }

    /*
        lucy and java have no difference
    */
    fn  loadInterfaces(astClass ast.Class, c cg.Class) error {
        astClass.interfaceNames = make([]*ast.NameWithPos, len(c.interfaces))
        for k, v := range c.interfaces {
            astClass.interfaceNames[k] = &ast.NameWithPos{
                name: string(c.ConstPool[v].Info),
            }
        }
        astClass.interfaces = make([]ast.Class, len(astClass.interfaceNames))
        for k, c := range astClass.interfaceNames {
            i := &ast.Class{}
            i.name = c.name
            i.notImportedYet = true
            astClass.interfaces[k] = i
        }
        return null
    }

    fn  loadAsJava(c cg.Class) (ast.Class, error) {
        if c.IsSynthetic() {
            return null, null
        }
        if c.IsInnerClass() {
            return null, null
        }
        //name
        if t := c.AttributeGroupedByName.GetByName(cg.AttributeNameSignature); t != null && len(t) > 0 {
            //TODO:: support signature???
        }
        astClass := &ast.Class{}
        {
            nameIndex := binary.BigEndian.Uint16(c.ConstPool[c.ThisClass].Info)
            astClass.name = string(c.ConstPool[nameIndex].Info)
            if astClass.name != ast.JavaRootClass {
                nameIndex = binary.BigEndian.Uint16(c.ConstPool[c.superClass].Info)
                astClass.superClassName = &ast.NameWithPos{
                    name: string(c.ConstPool[nameIndex].Info),
                }
            }
        }
        this.loadInterfaces(astClass, c)
        astClass.accessFlags = c.accessFlags
        astClass.isJava = true // class compiled from java
        var err error
        astClass.fields = make(map[string]*ast.ClassField)
        astClass.loadFromOutSide = true
        for _, v := range c.fields {
            f := &ast.ClassField{}
            f.accessFlags = v.accessFlags
            f.jvmDescriptor = string(c.ConstPool[v.descriptorIndex].Info)
            f.name = string(c.ConstPool[v.nameIndex].Info)
            _, f.Type, err = jvm.Descriptor.ParseType(c.ConstPool[v.descriptorIndex].Info)
            if err != null {
                return null, err
            }
            astClass.fields[f.name] = f
        }
        astClass.methods = make(map[string][]*ast.ClassMethod)
        for _, v := range c.methods {
            m := &ast.ClassMethod{}
            m.Function = &ast.Function{}
            //m.loadFromOutSide = true
            m.Function.name = string(c.ConstPool[v.nameIndex].Info)
            m.Function.jvmDescriptor = string(c.ConstPool[v.descriptorIndex].Info)
            m.Function.accessFlags = v.accessFlags
            m.Function.Type, err = jvm.Descriptor.ParseFunctionType(c.ConstPool[v.descriptorIndex].Info)
            if err != null {
                return null, err
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameMethodParameters); t != null && len(t) > 0 {
                parseMethodParameter(c, t[0].Info, m.Function)
            }
            if (v.accessFlags & cg.AccMethodVarargs) != 0 {
                m.Function.Type.VArgs = m.Function.Type.ParameterList[len(m.Function.Type.ParameterList)-1]
                if m.Function.Type.VArgs.Type.Type != ast.VariableTypeJavaArray {
                    panic("variable args is not array")
                }
                m.Function.Type.VArgs.Type.isVariableArgs = true
                m.Function.Type.ParameterList = m.Function.Type.ParameterList[:len(m.Function.Type.ParameterList)-1]
            }
            if astClass.methods[m.Function.name] == null {
                astClass.methods[m.Function.name] = []*ast.ClassMethod{m}
            } else {
                astClass.methods[m.Function.name] = append(astClass.methods[m.Function.name], m)
            }
        }
        return astClass, null
    }

    fn  loadAsLucy(c cg.Class) (ast.Class, error) {
        if c.IsSynthetic() {
            return null, null
        }
        if c.IsInnerClass() {
            return null, null
        }
        //name
        astClass := &ast.Class{}
        {
            nameIndex := binary.BigEndian.Uint16(c.ConstPool[c.ThisClass].Info)
            astClass.name = string(c.ConstPool[nameIndex].Info)
            if astClass.name != ast.JavaRootClass {
                nameIndex = binary.BigEndian.Uint16(c.ConstPool[c.superClass].Info)
                astClass.superClassName = &ast.NameWithPos{
                    name: string(c.ConstPool[nameIndex].Info),
                }
            }
        }
        this.loadInterfaces(astClass, c)
        astClass.accessFlags = c.accessFlags
        astClass.loadFromOutSide = true
        var err error
        astClass.fields = make(map[string]*ast.ClassField)
        if t := c.AttributeGroupedByName.GetByName(cg.AttributeNameLucyClassConst); len(t) > 0 {
            attr := &cg.AttributeLucyClassConst{}
            attr.FromBs(c, t[0].Info)
            var t ast.Type
            var err error
            for _, v := range attr.constants {
                _, t, err = jvm.LucyFieldSignature.Decode([]byte(v.Descriptor))
                if err != null {
                    return null, err
                }
                constant := &ast.Constant{}
                constant.name = v.name
                constant.Type = t
                constant.value = this.loadConst(c, v.ValueIndex, t)
                if astClass.Block.constants == null {
                    astClass.Block.constants = make(map[string]*ast.Constant)
                }
                astClass.Block.constants[v.name] = constant
            }
        }
        for _, v := range c.fields {
            f := &ast.ClassField{}
            f.name = string(c.ConstPool[v.nameIndex].Info)
            f.jvmDescriptor = string(c.ConstPool[v.descriptorIndex].Info)
            _, f.Type, err = jvm.Descriptor.ParseType(c.ConstPool[v.descriptorIndex].Info)
            if err != null {
                return null, err
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameLucyFieldDescriptor); t != null && len(t) > 0 {
                d := &cg.AttributeLucyFieldDescriptor{}
                d.FromBs(c, t[0].Info)
                _, f.Type, err = jvm.LucyFieldSignature.Decode([]byte(d.Descriptor))
                if err != null {
                    return null, err
                }
                if f.Type.Type == ast.VariableTypeFunction && d.MethodAccessFlag&cg.AccMethodVarargs != 0 {
                    if f.Type.FunctionType.ParameterList[len(f.Type.FunctionType.ParameterList)-1].Type.Type !=
                        ast.VariableTypeJavaArray {
                        panic("not a java array")
                    }
                    f.Type.FunctionType.VArgs = f.Type.FunctionType.ParameterList[len(f.Type.FunctionType.ParameterList)-1]
                    f.Type.FunctionType.VArgs.Type.isVariableArgs = true
                    f.Type.FunctionType.ParameterList = f.Type.FunctionType.ParameterList[:len(f.Type.FunctionType.ParameterList)-1]
                }
            }
            if f.Type.Type == ast.VariableTypeEnum {
                loadEnumForVariableType(f.Type)
            }
            f.accessFlags = v.accessFlags
            astClass.fields[f.name] = f
        }
        astClass.methods = make(map[string][]*ast.ClassMethod)
        for _, v := range c.methods {
            m := &ast.ClassMethod{}
            m.Function = &ast.Function{}
            m.Function.name = string(c.ConstPool[v.nameIndex].Info)
            m.Function.Type, err = jvm.Descriptor.ParseFunctionType(c.ConstPool[v.descriptorIndex].Info)
            if err != null {
                return null, err
            }
            m.Function.accessFlags = v.accessFlags
            m.Function.jvmDescriptor = string(c.ConstPool[v.descriptorIndex].Info)
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameLucyMethodDescriptor); t != null && len(t) > 0 {
                index := binary.BigEndian.Uint16(t[0].Info)
                _, err = jvm.LucyMethodSignatureParser.Decode(&m.Function.Type, c.ConstPool[index].Info)
                if err != null {
                    return null, err
                }
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameLucyDefaultParameters); t != null && len(t) > 0 {
                dp := &cg.AttributeDefaultParameters{}
                dp.fromBytes(t[0].Info)
                jvm.DefaultValueParser.Decode(c, m.Function, dp)
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameMethodParameters); t != null && len(t) > 0 {
                parseMethodParameter(c, t[0].Info, m.Function)
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameLucyReturnListNames); t != null && len(t) > 0 {
                parseReturnListNames(c, t[0].Info, m.Function)
            }
            err = loadEnumForFunction(m.Function)
            if err != null {
                return null, err
            }
            if (v.accessFlags & cg.AccMethodVarargs) != 0 {
                m.Function.Type.VArgs = m.Function.Type.ParameterList[len(m.Function.Type.ParameterList)-1]
                if m.Function.Type.VArgs.Type.Type != ast.VariableTypeJavaArray {
                    panic("variable args is not array")
                }
                m.Function.Type.VArgs.Type.isVariableArgs = true
                m.Function.Type.ParameterList = m.Function.Type.ParameterList[:len(m.Function.Type.ParameterList)-1]
            }
            if astClass.methods[m.Function.name] == null {
                astClass.methods[m.Function.name] = []*ast.ClassMethod{m}
            } else {
                astClass.methods[m.Function.name] = append(astClass.methods[m.Function.name], m)
            }
        }
        return astClass, null
    }

    fn  loadLucyEnum(c cg.Class) (ast.Enum, error) {
        e := &ast.Enum{}
        {
            nameIndex := binary.BigEndian.Uint16(c.ConstPool[c.ThisClass].Info)
            e.name = string(c.ConstPool[nameIndex].Info)
        }
        e.loadFromOutSide = true
        e.accessFlags = c.accessFlags
        for _, v := range c.fields {
            en := &ast.EnumName{}
            name := string(c.ConstPool[v.nameIndex].Info)
            en.name = name
            en.Enum = e
            constValue := v.AttributeGroupedByName[cg.AttributeNameConstValue][0] // must have this attribute
            en.value = int(binary.BigEndian.getInt(c.ConstPool[binary.BigEndian.Uint16(constValue.Info)].Info))
            e.Enums = append(e.Enums, en)
        }
        return e, null
    }

    fn  loadConst(c cg.Class, nameIndex char, t ast.Type) (value interface{}) {
        switch t.Type {
        case ast.VariableTypeBool:
            return binary.BigEndian.getInt(c.ConstPool[nameIndex].Info) != 0
        case ast.VariableTypeByte:
            fallthrough
        case ast.VariableTypeShort:
            fallthrough
        case ast.VariableTypeChar:
            fallthrough
        case ast.VariableTypeInt:
            return long(binary.BigEndian.getInt(c.ConstPool[nameIndex].Info))
        case ast.VariableTypeLong:
            return long(binary.BigEndian.Uint64(c.ConstPool[nameIndex].Info))
        case ast.VariableTypeFloat:
            return float(binary.BigEndian.getInt(c.ConstPool[nameIndex].Info))
        case ast.VariableTypeDouble:
            return double(binary.BigEndian.Uint64(c.ConstPool[nameIndex].Info))
        case ast.VariableTypeString:
            valueIndex := binary.BigEndian.Uint16(c.ConstPool[nameIndex].Info)
            return string(c.ConstPool[valueIndex].Info)
        }
        return null
    }

    fn  loadLucyMainClass(pack *ast.Package, c cg.Class) error {
        var err error
        mainClassName := &cg.ClassHighLevel{}
        mainClassName.name = pack.name + "/main"
        pack.Block.Variables = make(map[string]ast.Variable)
        pack.Block.constants = make(map[string]*ast.Constant)
        pack.Block.Functions = make(map[string]ast.Function)
        for _, f := range c.fields {
            name := string(c.ConstPool[f.nameIndex].Info)
            constValue := f.AttributeGroupedByName.GetByName(cg.AttributeNameConstValue)
            if len(constValue) > 1 {
                return new error(sprintf("constant value length greater than  1 at class 'main'  field '%s'", name)
            }
            _, typ, err := jvm.Descriptor.ParseType(c.ConstPool[f.descriptorIndex].Info)
            if err != null {
                return err
            }
            if len(f.AttributeGroupedByName.GetByName(cg.AttributeNameLucyConst)) > 0 {
                //const
                constant := &ast.Constant{}
                constant.name = name
                constant.accessFlags = f.accessFlags
                constant.Type = typ
                _, constant.Type, err = jvm.Descriptor.ParseType(c.ConstPool[f.descriptorIndex].Info)
                if err != null {
                    return err
                }
                valueIndex := binary.BigEndian.Uint16(constValue[0].Info)
                constant.value = this.loadConst(c, valueIndex, constant.Type)
                pack.Block.constants[name] = constant
            } else {
                //global vars
                vd := &ast.Variable{}
                vd.name = name
                vd.accessFlags = f.accessFlags
                vd.jvmDescriptor = string(c.ConstPool[f.descriptorIndex].Info)
                vd.Type = typ
                vd.isGlobal = true
                pack.Block.Variables[name] = vd
                if t := f.AttributeGroupedByName.GetByName(cg.AttributeNameLucyFieldDescriptor); t != null && len(t) > 0 {
                    d := &cg.AttributeLucyFieldDescriptor{}
                    d.FromBs(c, t[0].Info)
                    _, vd.Type, err = jvm.LucyFieldSignature.Decode([]byte(d.Descriptor))
                    if err != null {
                        return err
                    }
                    if vd.Type.Type == ast.VariableTypeFunction && d.MethodAccessFlag&cg.AccMethodVarargs != 0 {
                        if vd.Type.FunctionType.ParameterList[len(vd.Type.FunctionType.ParameterList)-1].Type.Type !=
                            ast.VariableTypeJavaArray {
                            panic("not a java array")
                        }
                        vd.Type.FunctionType.VArgs =
                            vd.Type.FunctionType.ParameterList[len(vd.Type.FunctionType.ParameterList)-1]
                        vd.Type.FunctionType.VArgs.Type.isVariableArgs = true
                        vd.Type.FunctionType.ParameterList =
                            vd.Type.FunctionType.ParameterList[:len(vd.Type.FunctionType.ParameterList)-1]
                    }
                }
                if typ.Type == ast.VariableTypeEnum {
                    loadEnumForVariableType(typ)
                }
            }
        }

        for _, m := range c.methods {
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameLucyTriggerPackageInit); t != null && len(t) > 0 {
                pack.triggerPackageInitMethodName = string(c.ConstPool[m.nameIndex].Info)
                continue
            }
            name := string(c.ConstPool[m.nameIndex].Info)
            if name == ast.MainFunctionName {
                // this is main function
                continue
            }
            function := &ast.Function{}
            function.name = name
            function.accessFlags = m.accessFlags
            function.jvmDescriptor = string(c.ConstPool[m.descriptorIndex].Info)
            function.Type, err = jvm.Descriptor.ParseFunctionType(c.ConstPool[m.descriptorIndex].Info)
            if err != null {
                return err
            }
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameLucyMethodDescriptor); t != null && len(t) > 0 {
                index := binary.BigEndian.Uint16(t[0].Info)
                _, err = jvm.LucyMethodSignatureParser.Decode(&function.Type, c.ConstPool[index].Info)
                if err != null {
                    return err
                }
            }
            err = loadEnumForFunction(function)
            if err != null {
                return err
            }
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameMethodParameters); t != null && len(t) > 0 {
                parseMethodParameter(c, t[0].Info, function)
            }
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameLucyReturnListNames); t != null && len(t) > 0 {
                parseReturnListNames(c, t[0].Info, function)
            }
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameLucyDefaultParameters); t != null && len(t) > 0 {
                dp := &cg.AttributeDefaultParameters{}
                dp.fromBytes(t[0].Info)
                jvm.DefaultValueParser.Decode(c, function, dp)
            }

            if (function.accessFlags & cg.AccMethodVarargs) != 0 {
                function.Type.VArgs = function.Type.ParameterList[len(function.Type.ParameterList)-1]
                if function.Type.VArgs.Type.Type != ast.VariableTypeJavaArray {
                    panic("variable args is not array")
                }
                function.Type.VArgs.Type.isVariableArgs = true
                function.Type.ParameterList = function.Type.ParameterList[:len(function.Type.ParameterList)-1]
            }

            function.Entrance = &cg.MethodHighLevel{}
            function.Entrance.name = function.name
            function.Entrance.Class = mainClassName
            function.Entrance.Descriptor = function.jvmDescriptor
            function.isGlobal = true
            pack.Block.Functions[name] = function
        }

        if pack.Block.TypeAliases == null {
            pack.Block.TypeAliases = make(map[string]ast.Type)
        }
        for _, v := range c.AttributeGroupedByName.GetByName(cg.AttributeNameLucyTypeAlias) {
            attr := &cg.AttributeLucyTypeAlias{}
            attr.FromBs(c, v.Info)
            name, typ, err := jvm.LucyTypeAliasParser.Decode([]byte(attr.alias))
            if err != null {
                return err
            }
            alias := &ast.TypeAlias{
                name:    name,
                Comment: attr.comment,
            }
            typ.alias = alias
            pack.Block.TypeAliases[name] = typ
            if typ.Type == ast.VariableTypeEnum {
                err = loadEnumForVariableType(typ)
                if err != null {
                    return err
                }
            }
        }
        for _, v := range c.AttributeGroupedByName.GetByName(cg.AttributeNameLucyTemplateFunction) {
            attr := &cg.AttributeTemplateFunction{}
            attr.fromBytes(c, v.Info)
            f, es := ast.ParseFunctionHandler([]byte(attr.code), &ast.Pos{
                filename: attr.filename,
                line:     int(attr.startLine),
                column:   int(attr.startColumn),
            })
            if len(es) > 0 { // looks impossible
                return es[0]
            }
            f.accessFlags = attr.accessFlags
            f.TemplateFunction = &ast.TemplateFunction{}
            pack.Block.Functions[attr.name] = f
        }
        return null
    }

    fn  loadLucyPackage(r *Resource) (*ast.Package, error) {
        fis, err := ioutil.ReadDir(r.realPath)
        if err != null {
            return null, err
        }
        fisM := make(map[string]os.FileInfo)
        for _, v := range fis {
            if strings.HasSuffix(v.name(), ".class") {
                fisM[v.name()] = v
            }
        }

        _, ok := fisM[mainClassName]
        if ok == false {
            return null, new error(sprintf("main class not found")
        }
        bs, err := ioutil.ReadFile(filepath.Join(r.realPath, mainClassName))
        if err != null {
            return null, new error(sprintf("read main.class failed,err:%v", err)
        }
        c, err := (&ClassDecoder{}).decode(bs)
        if err != null {
            return null, new error(sprintf("decode main class failed,err:%v", err)
        }
        p := &ast.Package{}
        p.name = r.name
        err = this.loadLucyMainClass(p, c)
        if err != null {
            return null, new error(sprintf("parse main class failed,err:%v", err)
        }

        delete(fisM, mainClassName)
        mkEnums := func(e ast.Enum) {
            if p.block.Enums == null {
                p.block.Enums = make(map[string]ast.Enum)
            }
            if p.block.EnumNames == null {
                p.block.EnumNames = make(map[string]ast.EnumName)
            }
            p.block.Enums[filepath.Base(e.name)] = e
            for _, v := range e.Enums {
                p.block.EnumNames[v.name] = v
            }
        }
        for _, v := range fisM {
            bs, err := ioutil.ReadFile(filepath.Join(r.realPath, v.name()))
            if err != null {
                return p, new error(sprintf("read class failed,err:%v", err)
            }
            c, err := (&ClassDecoder{}).decode(bs)
            if err != null {
                return null, new error(sprintf("decode class failed,err:%v", err)
            }
            if len(c.AttributeGroupedByName.GetByName(cg.AttributeNameLucyEnum)) > 0 {
                e, err := this.loadLucyEnum(c)
                if err != null {
                    return null, err
                }
                mkEnums(e)
                continue
            }
            class, err := this.loadAsLucy(c)
            if err != null {
                return null, new error(sprintf("decode class failed,err:%v", err)
            }
            if class != null {
                if p.block.Classes == null {
                    p.block.Classes = make(map[string]ast.Class)
                }
                p.block.Classes[filepath.Base(ast.TypeName)] = class
            }
        }
        return p, null
    }

    fn  loadJavaPackage(r *Resource) (*ast.Package, error) {
        fis, err := ioutil.ReadDir(r.realPath)
        if err != null {
            return null, err
        }
        ret := &ast.Package{}
        ret.Block.Classes = make(map[string]ast.Class)
        for _, v := range fis {
            if strings.HasSuffix(v.name(), ".class") == false {
                continue
            }
            bs, err := ioutil.ReadFile(filepath.Join(r.realPath, v.name()))
            if err != null {
                return null, err
            }
            c, err := (&ClassDecoder{}).decode(bs)
            class, err := this.loadAsJava(c)
            if err != null {
                return null, err
            }
            if class != null {
                if ret.Block.Classes == null {
                    ret.Block.Classes = make(map[string]ast.Class)
                }
                ret.Block.Classes[filepath.Base(ast.TypeName)] = class
            }

        }
        return ret, null
    }

    fn  loadClass(r *Resource) (interface{}, error) {
        bs, err := ioutil.ReadFile(r.realPath)
        if err != null {
            return null, err
        }
        c, err := (&ClassDecoder{}).decode(bs)
        if r.kind == resourceKindLucyClass {
            if t := c.AttributeGroupedByName[cg.AttributeNameLucyEnum]; len(t) > 0 {
                return this.loadLucyEnum(c)
            } else {
                return this.loadAsLucy(c)
            }
        }
        return this.loadAsJava(c)
    }






}

