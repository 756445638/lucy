
import "lucy/cmd/langtools/compile/jvm/cg"
import "lucy/cmd/langtools/compile/jvm"
import "lucy/cmd/langtools/compile/ast"
import "java/lang/Object"
import "lucy/binary"
import "java/io"
import "lucy/os"




/*
	load from file implementation
*/
class FileLoader implements ast.LoadImport{
	caches map { string -> Object }
    fn  LoadImport(importName string) -> (x Object,err error) {
        defer {
            e := catch()
            if err == null && e != null{
                err =  e
            }
        }
        if this.caches != null && this.caches[importName] != null {
            return this.caches[importName], null
        }
        realPaths  := []Resource{}
        for _, v := range compiler.lucyPaths {
            if  p := v + "/class/" + importName ; new io.File(p ).isDirectory() { // directory is package
                realPaths.append(new Resource(
                    resourceKindLucyPackage,
                    p,
                    importName
                ))
            }
            if  p :=v + "/class/" + importName + ".class" ;  new io.File(p).isFile(){ // class file
                realPaths.append(new Resource(
                    resourceKindLucyClass,
                    p,
                    importName
                ))
            }
        }

        for _, v := range compiler.ClassPaths {
            if p :=v + "/class/" + importName  ; new io.File(p).isDirectory() { // directory is package
                realPaths.append(new Resource(
                    resourceKindJavaPackage,
                    p,
                    importName
                ))
            }
            if p := v + "/class/" + importName + ".class" ; new io.File(p).isFile() { // directory is package
                realPaths.append(new Resource(
                   resourceKindJavaClass,
                   p,
                   importName
                ))
            }
        }
        if len(realPaths) == 0 {
            return null, new error(sprintf("resource '%v' not found", importName))
        }
        realPathMap := new map { string -> []Resource } ()
        for _, v := range realPaths {
            if realPathMap.keyExist(v.realPath) {
                realPathMap[v.realPath].append( v)
            } else {
                realPathMap[v.realPath] = []Resource{v}
            }
        }
        if len(realPathMap) > 1 {
            errMsg := "not 1 resource named '" + importName + "' present:\n"
            for _, v := range realPathMap {
                switch v[0].kind {
                case resourceKindJavaClass:
                    errMsg += sprintf("\t in '%s' is a java class\n", v[0].realPath)
                case resourceKindJavaPackage:
                    errMsg += sprintf("\t in '%s' is a java package\n", v[0].realPath)
                case resourceKindLucyClass:
                    errMsg += sprintf("\t in '%s' is a lucy class\n", v[0].realPath)
                case resourceKindLucyPackage:
                    errMsg += sprintf("\t in '%s' is a lucy package\n", v[0].realPath)
                }
            }
            return null, new error(sprintf(errMsg))
        }
        if realPaths[0].kind == resourceKindLucyClass {
            if filepath.Base(realPaths[0].realPath) == mainClassName {
                return null, new error(sprintf("%s is special class for global variable and other things", mainClassName))
            }
        }
        if realPaths[0].kind == resourceKindJavaClass {
            c := this.loadClass(realPaths[0])
            if c != null {
                this.caches[importName] = c
            }
            return c, null
        } else if realPaths[0].kind == resourceKindLucyClass {
            t := this.loadClass(realPaths[0])
            if t != null {
                this.caches[importName] = t
            }
            return t, null
        } else if realPaths[0].kind == resourceKindJavaPackage {
            p, err := this.loadJavaPackage(realPaths[0])
            if p != null {
                this.caches[importName] = p
            }
            return p, null
        } else { // lucy package
            p, err := this.loadLucyPackage(realPaths[0])
            if p != null {
                this.caches[importName] = p
            }
            return p, null
        }
    }

    /*
        lucy and java have no difference
    */
    fn  loadInterfaces(astClass ast.Class, c cg.Class) -> (err error) {
        astClass.interfaces = new []ast.Class(len(c.interfaces))
        for k, v := range c.interfaces {
            i := new ast.Class()
            i.name = string(c.ConstPool[binary.BigEndian.getChar(c.ConstPool[v].Info)].Info)
            i.notImportedYet = true
            astClass.interfaces[k] = i
        }
        return null
    }

    fn  loadAsJava(c cg.Class) -> (astClass ast.Class,err error) {
        if c.isSynthetic() {
            return null, null
        }
        if c.isInnerClass() {
            return null, null
        }
        //name
        if t := c.AttributeGroupedByName.GetByName(cg.AttributeNameSignature); t != null && len(t) > 0 {
            //TODO:: support signature???
        }
        astClass = new ast.Class()
        {
            nameIndex := binary.BigEndian.getChar(c.ConstPool[c.ThisClass].Info)
            astClass.name = string(c.ConstPool[nameIndex].Info)
            if astClass.name != ast.JavaRootClass {
                nameIndex = binary.BigEndian.getChar(c.ConstPool[c.superClass].Info)
                astClass.superClassName = new ast.NameWithPos(string(c.ConstPool[nameIndex].Info) , null)
            }
        }
        this.loadInterfaces(astClass, c)
        astClass.accessFlags = c.accessFlags
        astClass.isJava = true // class compiled from java
        var err error
        astClass.fields = new map{string -> ast.ClassField } ()
        astClass.loadFromOutSide = true
        for _, v := range c.fields {
            f := new ast.ClassField()
            f.accessFlags = v.accessFlags
            f.jvmDescriptor = string(c.ConstPool[v.descriptorIndex].Info)
            f.name = string(c.ConstPool[v.nameIndex].Info)
            _, f.Type, err = jvm.Descriptor.ParseType(c.ConstPool[v.descriptorIndex].Info)
            if err != null {
                return null, err
            }
            astClass.fields[f.name] = f
        }
        astClass.methods = new map { string -> []ast.ClassMethod } ()
        for _, v := range c.methods {
            m := new ast.ClassMethod()
            m.Function = new ast.Function()
            //m.loadFromOutSide = true
            m.Function.name = string(c.ConstPool[v.nameIndex].Info)
            m.Function.jvmDescriptor = string(c.ConstPool[v.descriptorIndex].Info)
            m.Function.accessFlags = v.accessFlags
            m.Function.Type, err = jvm.Descriptor.ParseFunctionType(c.ConstPool[v.descriptorIndex].Info)
            if err != null {
                return null, err
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameMethodParameters); t != null && len(t) > 0 {
                parseMethodParameter(c, t[0].Info, m.Function)
            }
            if (v.accessFlags & cg.AccMethodVarargs) != 0 {
                m.Function.Type.VArgs = m.Function.Type.ParameterList[len(m.Function.Type.ParameterList)-1]
                if m.Function.Type.VArgs.Type.Type != ast.VariableTypeJavaArray {
                    panic("variable args is not array")
                }
                m.Function.Type.VArgs.Type.isVariableArgs = true
                m.Function.Type.ParameterList = m.Function.Type.ParameterList[:len(m.Function.Type.ParameterList)-1]
            }
            if astClass.methods[m.Function.name] == null {
                astClass.methods[m.Function.name] = []ast.ClassMethod{m}
            } else {
                astClass.methods[m.Function.name].append(m)
            }
        }
        return astClass, null
    }

    fn  loadAsLucy(c cg.Class) -> (astClass ast.Class) {
        if c.isSynthetic() {
            return null
        }
        if c.isInnerClass() {
            return null
        }
        //name
        astClass = new ast.Class()
        {
            nameIndex := binary.BigEndian.getChar(c.ConstPool[c.ThisClass].Info)
            astClass.name = string(c.ConstPool[nameIndex].Info)
            if astClass.name != ast.JavaRootClass {
                nameIndex = binary.BigEndian.getChar(c.ConstPool[c.superClass].Info)
                astClass.superClassName = new ast.NameWithPos(string(c.ConstPool[nameIndex].Info) , null)
            }
        }
        this.loadInterfaces(astClass, c)
        astClass.accessFlags = c.accessFlags
        astClass.loadFromOutSide = true
        astClass.fields = new map{string -> ast.ClassField}()
        if t := c.AttributeGroupedByName.GetByName(cg.AttributeNameLucyClassConst); len(t) > 0 {
            attr := new cg.AttributeLucyClassConst()
            attr.FromBs(c, t[0].Info)
            var t ast.Type
            var err error
            for _, v := range attr.constants {
                _, t, err = jvm.LucyFieldSignature.Decode([]byte(v.Descriptor))
                if err != null {
                    return null, err
                }
                constant := new ast.Constant()
                constant.name = v.name
                constant.Type = t
                constant.value = this.loadConst(c, v.valueIndex, t)
                if astClass.block.constants == null {
                    astClass.block.constants = new map { string -> ast.Constant } ()
                }
                astClass.block.constants[v.name] = constant
            }
        }
        for _, v := range c.fields {
            f := new ast.ClassField()
            f.name = string(c.ConstPool[v.nameIndex].Info)
            f.jvmDescriptor = string(c.ConstPool[v.descriptorIndex].Info)
            _, f.Type, err = jvm.Descriptor.ParseType(c.ConstPool[v.descriptorIndex].Info)
            if err != null {
                return null, err
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameLucyFieldDescriptor); t != null && len(t) > 0 {
                d := new cg.AttributeLucyFieldDescriptor()
                d.FromBs(c, t[0].Info)
                _, f.Type, err = jvm.LucyFieldSignature.Decode([]byte(d.Descriptor))
                if err != null {
                    return null, err
                }
                if f.Type.Type == ast.VariableTypeFunction && d.MethodAccessFlag&cg.AccMethodVarargs != 0 {
                    if f.Type.FunctionType.ParameterList[len(f.Type.FunctionType.ParameterList)-1].Type.Type !=
                        ast.VariableTypeJavaArray {
                        panic("not a java array")
                    }
                    f.Type.FunctionType.VArgs = f.Type.FunctionType.ParameterList[len(f.Type.FunctionType.ParameterList)-1]
                    f.Type.FunctionType.VArgs.Type.isVariableArgs = true
                    f.Type.FunctionType.ParameterList = f.Type.FunctionType.ParameterList[:len(f.Type.FunctionType.ParameterList)-1]
                }
            }
            if f.Type.Type == ast.VariableTypeEnum {
                loadEnumForVariableType(f.Type)
            }
            f.accessFlags = v.accessFlags
            astClass.fields[f.name] = f
        }
        astClass.methods = new map{string->[]ast.ClassMethod}()
        for _, v := range c.methods {
            m := new ast.ClassMethod()
            m.Function = new ast.Function()
            m.Function.name = string(c.ConstPool[v.nameIndex].Info)
            m.Function.Type, err = jvm.Descriptor.ParseFunctionType(c.ConstPool[v.descriptorIndex].Info)
            if err != null {
                return null, err
            }
            m.Function.accessFlags = v.accessFlags
            m.Function.jvmDescriptor = string(c.ConstPool[v.descriptorIndex].Info)
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameLucyMethodDescriptor); t != null && len(t) > 0 {
                index := binary.BigEndian.getChar(t[0].Info)
                _, err = jvm.LucyMethodSignature.Decode(m.Function.Type, c.ConstPool[index].Info)
                if err != null {
                    return null, err
                }
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameLucyDefaultParameters); t != null && len(t) > 0 {
                dp := new cg.AttributeDefaultParameters()
                dp.fromBytes(t[0].Info)
                jvm.DefaultValueParser.Decode(c, m.Function, dp)
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameMethodParameters); t != null && len(t) > 0 {
                parseMethodParameter(c, t[0].Info, m.Function)
            }
            if t := v.AttributeGroupedByName.GetByName(cg.AttributeNameLucyReturnListNames); t != null && len(t) > 0 {
                parseReturnListNames(c, t[0].Info, m.Function)
            }
            err = loadEnumForFunction(m.Function)
            if err != null {
                return null, err
            }
            if (v.accessFlags & cg.AccMethodVarargs) != 0 {
                m.Function.Type.VArgs = m.Function.Type.ParameterList[len(m.Function.Type.ParameterList)-1]
                if m.Function.Type.VArgs.Type.Type != ast.VariableTypeJavaArray {
                    panic("variable args is not array")
                }
                m.Function.Type.VArgs.Type.isVariableArgs = true
                m.Function.Type.ParameterList = m.Function.Type.ParameterList[:len(m.Function.Type.ParameterList)-1]
            }
            if astClass.methods[m.Function.name] == null {
                astClass.methods[m.Function.name] = []ast.ClassMethod{m}
            } else {
                astClass.methods[m.Function.name] = append(astClass.methods[m.Function.name], m)
            }
        }
        return astClass, null
    }

    fn  loadLucyEnum(c cg.Class) -> (e ast.Enum,err error) {
        e = new ast.Enum()
        {
            nameIndex := binary.BigEndian.getChar(c.ConstPool[c.ThisClass].Info)
            e.name = string(c.ConstPool[nameIndex].Info)
        }
        e.loadFromOutSide = true
        e.accessFlags = c.accessFlags
        for _, v := range c.fields {
            en := new ast.EnumName()
            name := string(c.ConstPool[v.nameIndex].Info)
            en.name = name
            en.Enum = e
            constValue := v.AttributeGroupedByName[cg.AttributeNameConstValue][0] // must have this attribute
            en.value = int(binary.BigEndian.getInt(c.ConstPool[binary.BigEndian.getChar(constValue.Info)].Info))
            e.Enums.append(en)
        }
        return e, null
    }

    fn  loadConst(c cg.Class, nameIndex char, t ast.Type) -> (boolValue bool, longValue long , doubleValue double , stringValue string) {
        switch t.Type {
        case ast.VariableTypeBool:
            boolValue =  binary.BigEndian.getInt(c.ConstPool[nameIndex].Info) != 0
            return
        case ast.VariableTypeByte ,ast.VariableTypeShort ,ast.VariableTypeChar,ast.VariableTypeInt:
            longValue =  long(binary.BigEndian.getInt(c.ConstPool[nameIndex].Info))
            return
        case ast.VariableTypeLong:
            longValue = long(binary.BigEndian.getLong(c.ConstPool[nameIndex].Info))
            return
        case ast.VariableTypeFloat ,ast.VariableTypeDouble:
            doubleValue =  double(binary.BigEndian.getLong(c.ConstPool[nameIndex].Info))
            return
        case ast.VariableTypeString:
            valueIndex := binary.BigEndian.getChar(c.ConstPool[nameIndex].Info)
            stringValue = string(c.ConstPool[valueIndex].Info)
            return
        }
    }

    fn  loadLucyMainClass(pack ast.Package, c cg.Class)  {
        mainClassName := new cg.ClassHighLevel()
        mainClassName.name = pack.name + "/main"
        pack.block.Variables = new map{string->ast.Variable}()
        pack.block.constants = new map{string->ast.Constant}()
        pack.block.Functions = new map{string->ast.Function}()
        for _, f := range c.fields {
            name := string(c.ConstPool[f.nameIndex].Info)
            constValue := f.AttributeGroupedByName.GetByName(cg.AttributeNameConstValue)
            if len(constValue) > 1 {
                return new error(sprintf("constant value length greater than  1 at class 'main'  field '%s'", name))
            }
            _, typ, err := jvm.Descriptor.ParseType(c.ConstPool[f.descriptorIndex].Info)
            if err != null {
                return err
            }
            if len(f.AttributeGroupedByName.GetByName(cg.AttributeNameLucyConst)) > 0 {
                //const
                constant := new ast.Constant()
                constant.name = name
                constant.accessFlags = f.accessFlags
                constant.Type = typ
                _, constant.Type, err = jvm.Descriptor.ParseType(c.ConstPool[f.descriptorIndex].Info)
                if err != null {
                    return err
                }
                valueIndex := binary.BigEndian.getChar(constValue[0].Info)
                constant.value = this.loadConst(c, valueIndex, constant.Type)
                pack.Block.constants[name] = constant
            } else {
                //global vars
                vd := new ast.Variable()
                vd.name = name
                vd.accessFlags = f.accessFlags
                vd.jvmDescriptor = string(c.ConstPool[f.descriptorIndex].Info)
                vd.Type = typ
                vd.isGlobal = true
                pack.Block.Variables[name] = vd
                if t := f.AttributeGroupedByName.GetByName(cg.AttributeNameLucyFieldDescriptor); t != null && len(t) > 0 {
                    d := new cg.AttributeLucyFieldDescriptor()
                    d.FromBs(c, t[0].Info)
                    _, vd.Type, err = jvm.LucyFieldSignature.Decode([]byte(d.Descriptor))
                    if err != null {
                        return err
                    }
                    if vd.Type.Type == ast.VariableTypeFunction && d.MethodAccessFlag&cg.AccMethodVarargs != 0 {
                        if vd.Type.functionType.ParameterList[len(vd.Type.functionType.ParameterList)-1].Type.Type !=
                            ast.VariableTypeJavaArray {
                            panic("not a java array")
                        }
                        vd.Type.functionType.VArgs =
                            vd.Type.functionType.ParameterList[len(vd.Type.functionType.ParameterList)-1]
                        vd.Type.functionType.VArgs.Type.isVariableArgs = true
                        vd.Type.functionType.ParameterList =
                            vd.Type.functionType.ParameterList[:len(vd.Type.functionType.ParameterList)-1]
                    }
                }
                if typ.Type == ast.VariableTypeEnum {
                    loadEnumForVariableType(typ)
                }
            }
        }

        for _, m := range c.methods {
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameLucyTriggerPackageInit); t != null && len(t) > 0 {
                pack.triggerPackageInitMethodName = string(c.ConstPool[m.nameIndex].Info)
                continue
            }
            name := string(c.ConstPool[m.nameIndex].Info)
            if name == ast.MainFunctionName {
                // this is main function
                continue
            }
            function := new ast.Function()
            function.name = name
            function.accessFlags = m.accessFlags
            function.jvmDescriptor = string(c.ConstPool[m.descriptorIndex].Info)
            function.Type, err = jvm.Descriptor.ParseFunctionType(c.ConstPool[m.descriptorIndex].Info)
            if err != null {
                return err
            }
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameLucyMethodDescriptor); t != null && len(t) > 0 {
                index := binary.BigEndian.getChar(t[0].Info)
                _, err = jvm.LucyMethodSignature.Decode(function.Type, c.ConstPool[index].Info)
                if err != null {
                    return err
                }
            }
            err = loadEnumForFunction(function)
            if err != null {
                return err
            }
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameMethodParameters); t != null && len(t) > 0 {
                parseMethodParameter(c, t[0].Info, function)
            }
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameLucyReturnListNames); t != null && len(t) > 0 {
                parseReturnListNames(c, t[0].Info, function)
            }
            if t := m.AttributeGroupedByName.GetByName(cg.AttributeNameLucyDefaultParameters); t != null && len(t) > 0 {
                dp := new cg.AttributeDefaultParameters()
                dp.fromBytes(t[0].Info)
                jvm.DefaultValueParser.Decode(c, function, dp)
            }

            if (function.accessFlags & cg.AccMethodVarargs) != 0 {
                function.Type.VArgs = function.Type.ParameterList[len(function.Type.ParameterList)-1]
                if function.Type.VArgs.Type.Type != ast.VariableTypeJavaArray {
                    panic("variable args is not array")
                }
                function.Type.VArgs.Type.isVariableArgs = true
                function.Type.ParameterList = function.Type.ParameterList[:len(function.Type.ParameterList)-1]
            }

            function.entrance = new cg.MethodHighLevel()
            function.entrance.name = function.name
            function.entrance.Class = mainClassName
            function.entrance.Descriptor = function.jvmDescriptor
            function.isGlobal = true
            pack.Block.Functions[name] = function
        }

        if pack.Block.TypeAliases == null {
            pack.Block.TypeAliases = new map{string->ast.Type}()
        }
        for _, v := range c.AttributeGroupedByName.GetByName(cg.AttributeNameLucyTypeAlias) {
            attr := new cg.AttributeLucyTypeAlias()
            attr.FromBs(c, v.Info)
            name, typ, err := jvm.LucyTypeAliasParser.Decode([]byte(attr.alias))
            if err != null {
                return err
            }
            alias := new ast.TypeAlias()
            alias.name = name
            alias.Comment = attr.comment
            typ.alias = alias
            pack.Block.TypeAliases[name] = typ
            if typ.Type == ast.VariableTypeEnum {
                err = loadEnumForVariableType(typ)
                if err != null {
                    return err
                }
            }
        }
        for _, v := range c.AttributeGroupedByName.GetByName(cg.AttributeNameLucyTemplateFunction) {
            attr := new cg.AttributeTemplateFunction()
            attr.fromBytes(c, v.Info)
            pos := new ast.Pos()
            pos.filename = attr.filename
            pos.line = int(attr.startLine)
            pos.column = int(attr.startColumn)
            f, es := ast.ParseFunctionHandler([]byte(attr.code),pos)
            if len(es) > 0 { // looks impossible
                return es[0]
            }
            f.accessFlags = attr.accessFlags
            f.TemplateFunction = new ast.TemplateFunction()
            pack.Block.Functions[attr.name] = f
        }
        return null
    }

    fn  loadLucyPackage(r Resource) -> (p ast.Package, err error) {
        fis, err := ioutil.ReadDir(r.realPath)
        if err != null {
            return null, err
        }
        fisM := new map { string -> os.FileInfo } ()
        for _, v := range fis {
            if strings.HasSuffix(v.name(), ".class") {
                fisM[v.name()] = v
            }
        }

        _, ok := fisM[mainClassName]
        if ok == false {
            return null, new error(sprintf("main class not found"))
        }
        bs, err := ioutil.ReadFile(filepath.Join(r.realPath, mainClassName))
        if err != null {
            return null, new error(sprintf("read main.class failed,err:%v", err))
        }
        c, err := (new ClassDecoder()).decode(bs)
        if err != null {
            return null, new error(sprintf("decode main class failed,err:%v", err))
        }
        p = new ast.Package()
        p.name = r.name
        err = this.loadLucyMainClass(p, c)
        if err != null {
            return null, new error(sprintf("parse main class failed,err:%v", err))
        }
        delete(fisM, mainClassName)
        mkEnums := fn(e ast.Enum) {
            if p.block.Enums == null {
                p.block.Enums = new map { string -> ast.Enum } ()
            }
            if p.block.EnumNames == null {
                p.block.EnumNames = new map { string -> ast.EnumName } ()
            }
            p.block.Enums[filepath.Base(e.name)] = e
            for _, v := range e.Enums {
                p.block.EnumNames[v.name] = v
            }
        }
        for _, v := range fisM {
            b := ioutil.ReadFile(filepath.Join(r.realPath, v.name()))
            c := (new ClassDecoder(bs)).decode()
            if len(c.AttributeGroupedByName.GetByName(cg.AttributeNameLucyEnum)) > 0 {
                e, err := this.loadLucyEnum(c)
                if err != null {
                    return null, err
                }
                mkEnums(e)
                continue
            }
            c := this.loadAsLucy(c)
            if c != null {
                if p.block.Classes == null {
                    p.block.Classes = new map {string -> ast.Class } ()
                }
                p.block.Classes[filepath.Base(ast.TypeName)] = c
            }
        }
        return p, null
    }

    fn  loadJavaPackage(r Resource) -> (p ast.Package) {
        fis := new io.File(r.realPath).list()
        p = new ast.Package()
        p.block.Classes = new map {string -> ast.Class}()
        for _, v := range fis {
            if v.endsWith(".class") == false {
                continue
            }
            bs := os.readFile(r.realPath + "/" + v)
            c  := (new ClassDecoder(javaArray2Lucy(new []byte(bs.size())) , bs)).decode()
            cc := this.loadAsJava(c)
            if cc != null {
                if p.Block.Classes == null {
                    p.Block.Classes = new map{string->ast.Class}()
                }
                p.Block.Classes[filepath.Base(ast.TypeName)] = cc
            }

        }
    }

    fn  loadClass(r Resource) -> (cc ast.Class) {
        bs, err := os.readFile(r.realPath)
        if err != null {
            return null, err
        }
        c := (new ClassDecoder()).decode(javaArray2Lucy(new []byte(bs.size()),bs))
        if r.kind == resourceKindLucyClass {
            if t := c.AttributeGroupedByName[cg.AttributeNameLucyEnum]; len(t) > 0 {
                return this.loadLucyEnum(c)
            } else {
                return this.loadAsLucy(c)
            }
        }
        return this.loadAsJava(c)
    }






}

