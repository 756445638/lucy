
// import "lucy/cmd/langtools/compile/jvm/cg"
// import "lucy/binary"
  

// public class ClassDecoder {
// 	bs        []byte ;
// 	classFile cg.Class ;
	
// 	fn ClassDecoder(bs []byte){
// 		this.super()
// 		this.bs = bs 
// 		this.classFile = new cg.Class()
// 	}
	
// 	fn decode() -> (c cg.Class) {
// 		if binary.BigEndian.getInt(this.bs) != cg.ClassMagicNumber {
// 			panic("magic number is not right")
// 		}
// 		this.bs = this.bs[4:]
// 		//version
// 		this.classFile.minorVersion = binary.BigEndian.getChar(this.bs)
// 		this.classFile.majorVersion = binary.BigEndian.getChar(this.bs[2:])
// 		this.bs = this.bs[4:] ;
// 		this.classFile.constPools = []cg.ConstPool{null} // pool start 1
// 		//const pool
// 		this.parseConstPool()
// 		//access flag
// 		this.classFile.accessFlags = binary.BigEndian.getChar(this.bs) //11
// 		this.bs = this.bs[2:]
// 		// this class
// 		this.classFile.thisClass = binary.BigEndian.getChar(this.bs)
// 		this.classFile.superClass = binary.BigEndian.getChar(this.bs[2:])
// 		this.bs = this.bs[4:]
// 		this.parseInterfaces()
// 		this.parseFields()
// 		this.parserMethods()
// 		this.classFile.AttributeGroupedByName = this.parseAttributes()
// 		return this.classFile
// 	}

// 	fn parseConstPool()   {
// 		length := binary.BigEndian.getChar(this.bs) - 1
// 		this.bs = this.bs[2:]
// 		for i := 0; i < int(length); i++ {
// 			switch this.bs[0] {
// 			case cg.ConstantPoolTagUtf8:
// 				p := new cg.ConstPool()
// 				length := binary.BigEndian.getChar(this.bs[1:])
// 				p.tag = this.bs[0]
// 				this.bs = this.bs[3:]
// 				p.info = this.bs[:length]
// 				this.bs = this.bs[length:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagInteger:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:5]
// 				this.bs = this.bs[5:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagFloat:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:5]
// 				this.bs = this.bs[5:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagFieldref:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:5]
// 				this.bs = this.bs[5:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagMethodref:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:5]
// 				this.bs = this.bs[5:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagInterfaceMethodref:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:5]
// 				this.bs = this.bs[5:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagNameAndType:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:5]
// 				this.bs = this.bs[5:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagInvokeDynamic:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:5]
// 				this.bs = this.bs[5:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagLong:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:9]
// 				this.bs = this.bs[9:]
// 				this.classFile.constPools.append( p, null)
// 				i++ // increment twice
// 			case cg.ConstantPoolTagDouble:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:9]
// 				this.bs = this.bs[9:]
// 				this.classFile.constPools.append( p, null)
// 				i++ // increment twice
// 			case cg.ConstantPoolTagClass:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:3]
// 				this.bs = this.bs[3:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagString:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:3]
// 				this.bs = this.bs[3:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagMethodType:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:3]
// 				this.bs = this.bs[3:]
// 				this.classFile.constPools.append( p)
// 			case cg.ConstantPoolTagMethodHandle:
// 				p := new cg.ConstPool()
// 				p.tag = this.bs[0]
// 				p.info = this.bs[1:4]
// 				this.bs = this.bs[4:]
// 				this.classFile.constPools.append( p)
// 			}
// 		}
// 	}

// 	fn parseInterfaces() {
// 		length := binary.BigEndian.getChar(this.bs)
// 		this.bs = this.bs[2:]
// 		this.classFile.interfaces = new []char(length)
// 		for i := char(0); i < length; i++ {
// 			this.classFile.interfaces[i] = binary.BigEndian.getChar(this.bs)
// 			this.bs = this.bs[2:]
// 		}
// 	}

// 	fn parseFields() {
// 		length := binary.BigEndian.getChar(this.bs)
// 		this.bs = this.bs[2:]
// 		this.classFile.fields = new []cg.FieldInfo(length)
// 		for i := char(0); i < length; i++ {
// 			f := new cg.FieldInfo()
// 			f.accessFlags = binary.BigEndian.getChar(this.bs)
// 			f.nameIndex = binary.BigEndian.getChar(this.bs[2:])
// 			f.descriptorIndex = binary.BigEndian.getChar(this.bs[4:])
// 			this.bs = this.bs[6:]
// 			f.AttributeGroupedByName = this.parseAttributes()
// 			this.classFile.fields[i] = f 
// 		}
// 	}

// 	fn parserMethods()  {
// 		length := binary.BigEndian.getChar(this.bs)
// 		this.bs = this.bs[2:]
// 		this.classFile.methods = new []cg.MethodInfo(length)
// 		for i := char(0); i < length; i++ {
// 			m := new cg.MethodInfo()
// 			m.accessFlags = binary.BigEndian.getChar(this.bs)
// 			m.nameIndex = binary.BigEndian.getChar(this.bs[2:])
// 			m.descriptorIndex = binary.BigEndian.getChar(this.bs[4:])
// 			this.bs = this.bs[6:]
// 			m.AttributeGroupedByName = this.parseAttributes()
// 			this.classFile.methods[i] = m 
// 		}
// 	}
	
// 	fn parseAttributes() -> (attrs  cg.AttributeGroupedByName) {
// 		attrs = new cg.AttributeGroupedByName()
// 		length := binary.BigEndian.getChar(this.bs)
// 		this.bs = this.bs[2:]
// 		for i := char(0); i < length; i++ {
// 			a := new cg.AttributeInfo()
// 			a.nameIndex = binary.BigEndian.getChar(this.bs)
// 			if this.classFile.constPools[a.nameIndex].tag != cg.ConstantPoolTagUtf8 {
// 				panic(sprintf("name index %d is not a utf8 const", a.nameIndex))
// 			}
// 			length := binary.BigEndian.getInt(this.bs[2:])
// 			this.bs = this.bs[6:]
// 			a.info = this.bs[:length]
// 			this.bs = this.bs[length:]
// 			name := string(this.classFile.constPools[a.nameIndex].info)
// 			if attrs.keyExist(name) {
// 				attrs[name].append(a)
// 			} else {
// 				attrs[name] = []cg.AttributeInfo{a}
// 			}
// 		}
// 	}
// }

