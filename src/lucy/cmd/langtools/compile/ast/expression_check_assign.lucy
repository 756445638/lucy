class ExpressionCheckAssign {
		
	static fn check(e Expression , block Block, errs []error) ->(valueType Type)  {
		bin := e.data.(ExpressionBinary)
		lefts := new []Expression(1)
		if bin.left.Type == ExpressionTypeList {
			lefts = bin.left.data.([]Expression)
		} else {
			lefts[0] = bin.left
		}
		values := bin.right.data.([]Expression)
		for _, v := range values {
			v.lefts = lefts
		}
        valueTypes := checkExpressions(block, values, errs, false)
		leftTypes := []Type{}
		for _, v := range lefts {
			if v.isIdentifier(UnderScore) {
				leftTypes.append(null) // this is no assign situation
			} else {
				t := v.getLeftValue(block, errs)
				leftTypes.append(t) // append even if it`s null
			}
		}
		convertExpressionsToNeeds(block , values, leftTypes, valueTypes)
		bin.left.multiValues = leftTypes
		if len(lefts) > len(valueTypes) { //expression length compare with value types is more appropriate
			pos := values[len(values)-1].pos
			errs.append(new error(sprintf("%s cannot assign %d value to %d detinations",
				pos.errMsgPrefix(),
				len(valueTypes),
				len(lefts))))
		} else if len(lefts) < len(valueTypes) {
			pos := getExtraExpressionPos(values, len(lefts))
			errs.append(new error(sprintf("%s cannot assign %d value to %d detinations",
				pos.errMsgPrefix(),
				len(valueTypes),
				len(lefts))))
		}
		
		for k, v := range leftTypes {
			if v == null { // get left value error or "_"
				continue
			}
			if k >= len(valueTypes) {
				continue
			}
			if valueTypes[k] == null {
				continue
			}
			if false == leftTypes[k].assignAble(block , errs, valueTypes[k]) {
				errs.append(new error(sprintf("%s cannot assign '%s' to '%s'",
					errMsgPrefix(valueTypes[k].pos),
					valueTypes[k].typeString(), leftTypes[k].typeString())))
			}
		}
		{
		    t := new ExpressionAssign()
		    e.data = t
		    t.lefts = lefts
            t.values = values
		}
		voidReturn := mkVoidType(e.pos)
		if len(lefts) > 1 {
			return voidReturn
		}
		if len(lefts) == 0 || leftTypes[0] == null {
			return voidReturn
		}
		if e.isStatementExpression == false {
			left := lefts[0]
			if left.Type == ExpressionTypeIdentifier {
				t := left.data.(ExpressionIdentifier)
				if t.name == UnderScore {
					return voidReturn
				} else {
					if null != t.Variable {
						t.Variable.used = true
					}
				}
			}
		}
		// here is safe
		valueType = leftTypes[0].Clone()
		valueType.pos = e.pos
	}	
} 

