import "lucy/cmd/langtools/compile/jvm/cg"

class ExpressionCheckVar {
		
	static fn check(e Expression , block Block, errs []error) {
		ev := e.data.(ExpressionVar)
		if ev.Type != null {
			if err := ev.Type.resolve(block); err != null {
				errs.append(err)
				return
			}
			if len(ev.Variables) == 1 {
				ev.Variables[0].Type = ev.Type
			} else {
				for _, v := range ev.Variables {
					v.Type = ev.Type.Clone()
				}
			}
		}
		if ev.Type == null && len(ev.InitValues) == 0 {
			// looks impossible
			errs.append(new error( sprintf("%s expression var have not type and no initValues",
					errMsgPrefix(e.pos))))
			return
		}
		var err error
		if len(ev.InitValues) > 0 {
			valueTypes := checkExpressions(block, ev.InitValues, errs, false)
			if ev.Type != null {
				needs := new []Type(len(ev.Variables))
				for k, _ := range needs {
					needs[k] = ev.Type
				}
				convertExpressionsToNeeds(ev.InitValues, needs, valueTypes)
			}
			if len(ev.Variables) > len(valueTypes) {
				pos := ev.InitValues[len(ev.InitValues)-1].pos // last Pos
				errs.append(new error( sprintf("%s too few values , assign %d values to %d destinations",
					pos.ErrMsgPrefix(),
					len(valueTypes),
					len(ev.Variables))))
			} else if len(ev.Variables) < len(valueTypes) {
				pos := getExtraExpressionPos(ev.InitValues, len(ev.Variables))
				errs.append(new error( sprintf("%s too many values , assign %d values to %d destinations",
					pos.ErrMsgPrefix(),
					len(valueTypes),
					len(ev.Variables))))
			}
			for k, v := range ev.Variables {
				if k < len(valueTypes) && valueTypes[k] != null {
					if v.Type != null {
						if v.Type.assignAble(errs, valueTypes[k]) == false {
							err = new error(sprintf("%s cannot assign  '%s' to '%s'",
								errMsgPrefix(valueTypes[k].pos),
								valueTypes[k].typeString(),
								v.Type.typeString()))
							errs.append(err)
							continue
						}
					} else {
						v.Type = valueTypes[k].Clone()
						v.Type.pos = v.pos
					}
				}
				if v.Type == null {
					continue
				}
				if e.isGlobal {
					err = PackageBeenCompile.block.Insert(v.name, v.pos, v)
				} else {
					err = block.Insert(v.name, v.pos, v)
				}
				if err != null {
					errs.append(err)
					continue
				}
			}
		} else {
			for _, v := range ev.Variables {
				var err error
				if e.isGlobal {
					err = PackageBeenCompile.block.Insert(v.name, v.pos, v)
				} else {
					err = block.Insert(v.name, v.pos, v)
				}
				if err != null {
					errs.append(err)
					continue
				}
				ev.InitValues.append(v.Type.mkDefaultValueExpression())
			}
		}
		if e.isGlobal {
			for _, v := range ev.Variables {
				v.isGlobal = true
			}
			if e.isPublic {
				for _, v := range ev.Variables {
					v.accessFlags |= cg.AccFieldPublic
				}
			}
		}

	}	
} 

