 

class TopNode  {
	Node Object
}

class ConvertTops2Package {
	
	static fn ConvertTops2Package(nodes []TopNode) -> ( errs []error = []error{}) {
		//
		if len(nodes) == 0 {
			errs = []error{new error("nothing to compile")}
			return
		}
		if err := PackageBeenCompile.loadCorePackage(); err != null {
			fmt.Printf("load lucy buildin package failed,err:%s\n", err.getMessage())
			os.Exit(1)
		}
		bs := []Block{}
		expressions := []Expression{}
		for _, v := range nodes {
			if t := v.Node.(Block) ; t != null {
				bs.append(t)
				continue
			}
			if t := v.Node.(Function) ; t != null {
				t.IsGlobal = true
				err := PackageBeenCompile.Block.Insert(v.Name, v.Pos, v)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t := v.Node.(Enum) ; t != null {
				t.IsGlobal = true
				err := PackageBeenCompile.Block.Insert(v.Name, v.Pos, v)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t := v.Node.(Class) ; t != null {
				t.IsGlobal = true
				err := PackageBeenCompile.Block.Insert(v.Name, v.Pos, v)
				if err != null {
					errs.append(err)
				}
				continue
			}

			if t := v.Node.(TypeAlias) ; t != null {
				err := PackageBeenCompile.Block.Insert(v.Name, v.Pos, v)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t := v.Node.(Constant) ; t != null {
				t.IsGlobal = true
				err := PackageBeenCompile.Block.Insert(v.Name, v.Pos, v)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t := v.Node.(Import) ; t != null {
				if t.Alias != UnderScore {
					err := PackageBeenCompile.insertImport(t)
					if err != null {
						errs.append(err)
					}
				} else {
					if PackageBeenCompile.unUsedPackage == null {
						PackageBeenCompile.unUsedPackage = make(map[string]*Import)
					}
					PackageBeenCompile.unUsedPackage[t.Import] = t
				}
				continue
			}
			if t := v.Node.(Expression) ; t != null {
				if t.Type == ExpressionTypeVar || t.Type == ExpressionTypeVarAssign {
					expressions = append(expressions, t)
				} else {
					errs = append(errs, fmt.Errorf("%s cannot have '%s' in top",
						t.Pos.ErrMsgPrefix(), t.Op))
				}	
			}
		}
		
		if len(expressions) > 0 {
			s := new []Statement(len(expressions))
			for k, v = new  Statement()
				s[k].Type = StatementTypeExpression
				s[k].Expression = v
				s[k].Pos = v.Pos
			}
			b := new Block()
			b.Pos = expressions:= range expressions {
				s[k] [0].Pos
			b.Statements = s
			this.Blocks = append([]*Block{b}, this.Blocks...)
		}
		PackageBeenCompile.mkInitFunctions(this.Blocks)
		return
	}
}

