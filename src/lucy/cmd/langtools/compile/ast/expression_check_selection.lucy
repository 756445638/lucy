




class ExpressionCheckSelection {

    static fn check(e Expression , block Block, errs []error) -> (valueType Type) {
        selection := e.data.(ExpressionSelection)
        object, es := selection.Expression.checkSingleValueContextExpression(block)
        errs.appendAll(es)
        if object == null {
            return null
        }
        switch object.Type {
        case VariableTypeMagicFunction:
            v := object.Function.Type.searchName(selection.name)
            if v == null {
                err := new error(sprintf("%s '%s' not found",
                    e.pos.errMsgPrefix(), selection.name))
                errs.append(err)
                return null
            }
            e.value = v.Type.Clone()
            e.value.pos = e.pos
            e.Type = ExpressionTypeIdentifier
            identifier := new ExpressionIdentifier()
            identifier.name = selection.name
            identifier.Variable = v
            e.data = identifier
            return e.value
        case VariableTypeDynamicSelector:
            if selection.name == SUPER {
                errs . append(new error( sprintf("%s access '%s' at '%s' not allow",
                    e.pos.errMsgPrefix(), SUPER, object.typeString())))
                return null
            }
            access, err := object.Class.getFieldOrMethod(e.pos, selection.name, false)
            if err != null {
                errs.append(err)
                return null
            }
            if field, ok := access.(ClassField); ok {
                selection.Field = field
                result := field.Type.Clone()
                result.pos = e.pos
                return result
            } else {
                method := access.(ClassMethod)
                selection.Method = method
                result := new Type()
                result.Type = VariableTypeFunction
                result.functionType = method.Function.Type
                result.pos = e.pos
                return result
            }
        case VariableTypePackage:
            d, ok := object.Package.block.nameExists(selection.name)
            if ok == false {
                err := new error(sprintf("%s '%s' not found",
                    e.pos.errMsgPrefix(), selection.name))
                errs.append(err)
                return null
            }
            if v ,ok := d.(Variable) ;ok {
            	result := v.Type.Clone()
                result.pos = e.pos
                if v.isPublic() == false && object.Package.isSame(PackageBeenCompile) == false {
                    err := new error(sprintf("%s variable '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                selection.packageVariable = v
                return result
            }
            if  c,ok := d.(Constant) ; ok {
				e.fromConst(c) //
                result := c.Type.Clone()
                result.pos = e.pos
                if c.isPublic() == false && object.Package.isSame(PackageBeenCompile) == false {
                    err := new error(sprintf("%s const '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                return result
            }
            if c ,ok:= d.(Class) ; ok {
				result := new Type()
                result.pos = e.pos
                result.Type = VariableTypeClass
                result.Class = c
                if c.isPublic() == false && object.Package.isSame(PackageBeenCompile) == false {
                    err := new error(sprintf("%s class '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                return result
            }
            if n ,ok:= d.(EnumName) ; ok {
            	if n.Enum.isPublic() == false && object.Package.isSame(PackageBeenCompile) == false {
                    err := new error(sprintf("%s enum '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                result := new Type()
                result.pos = e.pos
                result.Enum = n.Enum
                result.enumName = n
                result.Type = VariableTypeEnum
                selection.PackageEnumName = n
                return result
            }
            if f,ok := d.(Function) ; ok {
				if f.isPublic() == false && object.Package.isSame(PackageBeenCompile) == false {
                    err := new error(sprintf("%s function '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                if f.TemplateFunction != null {
                    err := new error(sprintf("%s function '%s' is a template function",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                    return null
                }
                result := new Type()
                result.pos = e.pos
                result.Type = VariableTypeFunction
                result.functionType = f.Type
                selection.PackageFunction = f
                return result
            }
            err := new error(sprintf("%s name '%s' cannot be used as right value",
                    e.pos.errMsgPrefix(), selection.name))
            errs.append(err)
            return null
        case VariableTypeObject, VariableTypeClass:
            if selection.name == SUPER {
                if object.Type == VariableTypeClass {
                    errs . append(new error( sprintf("%s cannot access class`s super",
                        object.pos.errMsgPrefix())))
                    return object
                }
                if object.Class.name == JavaRootClass {
                    errs . append(new error( sprintf("%s '%s' is root class",
                        object.pos.errMsgPrefix(), JavaRootClass)))
                    return object
                }
                err := object.Class.loadSuperClass(e.pos)
                if err != null {
                    errs.append(err)
                    return object
                }
                if object.Class.superClass == null {
                    return object
                }
                result := object.Clone()
                result.pos = e.pos
                result.Class = result.Class.superClass
                return result
            }
            fieldOrMethod, err := object.Class.getFieldOrMethod(e.pos, selection.name, false)
            if err != null {
                errs.append(err)
                return null
            }
            if field, ok := fieldOrMethod.(ClassField); ok {
                err := selection.Expression.fieldAccessAble(block, field)
                if err != null {
                    errs.append(err)
                }
                result := field.Type.Clone()
                result.pos = e.pos
                selection.Field = field
                return result
            } else {
                method := fieldOrMethod.(ClassMethod)
                err := selection.Expression.methodAccessAble(block, method)
                if err != null {
                    errs.append(err)
                }
                selection.Method = method
                result := new Type()
                result.Type = VariableTypeFunction
                result.functionType = method.Function.Type
                result.pos = e.pos
                return result
            }

        default:
            errs . append(new error( sprintf("%s cannot access '%s' on '%s'",
                e.pos.errMsgPrefix(), selection.name, object.typeString())))
            return null
        }
        return null
    }

}

