


class ExpressionCheckSelection {
    
    static fn check(e Expression , block Block, errs []error) -> (valueType Type) {
        selection := e.data.(ExpressionSelection)
        object, es := selection.Expression.checkSingleValueContextExpression(block)
        errs.appendAll(es)
        if object == null {
            return null
        }
        if selection.autoCompletion {
            ExpressionCheckSelection.autoCompletion(object , block )
            return 
        }

        switch object.Type {
        case VariableTypeDynamicSelector:
            if selection.name == SUPER {
                errs.append(new error( sprintf("%s access '%s' at '%s' not allow",
                    e.pos.errMsgPrefix(), SUPER, object.typeString())))
                return null
            }
            access, err := object.Class.getFieldOrMethod(e.pos, selection.name, false)
            if err != null {
                errs.append(err)
                return null
            }
            if field, ok := access.(ClassField); ok {
                selection.Field = field
                result := field.Type.Clone()
                result.pos = e.pos
                if selection.locateDefinition{
                    block.inheritedAttribute.p.locateDefinition = field.pos 
                }
                return result
            } else {
                method := access.(ClassMethod)
                selection.Method = method
                result := new Type()
                result.Type = VariableTypeFunction
                result.functionType = method.Function.Type
                result.pos = e.pos
                if selection.locateDefinition {
                    block.inheritedAttribute.p.locateDefinition = method.Function.pos   
                }
                return result
            }
        case VariableTypePackage:
            d, ok := object.Package.block.nameExists(selection.name , e.pos)
            if ok == false {
                err := new error(sprintf("%s '%s' not found",
                    e.pos.errMsgPrefix(), selection.name))
                errs.append(err)
                return null
            }
            if v ,ok := d.(Variable) ;ok {
            	result := v.Type.Clone()
                result.pos = e.pos
                if v.isPublic() == false && object.Package.isSame(block.inheritedAttribute.p) == false {
                    err := new error(sprintf("%s variable '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                if selection.locateDefinition {
                    if object.Package.isSame(block.inheritedAttribute.p) || object.Package.javaPackage == null  {
                        // current package 
                        block.inheritedAttribute.p.locateDefinition = v.pos
                    }else {
                        t := new Pos()
                        block.inheritedAttribute.p.locateDefinition = t
                        t.loadDefinitionFromOutside = new LoadDefinitionFromOutside()
                        t.loadDefinitionFromOutside.packageName = object.Package.name
                        t.loadDefinitionFromOutside.name = selection.name 
                        t.loadDefinitionFromOutside.javaPackage = object.Package.javaPackage 
                    }
                }
                selection.packageVariable = v
                return result
            }
            if  c,ok := d.(Constant) ; ok {
				e.fromConst(c) //
                result := c.Type.Clone()
                result.pos = e.pos
                if c.isPublic() == false && object.Package.isSame(block.inheritedAttribute.p) == false {
                    err := new error(sprintf("%s const '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                if selection.locateDefinition {
                    if object.Package.isSame(block.inheritedAttribute.p) || object.Package.javaPackage == null  {
                        // current package 
                        block.inheritedAttribute.p.locateDefinition = c.pos
                    }else {
                        t := new Pos()
                        block.inheritedAttribute.p.locateDefinition = t
                        t.loadDefinitionFromOutside = new LoadDefinitionFromOutside()
                        t.loadDefinitionFromOutside.packageName = object.Package.name
                        t.loadDefinitionFromOutside.name = selection.name 
                        t.loadDefinitionFromOutside.javaPackage = object.Package.javaPackage 
                    }
                }
                return result
            }
            if c ,ok:= d.(Class) ; ok {
				result := new Type()
                result.pos = e.pos
                result.Type = VariableTypeClass
                result.Class = c
                if c.isPublic() == false && object.Package.isSame(block.inheritedAttribute.p) == false {
                    err := new error(sprintf("%s class '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                if selection.locateDefinition || object.Package.javaPackage == null  {
                    if object.Package.isSame(block.inheritedAttribute.p) {
                        // current package 
                        block.inheritedAttribute.p.locateDefinition = c.pos
                    }else {
                        t := new Pos()
                        block.inheritedAttribute.p.locateDefinition = t
                        t.loadDefinitionFromOutside = new LoadDefinitionFromOutside()
                        t.loadDefinitionFromOutside.packageName = object.Package.name
                        t.loadDefinitionFromOutside.name = selection.name 
                        t.loadDefinitionFromOutside.javaPackage = object.Package.javaPackage 
                    }
                }
                return result
            }
            if n ,ok:= d.(EnumName) ; ok {
            	if n.Enum.isPublic() == false && object.Package.isSame(block.inheritedAttribute.p) == false {
                    err := new error(sprintf("%s enum '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                if selection.locateDefinition {
                    if object.Package.isSame(block.inheritedAttribute.p) || object.Package.javaPackage == null  {
                        // current package 
                        block.inheritedAttribute.p.locateDefinition = n.pos
                    }else {
                        t := new Pos()
                        block.inheritedAttribute.p.locateDefinition = t
                        t.loadDefinitionFromOutside = new LoadDefinitionFromOutside()
                        t.loadDefinitionFromOutside.packageName = object.Package.name
                        t.loadDefinitionFromOutside.name = selection.name 
                        t.loadDefinitionFromOutside.javaPackage = object.Package.javaPackage 
                    }
                }
                result := new Type()
                result.pos = e.pos
                result.Enum = n.Enum
                result.enumName = n
                result.Type = VariableTypeEnum
                selection.PackageEnumName = n
                return result
            }
            if f,ok := d.(Function) ; ok {
				if f.isPublic() == false && object.Package.isSame(block.inheritedAttribute.p) == false {
                    err := new error(sprintf("%s function '%s' is not public",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                if f.TemplateFunction != null {
                    err := new error(sprintf("%s function '%s' is a template function",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                    return null
                }
                if selection.name == "main" {
                    err := new error(sprintf("%s function '%s' is a a special entrance",
                        e.pos.errMsgPrefix(), selection.name))
                    errs.append(err)
                }
                if selection.locateDefinition {
                    if object.Package.isSame(block.inheritedAttribute.p) || object.Package.javaPackage == null  {
                        // current package 
                        block.inheritedAttribute.p.locateDefinition = f.pos
                    }else {
                        t := new Pos()
                        block.inheritedAttribute.p.locateDefinition = t
                        t.loadDefinitionFromOutside = new LoadDefinitionFromOutside()
                        t.loadDefinitionFromOutside.packageName = object.Package.name
                        t.loadDefinitionFromOutside.name = selection.name 
                        t.loadDefinitionFromOutside.javaPackage = object.Package.javaPackage 
                    }
                }
                result := new Type()
                result.pos = e.pos
                result.Type = VariableTypeFunction
                result.functionType = f.Type
                selection.PackageFunction = f
                return result
            }
            err := new error(sprintf("%s name '%s' cannot be used as right value",
                    e.pos.errMsgPrefix(), selection.name))
            errs.append(err)
            return null
        case VariableTypeObject, VariableTypeClass:
            if selection.name == SUPER {
                if object.Type == VariableTypeClass {
                    errs . append(new error( sprintf("%s cannot access class`s super",
                        object.pos.errMsgPrefix())))
                    return object
                }
                if object.Class.name == JavaRootClass {
                    errs . append(new error( sprintf("%s '%s' is root class",
                        object.pos.errMsgPrefix(), JavaRootClass)))
                    return object
                }
                err := object.Class.loadSuperClass(e.pos)
                if err != null {
                    errs.append(err)
                    return object
                }
                if object.Class.superClass == null {
                    return object
                }
                result := object.Clone()
                result.pos = e.pos
                result.Class = result.Class.superClass
                return result
            }
            fieldOrMethod, err := object.Class.getFieldOrMethod(e.pos, selection.name, false)
            if err != null {
                errs.append(err)
                return null
            }
            if field, ok := fieldOrMethod.(ClassField); ok {
                err := selection.Expression.fieldAccessAble(block, field)
                if err != null {
                    errs.append(err)
                }
                if selection.locateDefinition {
                    if object.Class.loadFromOutSide  == false {      
                        block.inheritedAttribute.p.locateDefinition = field.pos
                    }else {
                        //TODO :: locateDefinition
                    }
                }
                result := field.Type.Clone()
                result.pos = e.pos
                selection.Field = field
                return result
            } else {
                method := fieldOrMethod.(ClassMethod)
                err := selection.Expression.methodAccessAble(block, method)
                if err != null {
                    errs.append(err)
                }
                if selection.locateDefinition {
                    if object.Class.loadFromOutSide  == false {      
                        block.inheritedAttribute.p.locateDefinition = field.pos
                    }
                }
                selection.Method = method
                result := new Type()
                result.Type = VariableTypeFunction
                result.functionType = method.Function.Type
                result.pos = e.pos
                return result
            }
            
        default:
            errs . append(new error( sprintf("%s cannot access '%s' on '%s'",
                e.pos.errMsgPrefix(), selection.name, object.typeString())))
            return null
        }
        return null
    }
    
    static fn autoCompletion(object Type , block Block) {
        switch object.Type {
        case VariableTypeDynamicSelector:
            
        case VariableTypePackage:
            
        case VariableTypeObject:
            
        case VariableTypeClass:
            
            
        default:
            errs.append(new error( sprintf("%s cannot access '%s' on '%s'",
                e.pos.errMsgPrefix(), selection.name, object.typeString())))
            return null
        }
        return null

    }   



}

