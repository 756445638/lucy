 import "lucy/cmd/langtools/compile/common"
 

public class Import {
	public accessName  string
	public Import string // full name
	public pos    Pos
	public used   bool
	public alias string 
	/*
		import "github.com/lucy" should access by lucy.doSomething()
		import "github.com/std" as std2 should access by std2.doSomething()
	*/
	fn MkAccessName() -> (err error) {
		if this.accessName != null && this.accessName != "" {
			this.alias = this.accessName
			return null
		}
		if false == PackageNameIsValid(this.Import) {
			return new error(sprintf("%s '%s' is not a valid name",
				this.pos.errMsgPrefix(), this.Import))
		}
		this.accessName = common.getBaseName(this.Import)
		return null
	}
}

//different from different source file
class SourceFile {
	imports            map { string -> Import }  // accessName -> *Import
	importsByResources map { string -> Import }  // resourceName -> *Import
	filename          string 
	/*
		rename will modify this file 
	*/
	isDirty bool 
	
	fn SourceFile(filename string) {
		this.super()
		this.filename = filename
	}

	fn insertImport(i Import) ->(err error)  {
		if this.imports == null {
			this.imports = new  map { string -> Import }()
		}
		if this.importsByResources == null {
			this.importsByResources =new map { string -> Import }()
		}
		if err = i.MkAccessName(); err != null {
			return err
		}
		if this.imports.keyExist(i.accessName){
			return new error(sprintf("%s '%s' reimported",
				i.pos.errMsgPrefix(), i.Import))
		}
		if this.importsByResources.keyExist(i.Import) {
			return new error(sprintf("%s '%s' reimported",
				i.pos.errMsgPrefix(), i.accessName))
		}
		this.importsByResources[i.Import] = i
		this.imports[i.accessName] = i
		return null
	}
}

