

typealias binaryConstFolder = fn(bin ExpressionBinary)  -> (is bool, err error)

class ExpressionConstFold {
	
	static fn getBinaryExpressionConstValue(e Expression , folder binaryConstFolder) -> (is bool, err error) {
		bin := e.Data.(ExpressionBinary)
		is1, err1 := bin.Left.constantFold()
		is2, err2 := bin.Right.constantFold()
		if err1 != null { //something is wrong
			err = err1
			return
		}
		if err2 != null {
			err = err2
			return
		}
		if is1 == false ||
			is2 == false {
			is = false
			err = null
			return
		}
		return folder(bin)
	}



	 


	static fn constantFold(e Expression) -> (is bool, err error) {
		if e.isLiteral() {
			return true, null
		}
		// ~
		if e.Type == ExpressionTypeBitwiseNot {
			ee := e.Data.(Expression)
			is, err = ee.constantFold()
			if err != null || is == false {
				return
			}
			if ee.isInteger() == false {
				err = new error(sprintf("%s cannot apply '^' on a non-integer expression",
					errMsgPrefix(e.Pos)))
				return
			}
			e.Type = ee.Type
			switch ee.Type {
			case ExpressionTypeByte:
				e.longValue = ~ee.Data.(longValue)
			case ExpressionTypeChar:
				e.longValue = ~ee.Data.(longValue)
			case ExpressionTypeShort:
				e.longValue = ~ee.Data.(longValue)
			case ExpressionTypeInt:
				e.longValue = ~ee.Data.(longValue)
			case ExpressionTypeLong:
				e.longValue = ~ee.Data.(longValue)
            default:

			}
		}
		// !
		if e.Type == ExpressionTypeNot {
			ee := e.Data.(Expression)
			is, err = ee.constantFold()
			if err != null || is == false {
				return
			}
			if ee.Type != ExpressionTypeBool {
				err = new error(sprintf("%s cannot apply '!' on a non-bool expression",
					errMsgPrefix(e.Pos)))
				return
			}
			e.Type = ExpressionTypeBool
			e.Data = !ee.Data.(bool)
			return
		}
		// -
		if e.Type == ExpressionTypeNegative {
			ee := e.Data.(Expression)
			is, err = ee.constantFold()
			if err != null || is == false {
				return
			}
			switch ee.Type {
			case ExpressionTypeFloat:
				is = true
				e.Data = -ee.doubleValue
				e.Type = ExpressionTypeFloat
				return
			case ExpressionTypeDouble:
				is = true
				e.Data = -ee.doubleValue
				e.Type = ExpressionTypeDouble
				return
            default:
			}
		}
		// && and ||
		if e.Type == ExpressionTypeLogicalAnd || e.Type == ExpressionTypeLogicalOr {
			f := fn(bin ExpressionBinary) -> (is bool, err error) {
				if bin.Left.Type != ExpressionTypeBool ||
					bin.Right.Type != ExpressionTypeBool {
					err = e.binaryWrongOpErr()
					return
				}
				is = true
				if e.Type == ExpressionTypeLogicalAnd {
					e.Data = bin.Left.Data.(bool) && bin.Right.Data.(bool)
				} else {
					e.Data = bin.Left.Data.(bool) || bin.Right.Data.(bool)
				}
				e.Type = ExpressionTypeBool
				return
			}
			return e.getBinaryExpressionConstValue(f)
		}
		// + - * / % algebra arithmetic
		if e.Type == ExpressionTypeAdd ||
			e.Type == ExpressionTypeSub ||
			e.Type == ExpressionTypeMul ||
			e.Type == ExpressionTypeDiv ||
			e.Type == ExpressionTypeMod {
			is, err = e.getBinaryExpressionConstValue(e.arithmeticBinaryConstFolder)
			return
		}
		// <<  >>
		if e.Type == ExpressionTypeLsh || e.Type == ExpressionTypeRsh {
			f := fn(bin ExpressionBinary) -> (is bool, err error) {
				if bin.Left.isInteger() == false || bin.Right.isInteger() == false {
					return
				}
				switch bin.Left.Type {
				case ExpressionTypeByte:
					fallthrough
				case ExpressionTypeShort:
					fallthrough
				case ExpressionTypeChar:
					fallthrough
				case ExpressionTypeInt:
					fallthrough
				case ExpressionTypeLong:
					if e.Type == ExpressionTypeLsh {
						e.Data = bin.Left.longValue << byte(bin.Right.getLongValue())
					} else {
						e.Data = bin.Left.longValue >> byte(bin.Right.getLongValue())
					}
				}
				//if this.Type == ExpressionTypeLsh {
				//	switch bin.Left.Type {
				//	case ExpressionTypeByte:
				//		if t := this.longValue; (t >> 8) != 0 {
				//			PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.byteExceeds(t))
				//		}
				//	case ExpressionTypeShort:
				//		if t := this.longValue; (t >> 16) != 0 {
				//			PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.shortExceeds(t))
				//		}
				//	case ExpressionTypeChar:
				//		if t := this.longValue; (t >> 16) != 0 {
				//			PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.charExceeds(t))
				//		}
				//	case ExpressionTypeInt:
				//		if t := this.longValue; (t >> 32) != 0 {
				//			PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.intExceeds(t))
				//		}
				//	}
				//}
				e.Type = bin.Left.Type
				return
			}
			return e.getBinaryExpressionConstValue(f)
		}
		// & | ^
		if e.Type == ExpressionTypeAnd ||
			e.Type == ExpressionTypeOr ||
			e.Type == ExpressionTypeXor {
			f := fn(bin ExpressionBinary) -> (is bool, err error) {
				if bin.Left.isInteger() == false || bin.Right.isInteger() == false ||
					bin.Left.Type != bin.Right.Type {
					return
				}
				switch bin.Left.Type {
				case ExpressionTypeByte:
					if e.Type == ExpressionTypeAnd {
						e.Data = bin.Left.longValue & bin.Right.longValue
					} else if e.Type == ExpressionTypeOr {
						e.Data = bin.Left.longValue | bin.Right.longValue
					} else {
						e.Data = bin.Left.longValue ^ bin.Right.longValue
					}
				case ExpressionTypeShort:
					if e.Type == ExpressionTypeAnd {
						e.Data = bin.Left.longValue & bin.Right.longValue
					} else if e.Type == ExpressionTypeOr {
						e.Data = bin.Left.longValue | bin.Right.longValue
					} else {
						e.Data = bin.Left.longValue ^ bin.Right.longValue
					}
				case ExpressionTypeChar:
					if e.Type == ExpressionTypeAnd {
						e.Data = bin.Left.longValue & bin.Right.longValue
					} else if e.Type == ExpressionTypeOr {
						e.Data = bin.Left.longValue | bin.Right.longValue
					} else {
						e.Data = bin.Left.longValue ^ bin.Right.longValue
					}
				case ExpressionTypeInt:
					if e.Type == ExpressionTypeAnd {
						e.Data = bin.Left.longValue & bin.Right.longValue
					} else if e.Type == ExpressionTypeOr {
						e.Data = bin.Left.longValue | bin.Right.longValue
					} else {
						e.Data = bin.Left.longValue ^ bin.Right.longValue
					}
				case ExpressionTypeLong:
					if e.Type == ExpressionTypeAnd {
						e.Data = bin.Left.longValue & bin.Right.longValue
					} else if e.Type == ExpressionTypeOr {
						e.Data = bin.Left.longValue | bin.Right.longValue
					} else {
						e.Data = bin.Left.longValue ^ bin.Right.longValue
					}
				}
				is = true
				e.Type = bin.Left.Type
				return
			}
			return e.getBinaryExpressionConstValue(f)
		}
		if e.Type == ExpressionTypeNot {
			ee := e.Data.(Expression)
			is, err = ee.constantFold()
			if err != null {
				return
			}
			if is == false {
				return
			}
			if ee.Type != ExpressionTypeBool {
				return false, new error(sprintf("!(not) can only apply to bool expression") )
			}
			is = true
			e.Type = ExpressionTypeBool
			e.Data = !ee.Data.(bool)
			return
		}
		//  == != > < >= <=
		if e.Type == ExpressionTypeEq ||
			e.Type == ExpressionTypeNe ||
			e.Type == ExpressionTypeGe ||
			e.Type == ExpressionTypeGt ||
			e.Type == ExpressionTypeLe ||
			e.Type == ExpressionTypeLt {
			return e.getBinaryExpressionConstValue(e.relationBinaryConstFolder)
		}
		return
	}

	

	static fn convertLiteralToNumberType(e Expression , to VariableTypeKind) {
		if e.isNumber() == false {
			panic("not a number")
		}
		switch to {
		case VariableTypeByte:
			e.longValue = e.getLongValue()
			e.Type = ExpressionTypeByte
		case VariableTypeShort:
			e.Data = e.getLongValue()
			e.Type = ExpressionTypeShort
		case VariableTypeChar:
			e.Data = e.getLongValue()
			e.Type = ExpressionTypeChar
		case VariableTypeInt:
			e.Data = e.getLongValue()
			e.Type = ExpressionTypeInt
		case VariableTypeLong:
			e.Data = e.getLongValue()
			e.Type = ExpressionTypeLong
		case VariableTypeFloat:
			e.Data = float(e.getDoubleValue())
			e.Type = ExpressionTypeFloat
		case VariableTypeDouble:
			e.Data = e.getDoubleValue()
			e.Type = ExpressionTypeDouble
		default:
		}
	}

	

	static fn arithmeticBinaryConstFolder(bin ExpressionBinary) -> (is bool, err error) {
		if bin.Left.Type != bin.Right.Type {
			return
		}
		switch bin.Left.Type {
		case ExpressionTypeByte:
			left := bin.Left.longValue
			right := bin.Right.longValue
			switch e.Type {
			case ExpressionTypeAdd:
				e.Data = left + right
			case ExpressionTypeSub:
				e.Data = left - right
			case ExpressionTypeMul:
				e.Data = left * right
			case ExpressionTypeDiv:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			case ExpressionTypeMod:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			default:
				return false, null
			}
			//if this.Type == ExpressionTypeAdd || this.Type == ExpressionTypeSub {
			//	if t := this.longValue; (t >> 8) != 0 {
			//		PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.byteExceeds(t))
			//	}
			//}
			e.Type = ExpressionTypeByte
			is = true
			return
		case ExpressionTypeShort:
			fallthrough
		case ExpressionTypeChar:
			fallthrough
		case ExpressionTypeInt:
			left := bin.Left.longValue
			right := bin.Right.longValue
			switch e.Type {
			case ExpressionTypeAdd:
				e.Data = left + right
			case ExpressionTypeSub:
				e.Data = left - right
			case ExpressionTypeMul:
				e.Data = left * right
			case ExpressionTypeDiv:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			case ExpressionTypeMod:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			default:
				return false, null
			}
			//switch this.Type {
			//case ExpressionTypeShort:
			//	if t := this.longValue; (t >> 16) != 0 {
			//		PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.shortExceeds(t))
			//	}
			//case ExpressionTypeChar:
			//	if t := this.longValue; (t >> 16) != 0 {
			//		PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.charExceeds(t))
			//	}
			//case ExpressionTypeInt:
			//	if t := this.longValue; (t >> 32) != 0 {
			//		PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.intExceeds(t))
			//	}
			//}
			e.Type = bin.Left.Type
			is = true
			return
		case ExpressionTypeLong:
			left := bin.Left.longValue
			right := bin.Right.longValue
			switch e.Type {
			case ExpressionTypeAdd:
				e.Data = left + right

			case ExpressionTypeSub:
				e.Data = left - right
			case ExpressionTypeMul:
				e.Data = left * right
			case ExpressionTypeDiv:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			case ExpressionTypeMod:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			default:
				return false, null
			}
			//if this.Type == ExpressionTypeAdd || this.Type == ExpressionTypeSub {
			//	if t := this.longValue < 0; t != (bin.Left.longValue < 0) && t != (bin.Left.longValue < 0) {
			//		PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.longExceeds(this.Data.(long)))
			//	}
			//}
			e.Type = ExpressionTypeLong
			is = true
			return
		case ExpressionTypeFloat:
			left := bin.Left.doubleValue
			right := bin.Right.doubleValue
			switch e.Type {
			case ExpressionTypeAdd:
				e.Data = left + right
			case ExpressionTypeSub:
				e.Data = left - right
			case ExpressionTypeMul:
				e.Data = left * right
			case ExpressionTypeDiv:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			case ExpressionTypeMod:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			default:
				return false, null
			}
			//if this.Type == ExpressionTypeAdd || this.Type == ExpressionTypeSub {
			//	if t := this.doubleValue < 0; t != (bin.Left.doubleValue < 0) && t != (bin.Left.doubleValue < 0) {
			//		PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.floatExceeds())
			//	}
			//}
			e.Type = ExpressionTypeFloat
			is = true
			return
		case ExpressionTypeDouble:
			left := bin.Left.doubleValue
			right := bin.Right.doubleValue
			switch e.Type {
			case ExpressionTypeAdd:
				e.Data = left + right
			case ExpressionTypeSub:
				e.Data = left - right
			case ExpressionTypeMul:
				e.Data = left * right
			case ExpressionTypeDiv:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			case ExpressionTypeMod:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.Data = left
			default:
				return false, null
			}
			//if this.Type == ExpressionTypeAdd || this.Type == ExpressionTypeSub {
			//	if t := this.doubleValue < 0; t != (bin.Left.doubleValue < 0) && t != (bin.Left.doubleValue < 0) {
			//		PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.floatExceeds())
			//	}
			//}
			e.Type = ExpressionTypeDouble
			is = true
			return
		case ExpressionTypeString:
			left := bin.Left.Data.(string)
			right := bin.Right.Data.(string)
			if e.Type == ExpressionTypeAdd {
				if len(left)+len(right) < 65536 {
					e.Type = ExpressionTypeString
					e.Data = left + right
				} else {
					return false, null
				}
			} else {
				return false, null
			}
		default:
		}
		return
	}

	static fn relationBinaryConstFolder(e Expression , bin ExpressionBinary) -> (is bool, err error) {
		if bin.Left.Type == ExpressionTypeBool &&
			bin.Right.Type == ExpressionTypeBool &&
			e.isEqOrNe() {
			if e.Type == ExpressionTypeEq {
				e.Data = bin.Left.Data.(bool) == bin.Right.Data.(bool)
			} else {
				e.Data = bin.Left.Data.(bool) != bin.Right.Data.(bool)
			}
			e.Type = ExpressionTypeBool
			return
		}
		if bin.Left.Type != bin.Right.Type {
			return false, null
		}
		switch bin.Left.Type {
		case ExpressionTypeString:
			left := bin.Left.Data.(string)
			right := bin.Right.Data.(string)
			var b bool
			switch e.Type {
			case ExpressionTypeEq:
				b := left == right
			case ExpressionTypeNe:
				b := left != right
			case ExpressionTypeGe:
				b := left >= right
			case ExpressionTypeGt:
				b := left > right
			case ExpressionTypeLe:
				b := left <= right
			case ExpressionTypeLt:
				b := left < right
			default:
			}
			if b {
				e.longValue = 1
			}else {
				e.longValue = 0
			}
			is = true
			e.Type = ExpressionTypeBool
			return
		case ExpressionTypeByte ,ExpressionTypeShort ,  ExpressionTypeChar , ExpressionTypeInt,ExpressionTypeLong:
			left := bin.Left.longValue
			right := bin.Right.longValue
			var b bool
			switch e.Type {
			case ExpressionTypeEq:
				b = left == right
			case ExpressionTypeNe:
				b = left != right
			case ExpressionTypeGe:
				b = left >= right
			case ExpressionTypeGt:
				b = left > right
			case ExpressionTypeLe:
				b = left <= right
			case ExpressionTypeLt:
				b = left < right
            default:
			}
			if b {
				e.longValue = 1
			}else {
				e.longValue = 0
			}
			is = true
			e.Type = ExpressionTypeBool
			return
		case ExpressionTypeFloat:
			left := bin.Left.doubleValue
			right := bin.Right.doubleValue
			var b bool
			switch e.Type {
			case ExpressionTypeEq:
				b = left == right
			case ExpressionTypeNe:
				b = left != right
			case ExpressionTypeGe:
				b = left >= right
			case ExpressionTypeGt:
				b = left > right
			case ExpressionTypeLe:
				b = left <= right
			case ExpressionTypeLt:
				b = left < right
			default:

			}
			if b {
				e.longValue = 1
			}else {
				e.longValue = 0
			}
			is = true
			e.Type = ExpressionTypeBool
			return
		case ExpressionTypeDouble:
			left := bin.Left.doubleValue
			right := bin.Right.doubleValue
			var b bool 
			switch e.Type {
			case ExpressionTypeEq:
				b = left == right
			case ExpressionTypeNe:
				b = left != right
			case ExpressionTypeGe:
				b = left >= right
			case ExpressionTypeGt:
				b = left > right
			case ExpressionTypeLe:
				b = left <= right
			case ExpressionTypeLt:
				b = left < right
            default:
			}
			if b {
				e.longValue = 1
			}else {
				e.longValue = 0
			}
			is = true
			e.Type = ExpressionTypeBool
			return
        default:
		}
		return
	}
}



