

typealias binaryConstFolder = fn(bin ExpressionBinary)  -> (is bool, err error)

class ExpressionConstFold {
	
	static fn getBinaryExpressionConstValue(e Expression , folder binaryConstFolder) -> (is bool, err error) {
		bin := e.Data.(ExpressionBinary)
		is1, err1 := bin.Left.constantFold()
		is2, err2 := bin.Right.constantFold()
		if err1 != null { //something is wrong
			err = err1
			return
		}
		if err2 != null {
			err = err2
			return
		}
		if is1 == false ||
			is2 == false {
			is = false
			err = null
			return
		}
		return folder(bin)
	}



	 


	static fn constantFold(e Expression) -> (is bool, err error) {
		if e.isLiteral() {
			return true, null
		}
		// ~
		if e.Type == ExpressionTypeBitwiseNot {
			ee := e.Data.(Expression)
			is, err = ee.constantFold()
			if err != null || is == false {
				return
			}
			if ee.isInteger() == false {
				err = new error(sprintf("%s cannot apply '^' on a non-integer expression",
					errMsgPrefix(e.Pos)))
				return
			}
			e.Type = ee.Type
			e.longValue = ~ee.longValue
		    return
		}
		// !
		if e.Type == ExpressionTypeNot {
			ee := e.Data.(Expression)
			is, err = ee.constantFold()
			if err != null || is == false {
				return
			}
			if ee.Type != ExpressionTypeBool {
				err = new error(sprintf("%s cannot apply '!' on a non-bool expression",
					errMsgPrefix(e.Pos)))
				return
			}
			e.Type = ExpressionTypeBool
			if ee.longValue == 1 {
			    e.longValue = 0
			}else {
			    e.longValue = 1
			}
			return
		}
		// -
		if e.Type == ExpressionTypeNegative {
			ee := e.Data.(Expression)
			is, err = ee.constantFold()
			if err != null || is == false {
				return
			}
			if e.isNumber() == false {
			    err = new error(sprintf("%s not a number" , e.Pos.ErrMsgPrefix()))
			    is = false
			    return
			}
			e.Type = ee.Type
			is = true
			switch ee.Type {
			case ExpressionTypeByte:
			     e.longValue = -ee.longValue
            case ExpressionTypeShort:
                 e.longValue = -ee.longValue
            case ExpressionTypeChar:
                 e.longValue = -ee.longValue
            case ExpressionTypeInt:
                 e.longValue = -ee.longValue
            case ExpressionTypeLong:
                e.longValue = -ee.longValue
			case ExpressionTypeFloat:
                e.doubleValue = -ee.doubleValue
			case ExpressionTypeDouble:
				e.doubleValue = -ee.doubleValue
            default:
			}
			return
		}
		// && and ||
		if e.Type == ExpressionTypeLogicalAnd || e.Type == ExpressionTypeLogicalOr {
			f := fn(bin ExpressionBinary) -> (is bool, err error) {
				if bin.Left.Type != ExpressionTypeBool ||
					bin.Right.Type != ExpressionTypeBool {
					err = e.binaryWrongOpErr()
					return
				}
				is = true
				if e.Type == ExpressionTypeLogicalAnd {
					e.longValue = (bin.Left.longValue == 1 && bin.Right.longValue == 1) ? 1L : 0L
				} else {
					e.longValue = (bin.Left.longValue == 1  || bin.Right.longValue == 1 ) ? 1L : 0L
				}
				e.Type = ExpressionTypeBool
				return
			}
			return e.getBinaryExpressionConstValue(f)
		}
		// + - * / % algebra arithmetic
		if e.Type == ExpressionTypeAdd ||
			e.Type == ExpressionTypeSub ||
			e.Type == ExpressionTypeMul ||
			e.Type == ExpressionTypeDiv ||
			e.Type == ExpressionTypeMod {
			is, err = e.getBinaryExpressionConstValue(e.arithmeticBinaryConstFolder)
			return
		}
		// <<  >>
		if e.Type == ExpressionTypeLsh || e.Type == ExpressionTypeRsh {
			f := fn(bin ExpressionBinary) -> (is bool, err error) {
				if bin.Left.isInteger() == false || bin.Right.isInteger() == false {
					return
				}

                if e.Type == ExpressionTypeLsh {
                    e.longValue = bin.Left.longValue << byte(bin.Right.getLongValue())
                } else {
                    e.longValue = bin.Left.longValue >> byte(bin.Right.getLongValue())
                }

				//if this.Type == ExpressionTypeLsh {
				//	switch bin.Left.Type {
				//	case ExpressionTypeByte:
				//		if t := this.longValue; (t >> 8) != 0 {
				//			PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.byteExceeds(t))
				//		}
				//	case ExpressionTypeShort:
				//		if t := this.longValue; (t >> 16) != 0 {
				//			PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.shortExceeds(t))
				//		}
				//	case ExpressionTypeChar:
				//		if t := this.longValue; (t >> 16) != 0 {
				//			PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.charExceeds(t))
				//		}
				//	case ExpressionTypeInt:
				//		if t := this.longValue; (t >> 32) != 0 {
				//			PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.intExceeds(t))
				//		}
				//	}
				//}
				e.Type = bin.Left.Type
				return
			}
			return e.getBinaryExpressionConstValue(f)
		}
		// & | ^
		if e.Type == ExpressionTypeAnd ||
			e.Type == ExpressionTypeOr ||
			e.Type == ExpressionTypeXor {
			f := fn(bin ExpressionBinary) -> (is bool, err error) {
				if bin.Left.isInteger() == false || bin.Right.isInteger() == false ||
					bin.Left.Type != bin.Right.Type {
					return
				}
				if e.Type == ExpressionTypeAnd {
                    e.longValue = bin.Left.longValue & bin.Right.longValue
                } else if e.Type == ExpressionTypeOr {
                    e.longValue = bin.Left.longValue | bin.Right.longValue
                } else {
                    e.longValue = bin.Left.longValue ^ bin.Right.longValue
                }
				is = true
				e.Type = bin.Left.Type
				return
			}
			return e.getBinaryExpressionConstValue(f)
		}
		if e.Type == ExpressionTypeNot {
			ee := e.Data.(Expression)
			is, err = ee.constantFold()
			if err != null {
				return
			}
			if is == false {
				return
			}
			if ee.Type != ExpressionTypeBool {
				return false, new error(sprintf("!(not) can only apply to bool expression") )
			}
			is = true
			e.Type = ExpressionTypeBool
			e.Data = !ee.Data.(bool)
			return
		}
		//  == != > < >= <=
		if e.Type == ExpressionTypeEq ||
			e.Type == ExpressionTypeNe ||
			e.Type == ExpressionTypeGe ||
			e.Type == ExpressionTypeGt ||
			e.Type == ExpressionTypeLe ||
			e.Type == ExpressionTypeLt {
			return e.getBinaryExpressionConstValue(e.relationBinaryConstFolder)
		}
		return
	}

	

	

	

	static fn arithmeticBinaryConstFolder(bin ExpressionBinary) -> (is bool, err error) {
		if bin.Left.Type != bin.Right.Type {
			return
		}
		switch bin.Left.Type {
		case ExpressionTypeByte ,ExpressionTypeShort ,ExpressionTypeChar ,ExpressionTypeInt ,  ExpressionTypeLong  :
			left := bin.Left.longValue
			right := bin.Right.longValue
			switch e.Type {
			case ExpressionTypeAdd:
				e.longValue = left + right
			case ExpressionTypeSub:
				e.longValue = left - right
			case ExpressionTypeMul:
				e.longValue = left * right
			case ExpressionTypeDiv:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.longValue = left
			case ExpressionTypeMod:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.longValue = left
			default:
				return false, null
			}
			//if this.Type == ExpressionTypeAdd || this.Type == ExpressionTypeSub {
			//	if t := this.longValue < 0; t != (bin.Left.longValue < 0) && t != (bin.Left.longValue < 0) {
			//		PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.longExceeds(this.Data.(long)))
			//	}
			//}
			e.Type = bin.Left.Type
			is = true
			return
		case ExpressionTypeFloat ,ExpressionTypeDouble :
			left := bin.Left.doubleValue
			right := bin.Right.doubleValue
			switch e.Type {
			case ExpressionTypeAdd:
				e.doubleValue = left + right
			case ExpressionTypeSub:
				e.doubleValue = left - right
			case ExpressionTypeMul:
				e.doubleValue = left * right
			case ExpressionTypeDiv:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.doubleValue = left
			case ExpressionTypeMod:
				if right == 0 {
					err = divisionByZeroErr(bin.Right.Pos)
				}
				e.doubleValue = left
			default:
				return false, null
			}
			//if this.Type == ExpressionTypeAdd || this.Type == ExpressionTypeSub {
			//	if t := this.doubleValue < 0; t != (bin.Left.doubleValue < 0) && t != (bin.Left.doubleValue < 0) {
			//		PackageBeenCompile.errors = append(PackageBeenCompile.errors, this.floatExceeds())
			//	}
			//}
			e.Type = bin.Left.Type
			is = true
			return
		case ExpressionTypeString:
			left := bin.Left.Data.(string)
			right := bin.Right.Data.(string)
			if e.Type == ExpressionTypeAdd {
				if len(left)+len(right) < 65536 {
					e.Type = ExpressionTypeString
					e.Data = left + right
				} else {
					return false, null
				}
			} else {
				return false, null
			}
		default:
		}
		return
	}

	static fn relationBinaryConstFolder(e Expression , bin ExpressionBinary) -> (is bool, err error) {
		if bin.Left.Type == ExpressionTypeBool &&
			bin.Right.Type == ExpressionTypeBool &&
			e.isEqOrNe() {
			if e.Type == ExpressionTypeEq {
				e.longValue = (bin.Left.longValue == bin.Right.longValue) ? 1 : 0
			} else {
				e.longValue = (bin.Left.longValue != bin.Right.longValue) ? 1 : 0
			}
			e.Type = ExpressionTypeBool
			return
		}
		if bin.Left.Type != bin.Right.Type {
			return false, null
		}
		switch bin.Left.Type {
		case ExpressionTypeString:
			left := bin.Left.Data.(string)
			right := bin.Right.Data.(string)
			var b bool
			switch e.Type {
			case ExpressionTypeEq:
				b = left == right
			case ExpressionTypeNe:
				b = left != right
			case ExpressionTypeGe:
				b = left >= right
			case ExpressionTypeGt:
				b = left > right
			case ExpressionTypeLe:
				b = left <= right
			case ExpressionTypeLt:
				b = left < right
			default:
			}
			if b {
				e.longValue = 1
			}else {
				e.longValue = 0
			}
			is = true
			e.Type = ExpressionTypeBool
			return
		case ExpressionTypeByte ,ExpressionTypeShort ,  ExpressionTypeChar , ExpressionTypeInt,ExpressionTypeLong:
			left := bin.Left.longValue
			right := bin.Right.longValue
			var b bool
			switch e.Type {
			case ExpressionTypeEq:
				b = left == right
			case ExpressionTypeNe:
				b = left != right
			case ExpressionTypeGe:
				b = left >= right
			case ExpressionTypeGt:
				b = left > right
			case ExpressionTypeLe:
				b = left <= right
			case ExpressionTypeLt:
				b = left < right
            default:
			}
			if b {
				e.longValue = 1
			}else {
				e.longValue = 0
			}
			is = true
			e.Type = ExpressionTypeBool
			return
		case ExpressionTypeFloat:
			left := bin.Left.doubleValue
			right := bin.Right.doubleValue
			var b bool
			switch e.Type {
			case ExpressionTypeEq:
				b = left == right
			case ExpressionTypeNe:
				b = left != right
			case ExpressionTypeGe:
				b = left >= right
			case ExpressionTypeGt:
				b = left > right
			case ExpressionTypeLe:
				b = left <= right
			case ExpressionTypeLt:
				b = left < right
			default:

			}
			if b {
				e.longValue = 1
			}else {
				e.longValue = 0
			}
			is = true
			e.Type = ExpressionTypeBool
			return
		case ExpressionTypeDouble:
			left := bin.Left.doubleValue
			right := bin.Right.doubleValue
			var b bool 
			switch e.Type {
			case ExpressionTypeEq:
				b = left == right
			case ExpressionTypeNe:
				b = left != right
			case ExpressionTypeGe:
				b = left >= right
			case ExpressionTypeGt:
				b = left > right
			case ExpressionTypeLe:
				b = left <= right
			case ExpressionTypeLt:
				b = left < right
            default:
			}
			if b {
				e.longValue = 1
			}else {
				e.longValue = 0
			}
			is = true
			e.Type = ExpressionTypeBool
			return
        default:
		}
		return
	}
}



