

class ExpressionConstFold {


	static fn constantFold(e Expression) -> (is bool, err error) {
		if e.isLiteral() {
			return true, null
		}
		// ~
		if e.Type == ExpressionTypeBitwiseNot {
			ee := e.data.(Expression)
			is, err = ee.constantFold()
			if err != null || is == false {
				return
			}
			if ee.isInteger() == false {
				err = new error(sprintf("%s cannot apply '^' on a non-integer expression",
					errMsgPrefix(e.pos)))
				return
			}
			e.Type = ee.Type
			e.longValue = ~ee.longValue
		    return
		}
		// !
		if e.Type == ExpressionTypeNot {
			ee := e.data.(Expression)
			is, err = ee.constantFold()
			if err != null || is == false {
				return
			}
			if ee.Type != ExpressionTypeBool {
				err = new error(sprintf("%s cannot apply '!' on a non-bool expression",
					errMsgPrefix(e.pos)))
				return
			}
			e.Type = ExpressionTypeBool
			e.boolValue = !ee.boolValue
			return
		}
		// -
		if e.Type == ExpressionTypeNegative {
			ee := e.data.(Expression)
			is, err = ee.constantFold()
			if err != null || is == false {
				return
			}
			if ee.isNumber() == false {
			    is = false
			    err = new error(sprintf("%s cannot apply '-' on a '%s'",
					errMsgPrefix(e.pos) ,e.op))
			    return
			}
			e.Type = ee.Type
			is = true
			switch ee.Type {
			case ExpressionTypeByte:
			     e.longValue = -ee.longValue
            case ExpressionTypeShort:
                 e.longValue = -ee.longValue
            case ExpressionTypeChar:
                 e.longValue = -ee.longValue
            case ExpressionTypeInt:
                 e.longValue = -ee.longValue
            case ExpressionTypeLong:
                e.longValue = -ee.longValue
			case ExpressionTypeFloat:
                e.doubleValue = -ee.doubleValue
			case ExpressionTypeDouble:
				e.doubleValue = -ee.doubleValue
            default:
			}
			return
		}
		// && and ||
		if e.Type == ExpressionTypeLogicalAnd || e.Type == ExpressionTypeLogicalOr {
			bin := e.data.(ExpressionBinary)
			is,err = .constantFold(bin.left)
			if is == false || err != null {
			    return
			}
			is,err = .constantFold(bin.right)
			if is == false || err != null {
			    return
			}
			if bin.left.Type != ExpressionTypeBool ||
					bin.right.Type != ExpressionTypeBool {
					err = e.binaryWrongOpErr()
					return
			}
			is = true
			if e.Type == ExpressionTypeLogicalAnd {
				e.boolValue = bin.left.boolValue && bin.right.boolValue
			} else {
				e.boolValue = bin.left.boolValue || bin.right.boolValue
			}
			e.Type = ExpressionTypeBool
			return
		}
		// + - * / % algebra arithmetic
		if e.Type == ExpressionTypeAdd ||
			e.Type == ExpressionTypeSub ||
			e.Type == ExpressionTypeMul ||
			e.Type == ExpressionTypeDiv ||
			e.Type == ExpressionTypeMod {
			bin := e.data.(ExpressionBinary)
			is,err = .constantFold(bin.left)
			if is == false || err != null {
			    return
			}
			is,err = .constantFold(bin.right)
			if is == false || err != null {
			    return
			}
			if bin.left.Type != bin.right.Type {
				return
			} 
			switch bin.left.Type {
			case ExpressionTypeByte ,ExpressionTypeShort ,ExpressionTypeChar ,ExpressionTypeInt ,  ExpressionTypeLong  :
				left := bin.left.longValue
				right := bin.right.longValue
				switch e.Type {
				case ExpressionTypeAdd:
					e.longValue = left + right
				case ExpressionTypeSub:
					e.longValue = left - right
				case ExpressionTypeMul:
					e.longValue = left * right
				case ExpressionTypeDiv:
					if right == 0 {
						err = divisionByZeroErr(bin.right.pos)
					}
					e.longValue = left
				case ExpressionTypeMod:
					if right == 0 {
						err = divisionByZeroErr(bin.right.pos)
					}
					e.longValue = left
				default:
					return false, null
				}
				//if this.Type == ExpressionTypeAdd || this.Type == ExpressionTypeSub {
				//	if t := this.longValue < 0; t != (bin.left.longValue < 0) && t != (bin.left.longValue < 0) {
				//		packageBeenCompile.errors = append(packageBeenCompile.errors, this.longExceeds(this.data.(long)))
				//	}
				//}
				e.Type = bin.left.Type
				is = true
				return
			case ExpressionTypeFloat ,ExpressionTypeDouble :
				left := bin.left.doubleValue
				right := bin.right.doubleValue
				switch e.Type {
				case ExpressionTypeAdd:
					e.doubleValue = left + right
				case ExpressionTypeSub:
					e.doubleValue = left - right
				case ExpressionTypeMul:
					e.doubleValue = left * right
				case ExpressionTypeDiv:
					if right == 0d {
						err = divisionByZeroErr(bin.right.pos)
					}
					e.doubleValue = left
				case ExpressionTypeMod:
					if right == 0d {
						err = divisionByZeroErr(bin.right.pos)
					}
					e.doubleValue = left
				default:
					return false, null
				}
				//if this.Type == ExpressionTypeAdd || this.Type == ExpressionTypeSub {
				//	if t := this.doubleValue < 0; t != (bin.left.doubleValue < 0) && t != (bin.left.doubleValue < 0) {
				//		packageBeenCompile.errors = append(packageBeenCompile.errors, this.floatExceeds())
				//	}
				//}
				e.Type = bin.left.Type
				is = true
				return
			case ExpressionTypeString:
				left := bin.left.stringValue
				right := bin.right.stringValue
				if e.Type == ExpressionTypeAdd {
					if len(left)+len(right) < 65536 {
						e.Type = ExpressionTypeString
						e.stringValue = left + right
					} else {
						return false, null
					}
				} else {
					return false, null
				}
			default:
				return false, null
			}
		}
		// <<  >>
		if e.Type == ExpressionTypeLsh || e.Type == ExpressionTypeRsh {
			bin := e.data.(ExpressionBinary)
			is,err = .constantFold(bin.left)
			if is == false || err != null {
			    return
			}
			is,err = .constantFold(bin.right)
			if is == false || err != null {
			    return
			}
			if bin.left.Type != bin.right.Type {
				return
			} 
			if bin.left.isInteger() == false || bin.right.isInteger() == false {
				return
			}

            if e.Type == ExpressionTypeLsh {
                e.longValue = bin.left.longValue << byte(bin.right.getLongValue())
            } else {
                e.longValue = bin.left.longValue >> byte(bin.right.getLongValue())
            }
			//if this.Type == ExpressionTypeLsh {
			//	switch bin.left.Type {
			//	case ExpressionTypeByte:
			//		if t := this.longValue; (t >> 8) != 0 {
			//			packageBeenCompile.errors = append(packageBeenCompile.errors, this.byteExceeds(t))
			//		}
			//	case ExpressionTypeShort:
			//		if t := this.longValue; (t >> 16) != 0 {
			//			packageBeenCompile.errors = append(packageBeenCompile.errors, this.shortExceeds(t))
			//		}
			//	case ExpressionTypeChar:
			//		if t := this.longValue; (t >> 16) != 0 {
			//			packageBeenCompile.errors = append(packageBeenCompile.errors, this.charExceeds(t))
			//		}
			//	case ExpressionTypeInt:
			//		if t := this.longValue; (t >> 32) != 0 {
			//			packageBeenCompile.errors = append(packageBeenCompile.errors, this.intExceeds(t))
			//		}
			//	}
			//}
			e.Type = bin.left.Type
			return

		}
		// & | ^
		if e.Type == ExpressionTypeAnd ||
			e.Type == ExpressionTypeOr ||
			e.Type == ExpressionTypeXor {

			bin := e.data.(ExpressionBinary)
			is,err = .constantFold(bin.left)
			if is == false || err != null {
			    return
			}
			is,err = .constantFold(bin.right)
			if is == false || err != null {
			    return
			}
			if bin.left.Type != bin.right.Type {
				return
			} 
			if bin.left.isInteger() == false || bin.right.isInteger() == false ||
				bin.left.Type != bin.right.Type {
				return
			}
			if e.Type == ExpressionTypeAnd {
                e.longValue = bin.left.longValue & bin.right.longValue
            } else if e.Type == ExpressionTypeOr {
                e.longValue = bin.left.longValue | bin.right.longValue
            } else {
                e.longValue = bin.left.longValue ^ bin.right.longValue
            }
			is = true
			e.Type = bin.left.Type
			return
		}
		if e.Type == ExpressionTypeNot {
			ee := e.data.(Expression)
			is, err = ee.constantFold()
			if err != null {
				return
			}
			if is == false {
				return
			}
			if ee.Type != ExpressionTypeBool {
				return false, new error(sprintf("!(not) can only apply to bool expression") )
			}
			is = true
			e.Type = ExpressionTypeBool
			e.boolValue = !ee.boolValue
			return
		}
		//  == != > < >= <=
		if e.Type == ExpressionTypeEq ||
			e.Type == ExpressionTypeNe ||
			e.Type == ExpressionTypeGe ||
			e.Type == ExpressionTypeGt ||
			e.Type == ExpressionTypeLe ||
			e.Type == ExpressionTypeLt {
			bin := e.data.(ExpressionBinary)
			is,err = .constantFold(bin.left)
			if is == false || err != null {
			    return
			}
			is,err = .constantFold(bin.right)
			if is == false || err != null {
			    return
			}
			if bin.left.Type != bin.right.Type {
				return
			} 

			if bin.left.Type != bin.right.Type {
			return false, null
		}
		if bin.left.Type == ExpressionTypeBool &&
			bin.right.Type == ExpressionTypeBool &&
			e.isEqOrNe() {
			if e.Type == ExpressionTypeEq {
				e.boolValue = bin.left.boolValue == bin.right.boolValue
			} else {
				e.boolValue = bin.left.boolValue != bin.right.boolValue
			}
			e.Type = ExpressionTypeBool
			return
		}
		switch bin.left.Type {
		case ExpressionTypeString:
			left := bin.left.stringValue
			right := bin.right.stringValue
			switch e.Type {
			case ExpressionTypeEq:
				e.boolValue = left == right
			case ExpressionTypeNe:
				e.boolValue = left != right
			case ExpressionTypeGe:
				e.boolValue = left >= right
			case ExpressionTypeGt:
				e.boolValue = left > right
			case ExpressionTypeLe:
				e.boolValue = left <= right
			case ExpressionTypeLt:
				e.boolValue = left < right
			default:
			}
			is = true
			e.Type = ExpressionTypeBool
			return
		case ExpressionTypeByte ,ExpressionTypeShort ,  ExpressionTypeChar , ExpressionTypeInt,ExpressionTypeLong:
			left := bin.left.longValue
			right := bin.right.longValue
			switch e.Type {
			case ExpressionTypeEq:
				e.boolValue = left == right
			case ExpressionTypeNe:
				e.boolValue = left != right
			case ExpressionTypeGe:
				e.boolValue = left >= right
			case ExpressionTypeGt:
				e.boolValue = left > right
			case ExpressionTypeLe:
				e.boolValue = left <= right
			case ExpressionTypeLt:
				e.boolValue = left < right
            default:
			}
			is = true
			e.Type = ExpressionTypeBool
			return
		case ExpressionTypeFloat , ExpressionTypeDouble:
			left := bin.left.doubleValue
			right := bin.right.doubleValue
			switch e.Type {
			case ExpressionTypeEq:
				e.boolValue = left == right
			case ExpressionTypeNe:
				e.boolValue = left != right
			case ExpressionTypeGe:
				e.boolValue = left >= right
			case ExpressionTypeGt:
				e.boolValue = left > right
			case ExpressionTypeLe:
				e.boolValue = left <= right
			case ExpressionTypeLt:
				e.boolValue = left < right
            default:
			}
			is = true
			e.Type = ExpressionTypeBool
			return
        default:
        	return false , null 
		}
		return
		}
	}

	
	

	
	 
}



