 

public class StatementReturn   {
	public defers      []StatementDefer
	public Expressions []Expression
	public pos         Pos


	fn mkDefers(b Block) {
		if b.isFunctionBlock == false { // not top block
			this.mkDefers(b.outer) // recursive
		}
		if b.defers != null {
			this.defers.appendAll(b.defers)
		}
	}

	fn check(b Block) -> (errs []error = []error {} ) {
		if b.inheritedAttribute.Defer != null {
			return []error{new error(sprintf("%s cannot has 'return' in 'defer'",
				this.pos.ErrMsgPrefix()))}
		}
		this.defers = []StatementDefer{}
		this.mkDefers(b)
		if len(this.Expressions) == 0 { // always ok
			return errs
		}
		returnValueTypes := checkExpressions(b, this.Expressions, errs, false)
		rs := b.inheritedAttribute.Function.Type.ReturnList
		pos := this.Expressions[len(this.Expressions)-1].pos
		if len(returnValueTypes) < len(rs) {
			errs.append(new error(sprintf("%s too few arguments to return", pos.ErrMsgPrefix())))
		} else if len(returnValueTypes) > len(rs) {
			errs.append(new error(sprintf("%s too many arguments to return", pos.ErrMsgPrefix())))
		}
		convertExpressionsToNeeds(this.Expressions,
			b.inheritedAttribute.Function.Type.mkCallReturnTypes(this.Expressions[0].pos), returnValueTypes)
		for k, v := range rs {
			if k < len(returnValueTypes) && returnValueTypes[k] != null {
				if false == v.Type.assignAble(errs, returnValueTypes[k]) {
					errs.append(new error(sprintf("%s cannot use '%s' as '%s' to return",
						returnValueTypes[k].pos.ErrMsgPrefix(),
						returnValueTypes[k].typeString(),
						v.Type.typeString())))
				}
			}
		}
		return errs
	}	
}

