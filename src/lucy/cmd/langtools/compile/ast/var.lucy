import "java/lang/Object"

public interface  LoadImport {
	public fn LoadImport(importName string) -> (Object, error)
}

const	magicIdentifierFile     = "__FILE__"
const	magicIdentifierLine     = "__LINE__"
const	magicIdentifierTime     = "__TIME__"
const	magicIdentifierClass    = "__CLASS__"
const	MainFunctionName        = "main"
const	ThisPointerName         = "this"
const	UnderScore              = "_"
const	LucyRootClass           = "lucy/lang/Lucy"
const	JavaRootClass           = "java/lang/Object"
const	DefaultExceptionClass   = "java/lang/Exception"
const	JavaThrowableClass      = "java/lang/Throwable"
const	JavaStringClass         = "java/lang/String"
const	SUPER                   = "super"
const	SpecialMethodInit       = "<init>"
const	classInitMethod         = "<clinit>"

 

fn isMagicIdentifier(name string) ->(is bool)  {
	return name == magicIdentifierFile ||
		name == magicIdentifierLine ||
		name == magicIdentifierTime ||
		name == magicIdentifierClass
}

var	buildInFunctionsMap = new map { string -> Function }()

// var	lucyBuildInPackage  Package

public var	ParseFunctionHandler fn(bs []byte, pos Pos) -> (f Function, es []error)
var	javaStringClass      Class
public var	LucyBytesType       Type // []byte
public var	JavaBytesType        Type // byte[]

{
	// []byte
	LucyBytesType = new Type()
	LucyBytesType.Type = VariableTypeArray
	LucyBytesType.array = new Type()
	LucyBytesType.array.Type = VariableTypeByte

	//byte[]
	JavaBytesType = new Type()
	JavaBytesType.Type = VariableTypeJavaArray
	JavaBytesType.array = new Type()
	JavaBytesType.array.Type = VariableTypeByte
}

fn loadJavaStringClass(block Block , pos Pos) ->(err error) {
	if javaStringClass != null {
		return null
	}
	c, err := block.inheritedAttribute.p.loader.LoadImport(JavaStringClass)
	if err != null {
		return err
	}
	if cc, ok := c.(Class); ok && cc != null {
		javaStringClass = cc
		return null
	} else {
		panic("loaded java string class is not a class")
	}
}




