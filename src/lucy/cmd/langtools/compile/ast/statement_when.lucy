 

public class StatementWhenCase {
	public matches []Type
	public block   Block
	public inlineComment string 
}


public class StatementWhen {
	public pos       Pos
	public condition Type
	public cases     []StatementWhenCase
	public Default   Block
	public inlineComment string 
	public elseInlineComment string 
	/*
		switchStatement will be override
	*/
	fn check(block Block, switchStatement Statement) -> (errs []error = []error{}) {
		if this.condition == null { // must be a error must parse stage
			return  
		}
		if len(this.condition.getParameterType(block.inheritedAttribute.Function.Type)) == 0 {
			errs.append(new error(sprintf("%s '%s' constains no parameter type",
				this.condition.pos.errMsgPrefix(), this.condition.typeString())))
			return errs
		}
		if err := this.condition.resolve(block); err != null {
			errs.append(err)
			return
		}
		var match Type
		var matchBlock Block
		typesChecked := []Type{}
		checkExists := fn(ts []Type, t Type) ->(exists Type) {
			for _, v := range ts {
				if v.equal(t) {
					return v
				}
			}
			return null
		}
		for _, t := range this.cases {
			for _, tt := range t.matches {
				if err := tt.resolve(block); err != null {
					errs.append(err)
					continue
				}
				if exist := checkExists(typesChecked, tt); exist != null {
					errMsg := sprintf("%s match '%s' already exist,first declared at:\n",
						errMsgPrefix(tt.pos), tt.typeString())
					errMsg += sprintf("\t %s", errMsgPrefix(exist.pos))
					errs.append(new error(errMsg))
					return
				}
				typesChecked.append(tt)
				if this.condition.equal(tt) == false {
					//no match here
					continue
				}
				// found
				if match == null {
					match = tt
					matchBlock = t.block
				}
			}
		}
		if len(errs) > 0 {
			return errs
		}
		if match == null {
			if this.Default == null {
				errs.append(new error(sprintf("%s condition resolve as '%s' has no match and no 'default block'",
						errMsgPrefix(this.condition.pos), this.condition.typeString())))
			} else {
				switchStatement.Type = StatementTypeBlock
				switchStatement.block = this.Default
				switchStatement.block.inherit(block)
				switchStatement.block.isWhenBlock = true
				switchStatement.block.inheritedAttribute.forBreak = switchStatement.block
				errs.appendAll (switchStatement.block.check())
			}
			return
		}
		// let`s reWrite
		if matchBlock == null {
			switchStatement.Type = StatementTypeNop
			return errs
		} else {
			switchStatement.Type = StatementTypeBlock
			switchStatement.block = matchBlock
			switchStatement.block.inherit(block)
			switchStatement.block.isWhenBlock = true
			switchStatement.block.inheritedAttribute.forBreak = switchStatement.block
			errs.appendAll(switchStatement.block.check())
			return 
		}
	}	
}



