 
class ExpressionCheckTypeConversion {
	static fn check(e Expression , block Block, errs []error)  ->(valueType Type){
		conversion := e.data.(ExpressionTypeConversion)
		on, es := conversion.Expression.checkSingleValueContextExpression(block)
		errs.appendAll(es)
		if on == null {
			return null
		}
		if err := on.rightValueValid(); err != null {
			errs.append(err)
			return null
		}
		err := conversion.Type.resolve(block)
		if err != null {
			errs.append(err)
			return null
		}
		valueType = conversion.Type.Clone()
		valueType.pos = e.pos
		if on.isNumber() && conversion.Type.isNumber() {
			if conversion.Expression.isLiteral() {
				conversion.Expression.convertToNumberType(conversion.Type.Type)
				e.Type = conversion.Expression.Type
				e.longValue = conversion.Expression.longValue
				e.doubleValue = conversion.Expression.doubleValue
				e.value = conversion.Expression.value
			}
			return valueType
		}
		// string([]byte)
		if conversion.Type.Type == VariableTypeString &&
			on.equal(LucyBytesType) {
			return valueType
		}
		// string(byte[])
		if conversion.Type.Type == VariableTypeString &&
			on.equal(JavaBytesType) {
			return valueType
		}
		// int(enum)
		if conversion.Type.Type == VariableTypeInt &&
			on.Type == VariableTypeEnum {
			return valueType
		}
		// enum(int)
		if conversion.Type.Type == VariableTypeEnum &&
			on.Type == VariableTypeInt {
			return valueType
		}
		// []byte("hello world")
		if conversion.Type.equal(LucyBytesType) &&
			on.Type == VariableTypeString {
			return valueType
		}
		// byte[]("hello world")
		if conversion.Type.equal(JavaBytesType) &&
			on.Type == VariableTypeString {
			return valueType
		}
		if conversion.Type.validForTypeAssertOrConversion() && on.isPointer() {
			return valueType
		}
		errs.append(new error( sprintf("%s cannot convert '%s' to '%s'",
			on.pos.errMsgPrefix(), on.typeString(), conversion.Type.typeString())))
		return valueType
	}
}

