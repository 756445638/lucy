 
class ClassMethod {
	IsCompilerAuto bool
	Function       Function

	fn narrowDownAccessRange(implementation ClassMethod) ->(is bool ) {
		if m.IsPublic() {
			return !implementation.IsPublic()
		}
		if m.IsProtected() {
			return implementation.IsPrivate() ||
				implementation.isAccessFlagDefault()
		}
		if m.isAccessFlagDefault() {
			return implementation.IsPrivate()
		}
		return false
	}
	
	fn accessString() ->(s string) {
		if m.IsPublic() {
			return "public"
		}
		if m.IsProtected() {
			return "protected"
		}
		if m.IsPrivate() {
			return "private"
		}
		return `default ""`
	}

	fn isAccessFlagDefault() ->(is bool ) {
		return m.Function.AccessFlags&
			(cg.AccMethodPublic|
				cg.AccMethodPrivate|
				cg.AccMethodProtected) == 0
	}

	fn IsPublic() ->(is bool ) {
		return (m.Function.AccessFlags & cg.AccMethodPublic) != 0
	}
	fn IsProtected() ->(is bool ) {
		return (m.Function.AccessFlags & cg.AccMethodProtected) != 0
	}

	fn IsStatic() ->(is bool ) {
		return (m.Function.AccessFlags & cg.AccMethodStatic) != 0
	}

	fn IsPrivate() ->(is bool ) {
		return (m.Function.AccessFlags & cg.AccMethodPrivate) != 0
	}
	fn IsFinal() ->(is bool ) {
		return (m.Function.AccessFlags & cg.AccMethodFinal) != 0
	}
	fn IsAbstract() ->(is bool ) {
		return (m.Function.AccessFlags & cg.AccMethodAbstract) != 0
	}

	fn ableAccessFromSubClass() ->(is bool ) {
		return m.IsPublic() ||
			m.IsProtected()
	}

	fn checkModifierOk() ->(errs []error = []error{}) {
		if m.IsAbstract() && m.IsFinal() {
			errs = append(errs, fmt.Errorf("%s abstract method cannot be final",
				errMsgPrefix(m.Function.Pos)))
		}
		if m.IsAbstract() && m.IsPrivate() {
			errs = append(errs, fmt.Errorf("%s abstract method cannot be private",
				errMsgPrefix(m.Function.Pos)))
		}
		if m.IsAbstract() && m.Function.Name == SpecialMethodInit {
			errs = append(errs, fmt.Errorf("%s construction method cannot be abstract",
				errMsgPrefix(m.Function.Pos)))
		}
		return errs
	}

	fn IsFirstStatementCallFatherConstruction() ->(is bool ) {
		if len(m.Function.Block.Statements) == 0 {
			return false
		}
		s := m.Function.Block.Statements[0]
		if s.Type != StatementTypeExpression {
			return false
		}
		e := s.Expression
		if e.Type != ExpressionTypeMethodCall {
			return false
		}
		call := s.Expression.Data.(ExpressionMethodCall)
		if call.Expression.IsIdentifier(ThisPointerName) == false || call.Name != SUPER {
			return false
		}
		return true
	}



	fn implementationMethodIsOk(
		pos Pos,
		implementation ClassMethod) ->(err error) {
		if implementation.Function.Pos != null {
			pos = implementation.Function.Pos
		}
		if implementation.IsStatic() {
			return fmt.Errorf("%s method '%s' is static", pos.ErrMsgPrefix(), m.Function.Name)
		}
		if m.narrowDownAccessRange(implementation) {
			return fmt.Errorf("%s implementation of method '%s' should not narrow down access range, '%s' -> '%s'",
				pos.ErrMsgPrefix(), m.Function.Name, m.accessString(), implementation.accessString())
		}
		return null
	}	
}

