import "lucy/cmd/langtools/compile/jvm/cg"


typealias buildInFunctionChecker = fn(
	f Function,
	e ExpressionFunctionCall,
	block Block,
	errs []error,
	args []Type,
	pos Pos) // usEed in build function

public class Function {
	public CallFatherConstructionExpression Expression
	public TemplateFunction                 TemplateFunction
	parameterTypes                   map { string -> Type }     //typed parameters
	public Entrance                         cg.MethodHighLevel // make_node_objects call from
	buildInFunctionChecker           buildInFunctionChecker
	public accessFlags                      char
	public Type                             FunctionType
	public Closure                          Closure = new Closure()
	public name                             string // if name is null string,means no name function
	public block                            Block
	public pos                              Pos
	public jvmDescriptor                    string
	public ClosureVariableOffSet            char // for closure
	public SourceCode                       []byte // source code for template function
	public HasDefer                         bool
	public HaveDefaultValue                 bool
	public DefaultValueStartAt              int
	public isGlobal                         bool
	public isBuildIn                        bool
	public LoadedFromCorePackage            bool
	public used                             bool
	public TemplateClonedFunction           bool
	isPackageInitBlockFunction       bool
	public comment                          string
	public IsClosureFunction                bool

	fn isPublic() -> (is bool) {
		return this.accessFlags&cg.AccMethodPublic != 0
	}

	public fn nameLiteralFunction() -> (name string) {
		if this.name != "" {
			return this.name
		}
		var t string
		if this.name != "" {
			t = this.block.inheritedAttribute.classAndFunctionNames + this.name
		}
		return t
	}

	fn readableMsg() -> (r string)  {
		if this.name == "" {
			return "fn " + this.Type.typeString()
		} else {
			return "fn " + this.name + " " + this.Type.typeString()
		}
	}

	fn makeName() {
		if this.name == "" {
			if this.block.inheritedAttribute.classAndFunctionNames == "" {
				this.name = sprintf("literal$%d", this.pos.line)
			} else {
				this.name = sprintf("%s$literal%d",
					this.block.inheritedAttribute.classAndFunctionNames, this.pos.line)
			}
		}
		name := this.name
		if name == SpecialMethodInit {
			name = "init"
		}
		if this.block.inheritedAttribute.classAndFunctionNames == "" {
			this.block.inheritedAttribute.classAndFunctionNames = name
		} else {
			this.block.inheritedAttribute.classAndFunctionNames += "$" + name
		}
	}

	fn checkBlock(errs []error) {
		this.makeName()
		this.makeLastReturnStatement()
		errs.appendAll(this.block.check())
	}

	fn check(b Block) -> (errs []error= []error{}) {
		this.block.inherit(b)
		this.block.inheritedAttribute.Function = this
		this.checkParametersAndReturns(errs, true, false)
		if this.TemplateFunction == null {
			this.checkBlock(errs)
		}
		return errs
	}
	
	fn clone() -> (ret Function, es []error) {
		ret, es = ParseFunctionHandler(this.SourceCode, this.pos)
		if len(es) > 0 {
			return ret, es
		}
		ret.TemplateClonedFunction = true
		return ret, es
	}
	fn makeLastReturnStatement() {
		s := new StatementReturn()
		t := new Statement()
		t.Type = StatementTypeReturn
		t.StatementReturn = s
		t.pos =  this.block.endPos
		this.block.statements.append( t)
	}

	public fn isGlobalMain() -> (is bool) {
		return this.isGlobal &&
			this.name == MainFunctionName
	}

	fn checkParametersAndReturns(
		errs []error,
		checkReturnVarExpression bool,
		isAbstract bool) {
		var err error
		for k, v := range this.Type.ParameterList {
			v.isFunctionParameter = true
			if len(v.Type.getParameterType(this.Type)) > 0 {
				if this.TemplateFunction == null {
					this.TemplateFunction = new TemplateFunction()
				}
			} else {
				err = v.Type.resolve(this.block)
				if err != null {
					errs.append(err)
				}
				if isAbstract == false {
					err = this.block.Insert(v.name, v.pos, v)
					if err != null {
						errs.append(err)
						continue
					}
				}
			}
			if v.Type.isVariableArgs && v.defaultValueExpression != null {
				errs.append(new error( sprintf("%s vargs cannot have default value",
					errMsgPrefix(v.Type.pos))))
			}
			if v.Type.isVariableArgs {
				if k != len(this.Type.ParameterList)-1 {
					errs.append(new error( sprintf("%s only last parameter can be use as vargs",
						errMsgPrefix(v.Type.pos))))
				} else {
					this.Type.ParameterList = this.Type.ParameterList[0:k]
					this.Type.VArgs = v
				}
				continue
			}
			if this.TemplateFunction != null {
				continue
			}
			if v.defaultValueExpression != null {
				if this.HaveDefaultValue == false {
					this.DefaultValueStartAt = k
				}
				this.HaveDefaultValue = true
				t, es := v.defaultValueExpression.checkSingleValueContextExpression(this.block)
				errs.appendAll(es)
				if t != null {
					if v.Type.assignAble(errs, t) == false {
						errs.append(new error( sprintf("%s cannot use '%s' as '%s'",
							errMsgPrefix(v.defaultValueExpression.pos), t.typeString(), v.Type.typeString())))
						continue
					}
				}
				if v.defaultValueExpression.isLiteral() == false {
					errs.append(new error( sprintf("%s default value must be literal",
						errMsgPrefix(v.defaultValueExpression.pos))))
					continue
				}
				if v.defaultValueExpression.Type == ExpressionTypeNull {
					errs.append(new error( sprintf("%s cannot use 'null' as default value",
						errMsgPrefix(v.defaultValueExpression.pos))))
				}
			}
		}
		if this.Type.VoidReturn() == false {
			//handler return
			for _, v := range this.Type.ReturnList {
				v.isReturn = true
				if len(v.Type.getParameterType(this.Type)) > 0 {
					if this.TemplateFunction == null {
						this.TemplateFunction = new TemplateFunction()
					}
				} else {
					err = v.Type.resolve(this.block)
					if err != null {
						errs.append(err)
					}
					if isAbstract == false {
						err = this.block.Insert(v.name, v.pos, v)
						if err != null {
							errs.append(err)
							continue
						}
					}
				}
				if this.TemplateFunction != null {
					continue
				}
				if checkReturnVarExpression == false {
					// eval expression later
					continue
				}
				if v.defaultValueExpression == null {
					v.defaultValueExpression = v.Type.mkDefaultValueExpression()
					continue
				}
				t, es := v.defaultValueExpression.checkSingleValueContextExpression(this.block)
				if len(es) > 0 {
					errs.appendAll(es)
					continue
				}
				if t != null && v.Type.assignAble(errs, t) == false {
					err = new error(sprintf("%s cannot assign '%s' to '%s'", errMsgPrefix(v.defaultValueExpression.pos),
						t.typeString(), v.Type.typeString()))
					errs.append(err)
				}
			}
		}
	}

	fn checkReturnVarExpression() -> (errs []error= []error{}) {
		if this.Type.VoidReturn() {
			return null
		}
		for _, v := range this.Type.ReturnList {
			if v.defaultValueExpression == null {
				v.defaultValueExpression = v.Type.mkDefaultValueExpression()
				continue
			}
			t, es := v.defaultValueExpression.checkSingleValueContextExpression(this.block)
			if len(es) > 0 {
				errs.appendAll(es)
				continue
			}
			if t != null && v.Type.assignAble(errs, t) == false {
				err := new error(sprintf("%s cannot assign '%s' to '%s'", errMsgPrefix(v.defaultValueExpression.pos),
					t.typeString(), v.Type.typeString()))
				errs.append(err)
			}
		}
		return errs
	}	
}

