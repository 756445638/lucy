import "java/lang/Object"
import "lucy/cmd/langtools/compile/jvm/cg"
import "lucy/cmd/langtools/compile/common"


public class Block {
	public exits []cg.Exit // for switch template
	/*
		should analyse at ast stage
	*/
	public notExecuteToLastStatement bool
	public defers                    []StatementDefer
	public Fn                        Function
	public isFunctionBlock           bool // function block
	public isClassBlock              bool // class block
	public Class                     Class
	public isForBlock                bool // for top block
	public isSwitchBlock             bool // switch statement list block
	public isWhenBlock               bool // template swtich statement list block
	public pos                       Pos
	public endPos                    Pos
	public outer                     Block
	public inheritedAttribute        InheritedAttribute
	public statements                []Statement
	public constants                 map{string->Constant}
	public Functions                 map{string->Function}
	public Classes                   map{string->Class}
	public Enums                     map{string->Enum}
	public EnumNames                 map{string->EnumName}
	public Labels                    map{string->StatementLabel}
	public TypeAliases               map{string->Type}
	public Variables                 map{string->Variable}
	checkConstantsCalled      bool

    fn nameExists(name string) -> (x Object,exist bool) {
        if this.Functions != null {
            if t := this.Functions[name]; t != null {
                return t, true
            }
        }
        if this.Variables != null {
            if t := this.Variables[name]; t != null {
                return t, true
            }
        }
        if this.constants != null {
            if t := this.constants[name]; t != null {
                return t, true
            }
        }
        if this.EnumNames != null {
            if t := this.EnumNames[name]; t != null {
                return t, true
            }
        }
        if this.Classes != null {
            if t := this.Classes[name]; t != null {
                return t, true
            }
        }
        if this.Enums != null {
            if t := this.Enums[name]; t != null {
                return t, true
            }
        }
        if this.TypeAliases != null {
            if t := this.TypeAliases[name]; t != null {
                return t, true
            }
        }
        if this.Labels != null { // should be useless
            if t := this.Labels[name]; t != null {
                return t, true
            }
        }
        return null, false
    }

    /*
        search label
    */
    fn searchLabel(name string) -> (label StatementLabel) {
        outer := this
        for {
            if outer.Labels != null {
                if l := outer.Labels[name]; l != null {
                    l.used = true
                    return l
                }
            }
            if outer.isFunctionBlock {
                return null
            }
            outer = outer.outer
        }
        return null
    }

    /*
        search type
    */
    fn searchType(name string) -> (x Object)  {
        bb := this
        for bb != null {
            if bb.Classes != null {
                if t := bb.Classes[name]; t != null {
                    t.used = true
                    return t
                }
            }
            if bb.Enums != null {
                if t := bb.Enums[name]; t != null {
                    t.used = true
                    return t
                }
            }
            if bb.TypeAliases != null {
                if t := bb.TypeAliases[name]; t != null {
                    return t
                }
            }
            if bb.isFunctionBlock && bb.Fn != null {
                if bb.Fn.parameterTypes != null {
                    if t := bb.Fn.parameterTypes[name]; t != null {
                        return t
                    }
                }
            }
            bb = bb.outer
        }
        return null
    }

    fn identifierIsWhat(x Object) -> (w string) {
        return x.getClass().getName()
    }

    /*
        search identifier
    */
    fn searchIdentifier(from Pos, name string, isCaptureVar []bool) -> (x Object,err error) {
        if this.Functions != null {
            if t := this.Functions[name]; t != null {
                t.used = true
                return t, null
            }
        }
        if this.Variables != null {
            if t := this.Variables[name]; t != null {
                return t, null
            }
        }
        if this.constants != null {
            if t := this.constants[name]; t != null {
                t.used = true
                return t, null
            }
        }
        if this.EnumNames != null {
            if t := this.EnumNames[name]; t != null {
                t.Enum.used = true
                return t, null
            }
        }
        if this.Enums != null {
            if t := this.Enums[name]; t != null {
                t.used = true
                return t, null
            }
        }
        if this.Classes != null {
            if t := this.Classes[name]; t != null {
                t.used = true
                return t, null
            }
        }
        if this.TypeAliases != null {
            if t := this.TypeAliases[name]; t != null {
                return t, null
            }
        }
        if this.isFunctionBlock && this.Fn != null {
            if this.Fn.parameterTypes != null {
                if t := this.Fn.parameterTypes[name]; t != null {
                    return t, null
                }
            }
        }
        // search closure
        if this.inheritedAttribute.Function != null {
            v := this.inheritedAttribute.Function.Closure.search(name)
            if v != null {
                return v, null
            }
        }
        if this.isFunctionBlock &&
            len(this.inheritedAttribute.Function.parameterTypes) > 0 {
            return searchBuildIns(name), null
        }
        if this.isFunctionBlock &&
            name == ThisPointerName {
            return null, null
        }
        if this.outer == null {
            return searchBuildIns(name), null
        }
        t, err := this.outer.searchIdentifier(from, name, isCaptureVar) // search by outer block
        if err != null {
            return t, err
        }
        if t != null { //
            if v,ok := t.(Variable) ; ok {
                if v.isGlobal == false { // not a global variable
                    if this.isFunctionBlock &&
                        this.inheritedAttribute.Function.isGlobal == false {
                        this.inheritedAttribute.Function.Closure.insertVar(from, v)
                            isCaptureVar[0] = true
                    }
                    //cannot search variable from class body
                    if this.isClassBlock {
                        return null, new error(sprintf("%s trying to access variable '%s' from class",
                            from.errMsgPrefix(), name))
                    }
                }
            } 
            if f,ok :=  t.(Function) ; ok {
                if f.isGlobal == false {
                    if this.isClassBlock {
                        this.Class.closure.insertFunction(from, f)
                    }
                    if this.isFunctionBlock {
                        this.Fn.Closure.insertFunction(from, f)
                    }
                }

            } 
               
        }

        return t, null
    }

    fn inherit(father Block) {
        if this.outer != null {
            return
        }
        if this == father {
            panic("inherit from self")
        }

        this.outer = father
        this.inheritedAttribute.forBreak = father.inheritedAttribute.forBreak
        this.inheritedAttribute.statementOffset = father.inheritedAttribute.statementOffset
        this.inheritedAttribute.isConstructionMethod = father.inheritedAttribute.isConstructionMethod
        this.inheritedAttribute.forStatement = father.inheritedAttribute.forStatement
        this.inheritedAttribute.Function = father.inheritedAttribute.Function
        this.inheritedAttribute.Class = father.inheritedAttribute.Class
        this.inheritedAttribute.Defer = father.inheritedAttribute.Defer
        this.inheritedAttribute.classMethod = father.inheritedAttribute.classMethod
        this.inheritedAttribute.classAndFunctionNames = father.inheritedAttribute.classAndFunctionNames


        if this.isFunctionBlock || this.isClassBlock {
            this.inheritedAttribute.forBreak = null
            this.inheritedAttribute.forStatement = null
            this.inheritedAttribute.statementOffset = 0
            this.inheritedAttribute.isConstructionMethod = false
            this.inheritedAttribute.classMethod = null
            this.inheritedAttribute.Defer = null
        }
    }

    fn checkUnUsed() -> (es []error) {
        if common.CompileFlags.DisableCheckUnUse.getValue() {
            return null
        }
        es = []error{}
        for _, v := range this.constants {
            if v.used ||
                v.isGlobal {
                continue
            }
            es.append(new error(sprintf("%s const '%s' has declared,but not used",
                v.pos.errMsgPrefix(), v.name)))
        }
        for _, v := range this.Enums {
            if v.used ||
                v.isGlobal {
                continue
            }
            es.append( new error(sprintf("%s enum '%s' has declared,but not used",
                v.pos.errMsgPrefix(), v.name)))
        }
        for _, v := range this.Classes {
            if v.used ||
                v.isGlobal {
                continue
            }
            es.append(new error(sprintf("%s class '%s' has declared,but not used",
                v.pos.errMsgPrefix(), v.name)))
        }
        for _, v := range this.Functions {
            if v.used ||
                v.isGlobal {
                continue
            }
            es.append(new error(sprintf("%s function '%s' has declared,but not used",
                v.pos.errMsgPrefix(), v.name)))
        }
        for _, v := range this.Labels {
            if v.used {
                continue
            }
            es.append(new error(sprintf("%s enum '%s' has declared,but not used",
                v.pos.errMsgPrefix(), v.name)))
        }
        for _, v := range this.Variables {
            if v.used ||
                v.isGlobal ||
                v.isFunctionParameter ||
                v.name == ThisPointerName ||
                v.isReturn {
                continue
            }
            es.append(new error(sprintf("%s variable '%s' has declared,but not used",
                v.pos.errMsgPrefix(), v.name)))
        }
        return es
    }

    fn check()  -> (errs []error = []error{}) {
        for k, s := range this.statements {
            if s.isStaticFieldDefaultValue {
                // no need to check
                // compile auto statement , checked before
                continue
            }
            this.inheritedAttribute.statementOffset = k
            errs.appendAll(s.check(this))
            if PackageBeenCompile.shouldStop(errs) {
                return errs
            }
        }
        errs.appendAll( this.checkUnUsed())
        return errs
    }

    fn checkConstants() -> (errs []error= new []error(0)) {
        if this.checkConstantsCalled {
            return null
        }
        this.checkConstantsCalled = true
        for _, c := range this.constants {
            if err := this.nameIsValid(c.name, c.pos); err != null {
                errs.append(err)
                this.constants.remove(c.name)
                continue
            }
            err := checkConst(this, c)
            if err != null {
                errs.append(err)
            }
            if err != null && c.Type == null {
                this.constants.remove(c.name)
            }
        }
        return errs
    }

    fn checkNameExist(name string, pos Pos) -> (err error) {
        if this.Variables == null {
            this.Variables = new map {string -> Variable } ()
        }
        if v := this.Variables[name]; v != null {
            errMsg := sprintf("%s name '%s' already declared as variable,first declared at:\n",
                pos.errMsgPrefix(), name)
            errMsg += sprintf("\t%s", v.pos.errMsgPrefix())
            return new error(errMsg)
        }
        if this.Classes == null {
            this.Classes = new map {string-> Class} ()
        }
        if c := this.Classes[name]; c != null {
            errMsg := sprintf("%s name '%s' already declared as class,first declared at:\n",
                pos.errMsgPrefix(), name)
            errMsg += sprintf("\t%s", c.pos.errMsgPrefix())
            return new error(errMsg)
        }
        if this.Functions == null {
            this.Functions = new map  { string -> Function } ()
        }
        if f := this.Functions[name]; f != null {
            errMsg := sprintf("%s name '%s' already declared as function,first declared at:\n",
                pos.errMsgPrefix(), name)
            errMsg += sprintf("\t%s", f.pos.errMsgPrefix())
            return new error(errMsg)
        }
        if this.constants == null {
            this.constants = new map { string -> Constant } ()
        }
        if c := this.constants[name]; c != null {
            errMsg := sprintf("%s name '%s' already declared as const,first declared at:\n",
                pos.errMsgPrefix(), name)
            errMsg += sprintf("\t%s", c.pos.errMsgPrefix())
            return new error(errMsg)
        }
        if this.EnumNames == null {
            this.EnumNames = new map { string->EnumName}()
        }
        if en := this.EnumNames[name]; en != null {
            errMsg := sprintf("%s name '%s' already declared as enumName,first declared at:\n",
                pos.errMsgPrefix(), name)
            errMsg += sprintf("\t%s", en.pos.errMsgPrefix())
            return new error(errMsg)
        }
        if this.TypeAliases == null {
            this.TypeAliases = new map { string -> Type } ()
        }
        if t := this.TypeAliases[name]; t != null {
            errMsg := sprintf("%s name '%s' already declared as enumName,first declared at:\n",
                pos.errMsgPrefix(), name)
            errMsg += sprintf("\t%s", t.pos.errMsgPrefix())
            return new error(errMsg)
        }
        if this.Enums == null {
            this.Enums = new map { string -> Enum } ()
        }
        if e := this.Enums[name]; e != null {
            errMsg := sprintf("%s name %s already declared as enum,first declared at:\n",
                pos.errMsgPrefix(), name)
            errMsg += sprintf("\t%s", e.pos.errMsgPrefix())
            return new error(errMsg)
        }
        return null
    }

    fn nameIsValid(name string, pos Pos) -> (err error) {
        if name == "" {
            return new error(sprintf(`%s "" is not a valid name`, pos.errMsgPrefix()))
        }
        if name == ThisPointerName {
            return new error(sprintf("%s '%s' already been taken", pos.errMsgPrefix(), ThisPointerName))
        }
        if name == "_" {
            return new error(sprintf("%s '%s' is not a valid name", pos.errMsgPrefix(), name))
        }
        if isMagicIdentifier(name) {
            return new error(sprintf("%s '%s' is not a magic identifier", pos.errMsgPrefix(), name))
        }
        if searchBuildIns(name) != null {
            return new error(sprintf("%s '%s' is buildin", pos.errMsgPrefix(), name))
        }
        return null
    }

    public fn Insert(name string, pos Pos, d Object) -> (err error) {
        if err := this.nameIsValid(name, pos); err != null {
            return err
        }
        // handle label
        if label := d.(StatementLabel); label != null {
            if this.Labels == null {
                this.Labels = new map { string -> StatementLabel } ()
            }
            if l := this.Labels[name]; l != null {
                errMsg := sprintf("%s name '%s' already declared as enumName,first declared at:",
                    pos.errMsgPrefix(), name)
                errMsg += sprintf("\t%s", l.statement.pos.errMsgPrefix())
                return new error(errMsg)
            }
            this.Labels[name] = label
            return null
        }
        err = this.checkNameExist(name, pos)
        if err != null {
            return err
        }
        if buildInFunctionsMap[name] != null {
            return new error(sprintf("%s function named '%s' is buildin",
                pos.errMsgPrefix(), name))
        }
        if c := d.(Class) ; d != null {
            this.Classes[name] = c
            return null
        }
        if f := d.(Function) ; f != null {
            this.Functions[name] = f
            return null
        }
        if c := d.(Constant) ; c != null {
             this.constants[name] = c
             return null
        }
        if v := d.(Variable) ; v != null {
            v.localValOffset = 65535 // overflow
            this.Variables[name] = v
            return null
        }
        if e := d.(Enum) ; e != null {
            this.Enums[name] = e
            for _, v := range e.Enums {
                err := this.Insert(v.name, v.pos, v)
                if err != null {
                    return err
                }
            }
            return null
        }
        if en := d.(EnumName) ; en != null {
            this.EnumNames[name] = en
            return null
        }
        if t := d.(Type) ; d != null {
             this.TypeAliases[name] = t
             return null
        }
        return null
    }
}

