class ExpressionCheckMap {
	
	static fn checkMapExpression(e Expression , block Block, errs []error) ->(valueType Type) {
		m := e.Data.(ExpressionMap)
		if m.Type != null {
			if err := m.Type.resolve(block); err != null {
				errs.append(err)
			}
		}
		var mapK Type
		var mapV Type
		noType := m.Type == null
		if noType && len(m.KeyValuePairs) == 0 {
			errs.append(new error(sprintf("%s map literal has no type and no initiational values,"+
					"cannot inference it`s type",
					errMsgPrefix(e.Pos))))
			return null
		}
		if m.Type == null {
			m.Type = &Type{}
			m.Type.Pos = e.Pos
			m.Type.Type = VariableTypeMap
		}
		if m.Type.Map == null {
			m.Type.Map = &Map{}
		}
		longMap := make(map[int64]Pos)
		floatMap := make(map[float32]Pos)
		doubleMap := make(map[float64]Pos)
		stringMap := make(map[string]Pos)
		for _, v := range m.KeyValuePairs {
			// map k
			kType, es := v.Key.checkSingleValueContextExpression(block)
			errs.appendAll(es)
			if kType != null {
				if err := kType.rightValueValid(); err != null {
					errs.append(err)
					continue
				}
				if noType && m.Type.Map.K == null {
					if err := kType.isTyped(); err != null {
						errs.append(err)
					} else {
						m.Type.Map.K = kType
						mapK = m.Type.Map.K
					}
				}
				if mapK != null {
					if mapK.assignAble(errs, kType) == false {
						if noType {
							errs.append(new error(sprintf("%s mix '%s' and '%s' for map value",
								errMsgPrefix(v.Key.Pos),
								kType.TypeString(), mapK.TypeString())))
						} else {
							errs.append(new error(sprintf("%s cannot use '%s' as '%s'",
								errMsgPrefix(v.Key.Pos),
								kType.TypeString(), mapK.TypeString())))
						}
					}
				}
			}
			if m.Type.Map.K != null &&
				v.Key.isLiteral() &&
				m.Type.Map.K.Type == v.Key.Value.Type {
				errMsg := func(pos Pos, first Pos, which interface{}) error {
					errMsg := fmt.Sprintf("%s  '%v' duplicate key,first declared at:\n",
						pos.ErrMsgPrefix(), which)
					errMsg += fmt.Sprintf("\t%s", errMsgPrefix(first))
					return new error(errMsg)
				}
				switch m.Type.Map.K.Type {
				case VariableTypeByte:
					fallthrough
				case VariableTypeChar:
					fallthrough
				case VariableTypeShort:
					fallthrough
				case VariableTypeInt:
					fallthrough
				case VariableTypeLong:
					value := v.Key.Data.(int64)
					if first, ok := longMap[value]; ok {
						errs.append(errMsg(v.Key.Pos, first, v.Key.Data))
					} else {
						longMap[value] = v.Key.Pos
					}
				case VariableTypeFloat:
					value := v.Key.Data.(float32)
					if first, ok := floatMap[value]; ok {
						errs.append(errMsg(v.Key.Pos, first, v.Key.Data))
					} else {
						floatMap[value] = v.Key.Pos
					}
				case VariableTypeDouble:
					value := v.Key.Data.(float64)
					if first, ok := doubleMap[value]; ok {
						errs.append(errMsg(v.Key.Pos, first, v.Key.Data))
					} else {
						doubleMap[value] = v.Key.Pos
					}
				case VariableTypeString:
					value := v.Key.Data.(string)
					if first, ok := stringMap[value]; ok {
						errs.append(errMsg(v.Key.Pos, first, v.Key.Data))
					} else {
						stringMap[value] = v.Key.Pos
					}
				}
			}
			// map v
			vType, es := v.Value.checkSingleValueContextExpression(block)
			errs.appendAll(es)
			if vType == null {
				continue
			}
			if err := kType.rightValueValid(); err != null {
				errs.append(err)
				continue
			}
			if noType && m.Type.Map.V == null {
				if err := vType.isTyped(); err != null {
					errs.append(err)
				} else {
					m.Type.Map.V = vType
					mapV = m.Type.Map.V
				}
			}
			if mapV != null {
				if mapV.assignAble(errs, vType) == false {
					if noType {
						errs.append(new error(sprintf("%s mix '%s' and '%s' for map key",
							errMsgPrefix(v.Value.Pos),
							vType.TypeString(), mapV.TypeString())))
					} else {
						errs.append(new error(sprintf("%s cannot use '%s' as '%s'",
							errMsgPrefix(v.Value.Pos),
							vType.TypeString(), mapV.TypeString())))
					}
				}
			}
		}
		if m.Type.Map.K == null {
			m.Type.Map.K = &Type{
				Type: VariableTypeVoid,
				Pos:  e.Pos,
			}
		}
		if m.Type.Map.V == null {
			m.Type.Map.V = &Type{
				Type: VariableTypeVoid,
				Pos:  e.Pos,
			}
		}
		return m.Type
	}

} 

