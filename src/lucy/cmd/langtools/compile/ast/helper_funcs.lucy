
import "java/lang/Object"



fn divisionByZeroErr(pos Pos) -> (err error) {
	return new error(sprintf("%s division by zero", pos.errMsgPrefix()))
}

fn checkExpressions(block Block, es []Expression, errs []error, singleValueContext bool) ->(valueTypes []Type) {
	ret := []Type{}
	for _, v := range es {
		ts, es := v.check(block)
		errs.appendAll(es)
		if ts == null {
			ret.append(null)
		} else {
			if len(ts) > 1 && singleValueContext {
				errs.append(new error( sprintf("%s multi value in single value context",
					errMsgPrefix(v.pos))))
			}
			for _, t := range ts {
				if t == null {
					continue
				}
				if err := t.rightValueValid(); err != null {
					errs.append(err)
				}
			}
			ret.appendAll(ts)
		}
	}
	return ret
}

fn getExtraExpressionPos(args []Expression, n int) -> (pos Pos) {
	i := 0
	for _, a := range args {
		if a.haveMultiValue() {
			i += len(a.multiValues)
		} else {
			i++
		}
		if i >= n {
			return a.pos
		}
	}
	return null
}

fn mkVoidType(pos Pos) -> (voidType Type) {
	result := new Type()
	result.Type = VariableTypeVoid // means no return;
	result.pos = pos
	return result
}

/*
	when access from global,should check if access from package
*/
fn shouldAccessFromImports(name string, from Pos, alreadyHave Pos) -> (i Import,should bool) {
	//fmt.Println(name, from, alreadyHave)
	// different file
	// should access from import
	if from.filename != alreadyHave.filename {
		i := PackageBeenCompile.getImport(from.filename, name)
		if i != null {
			i.used = true
			return i, true
		} else {
			return null, false
		}
	}
	i = PackageBeenCompile.getImport(from.filename, name)
	if i == null {
		return null, false
	}
	// this is should
	/*
		import
		from
		alreadyHave
	*/
	should = from.line < alreadyHave.line
	if should {
		i.used = true
	}
	return i, should
}

fn methodsNotMatchError(pos Pos, name string, ms []ClassMethod, want []Type) -> (err error) {
	if len(ms) == 0 {
		return new error(sprintf("%s method '%s' not found", pos.errMsgPrefix(), name))
	}
	var errMsg string
	if len(ms) == 1 {
		errMsg = sprintf("%s cannot call method '%s':\n",
			pos.errMsgPrefix(), name)
	} else {
		errMsg = sprintf("%s method named '%s' have no suitable match:\n",
			pos.errMsgPrefix(), name)
	}
	wantString := "fn " + name + " ("
	for k, v := range want {
		if v == null {
			continue
		}
		wantString += v.typeString()
		if k != len(want)-1 {
			wantString += ","
		}
	}
	wantString += ")"
	errMsg += "\twant " + wantString + "\n"
	for _, m := range ms {
		errMsg += "\thave fn " + name + " " + m.Function.Type.typeString() + "\n"
	}
	return new error(errMsg)
}

fn searchBuildIns(name string) -> (t Object)  {
	t = buildInFunctionsMap[name]
	if t != null {
		//check
		if _, exists := lucyBuildInPackage.block.nameExists(name); exists {
			panic(sprintf("%s both exits in 'build function' and 'core package'",
				name))
		}
		return t
	}
	if lucyBuildInPackage != null { // avoid lucy/lang package
		t, _ = lucyBuildInPackage.block.nameExists(name)
		return t
	}
	return null
}

fn checkConst(block Block, c Constant) -> (err error)  {
	if c.Type != null {
		c.mkDefaultValue()
	}
	if c.defaultValueExpression == null {
		err := new error(sprintf("%s const have no expression", errMsgPrefix(c.pos)))
		return err
	}
	is, err := c.defaultValueExpression.constantFold()
	if err != null {
		return err
	}
	if is == false {
		err := new error(sprintf("%s const named '%s' is not defined by const value",
			c.pos.errMsgPrefix(), c.name))
		return err
	}
	t, _ := c.defaultValueExpression.checkSingleValueContextExpression(block)
	if c.Type != null {
		es := []error{}
		if c.Type.assignAble(es, t) == false {
			if (c.Type.isInteger() && t.isInteger()) ||
				(c.Type.isFloat() && t.isFloat()) {
				c.defaultValueExpression.convertLiteralToNumberType(c.Type.Type)
			} else {
				err := new error(sprintf("%s cannot use '%s' as '%s' for initialization value",
					c.pos.errMsgPrefix(), c.Type.typeString(), t.typeString()))
				return err
			}
		}
	} else { // means use old type
		c.Type = t
	}
	switch c.Type.Type {
		case VariableTypeBool:
			c.boolValue = c.defaultValueExpression.boolValue
		case c.Type.isInteger():
			c.longValue = c.defaultValueExpression.longValue
		case c.Type.isFloat():
			c.doubleValue = c.defaultValueExpression.doubleValue
		case VariableTypeString:
			c.stringValue = c.defaultValueExpression.stringValue
	}
    
	return null
}

fn convertExpressionToNeed(e Expression, need Type, eval Type) {
	convertExpressionsToNeeds([]Expression{e}, []Type{need}, []Type{eval})
}


fn convertExpressionsToNeeds(es []Expression, needs []Type, eval []Type) {
	errs := []error{} // no return
	if len(es) == 0 {
		return
	}
	for k, e := range es {
		if e.isLiteral() == false {
			continue
		}
		if k >= len(needs) {
			break
		}
		if needs[k] == null {
			continue
		}
		if eval[k] == null {
			continue
		}

		if needs[k].assignAble(errs, eval[k]) {
			continue // no need
		}
		if (needs[k].isInteger() && eval[k].isInteger()) ||
			(needs[k].isFloat() && eval[k].isFloat()) {
			pos := eval[k].pos // keep pos
			e.convertToNumberType(needs[k].Type)
			eval[k] = e.value
			eval[k].pos = pos
		}
	}
	return
}

// check out package name is valid or not
fn PackageNameIsValid(name string) -> (valid bool) {
	return true
}
