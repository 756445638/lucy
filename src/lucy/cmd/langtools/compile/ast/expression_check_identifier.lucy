import "java/lang/Long"
import "java/util/Date"

class ExpressionCheckIdentifier {
	
	static fn check(e Expression , block Block) -> (valueType Type,err  error) {
		identifier := e.data.(ExpressionIdentifier)
		if identifier.name == UnderScore {
			//_ is not valid
			return null, new error(sprintf("%s '%s' is not a valid name",
				e.pos.errMsgPrefix(), identifier.name))
		}
		//handle magic identifier
		switch identifier.name {
		case magicIdentifierFile:
			e.Type = ExpressionTypeString
			e.stringValue = e.pos.filename
			if identifier.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = e.pos 
			}
			result, _ := e.checkSingleValueContextExpression(block)
			return result, null
		case magicIdentifierLine:
			e.Type = ExpressionTypeInt
			e.data = Long.valueOf(long(0))
			result, _ := e.checkSingleValueContextExpression(block)
			if identifier.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = e.pos 
			}
			return result, null
		case magicIdentifierTime:
			e.Type = ExpressionTypeLong
			e.data = Long.valueOf(new Date().getTime())
			result, _ := e.checkSingleValueContextExpression(block)
			if identifier.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = e.pos 
			}
			return result, null
		case magicIdentifierClass:
			if block.inheritedAttribute.Class == null {
				return null,
					new error(sprintf("%s '%s' must in class scope", e.pos.errMsgPrefix(), identifier.name))
			}
			result := new Type()
			result.Type = VariableTypeClass
			result.pos = e.pos
			result.Class = block.inheritedAttribute.Class
			return result, null
		}
		isCaptureVar := [false]
		d, err := block.searchIdentifier(e.pos, identifier.name, isCaptureVar)
		if err != null {
			return null, err
		}
		if d == null {
			i := block.inheritedAttribute.p.getImport(e.pos.filename, identifier.name)
			if i != null {
				i.used = true
				return .checkIdentifierThroughImports(block , identifier , e , i)
			}
			
		}
		if d == null {
			return null, new error(sprintf("%s '%s' not found", e.pos.errMsgPrefix(), identifier.name))
		}
		if f ,ok := d.(Function) ; ok {
			f := d.(Function)
			if f.isGlobalMain() {
				// not allow
				return null, new error(sprintf("%s fucntion is global main", errMsgPrefix(e.pos)))
			}
			if f.isBuildIn {
				return null, new error(sprintf("%s fucntion '%s' is buildin",
					e.pos.errMsgPrefix(), f.name))
			}
			if f.TemplateFunction != null {
				return null, new error(sprintf("%s fucntion '%s' a template function",
					e.pos.errMsgPrefix(), f.name))
			}
			// try from import
			if f.isBuildIn == false {
				i, should := shouldAccessFromImports(block , identifier.name, e.pos, f.pos)
				if should {
					return .checkIdentifierThroughImports(block,identifier , e , i)
				}
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = f.pos 
			}
			result := new Type()
			result.Type = VariableTypeFunction
			result.functionType = f.Type
			result.pos = e.pos
			identifier.Function = f
			return result, null
		}
		if t ,ok := d.(Variable) ;ok {
			if t.isBuildIn == false { // try from import
				i, should := shouldAccessFromImports(block , identifier.name, e.pos, t.pos)
				if should {
					return .checkIdentifierThroughImports(block,identifier, e , i)
				}
			}
			if isCaptureVar[0] {
				t.beenCapturedAsRightValue++
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = t.pos 
			}
			t.used = true
			result := t.Type.Clone()
			result.pos = e.pos
			identifier.Variable = t
			return result, null
		}
		if t,ok  := d.(Constant) ;ok {
			if t.isBuildIn == false { // try from import
				i, should := shouldAccessFromImports(block , identifier.name, e.pos, t.pos)
				if should {
					return .checkIdentifierThroughImports(block,identifier , e , i)
				}
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = t.pos 
			}
			t.used = true
			e.fromConst(t)
			result := t.Type.Clone()
			result.pos = e.pos
			return result, null
		}
		if c ,ok := d.(Class) ; ok {
			if c.isBuildIn == false { // try from import
				i, should := shouldAccessFromImports(block , identifier.name, e.pos, c.pos)
				if should {
					return .checkIdentifierThroughImports(block,identifier, e , i)
				}
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = c.pos 
			}
			result := new Type()
			result.Type = VariableTypeClass
			result.pos = e.pos
			result.Class = c
			return result, null
		}
		if enumName ,ok := d.(EnumName) ; ok {
			if enumName.Enum.isBuildIn == false { // try from import
				i, should := shouldAccessFromImports(block , identifier.name, e.pos, enumName.pos)
				if should {
					return .checkIdentifierThroughImports(block,identifier, e , i)
				}
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = enumName.pos 
			}
			result := new Type()
			result.pos = enumName.pos
			result.Type = VariableTypeEnum
			result.enumName = enumName
			result.Enum = enumName.Enum
			identifier.EnumName = enumName
			return result, null
		}
		err = new error(sprintf("%s identifier '%s' is not a expression , but '%s'",
			e.pos.errMsgPrefix(), identifier.name, block.identifierIsWhat(d)))
	}
	
	static fn checkIdentifierThroughImports(block Block , identifier ExpressionIdentifier ,  e Expression , it Import) -> (valueType Type,err  error) {
		p, err := loaded.load(it.Import)
		if err != null {
			return null, new error(sprintf("%s %s", e.pos.errMsgPrefix(), err.getMessage()))
		}
		if identifier.locateDefinition {
			block.inheritedAttribute.p.locateDefinition = it.pos  
		}
		valueType = new Type()
		valueType.pos = e.pos
		if pp, ok := p.(Package); ok {
			valueType.Package = pp
			valueType.Type = VariableTypePackage
		} else {
			valueType.Class = p.(Class)
			valueType.Type = VariableTypeClass
		}
	}
} 



