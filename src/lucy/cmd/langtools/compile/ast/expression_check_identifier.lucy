import "java/util/Date"

class ExpressionCheckIdentifier {
	
	static fn check(e Expression , block Block) -> (valueType Type,err  error) {
		identifier := e.data.(ExpressionIdentifier)
		if identifier.autoCompletion {
			block.inheritedAttribute.p.autoCompletionItems = 
			  searchRightValueForAutoCompletionItems(e.pos , block)
			return 
		}
		if identifier.name == UnderScore {
			//_ is not valid
			return null, new error(sprintf("%s '%s' is not a valid name",
				e.pos.errMsgPrefix(), identifier.name))
		}
		//handle magic identifier
		switch identifier.name {
		case MagicIdentifierFile:
			e.Type = ExpressionTypeString
			e.stringValue = e.pos.filename
			if identifier.locateDefinition {
				block.inheritedAttribute.p.setLocationDefinition(e)
				return 
			}
			result, _ := e.checkSingleValueContextExpression(block)
			return result, null
		case MagicIdentifierLine:
			e.Type = ExpressionTypeInt
			e.longValue = long(e.pos.startLine)
			result, _ := e.checkSingleValueContextExpression(block)
			if identifier.locateDefinition {
				block.inheritedAttribute.p.setLocationDefinition(e)
				return 
			}
			return result, null
		case MagicIdentifierTime:
			e.Type = ExpressionTypeLong
			e.longValue = new Date().getTime()
			result, _ := e.checkSingleValueContextExpression(block)
			if identifier.locateDefinition {
				block.inheritedAttribute.p.setLocationDefinition(e)
				return 
			}
			return result, null
		case MagicIdentifierClass:
			if block.inheritedAttribute.Class == null {
				return null,
					new error(sprintf("%s '%s' must in class scope", e.pos.errMsgPrefix(), identifier.name))
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.setLocationDefinition(e)
				return 
			}
			result := new Type()
			result.Type = VariableTypeClass
			result.pos = e.pos
			result.Class = block.inheritedAttribute.Class
			return result, null
		}
		isCaptureVar := [false]
		d, err := block.searchIdentifier(e.pos, identifier.name, isCaptureVar)
		if err != null {
			return null, err
		}
		if d == null {
			i := block.inheritedAttribute.p.getImport(e.pos.filename, identifier.name)
			if i != null {
				return .checkIdentifierThroughImports(block , identifier , e , i)
			}
		}
		if d == null {
			return null, new error(sprintf("%s '%s' not found", e.pos.errMsgPrefix(), identifier.name))
		}
		if f ,ok := d.(Function) ; ok {
			if f.isGlobalMain() {
				// not allow
				return null, new error(sprintf("%s fucntion is global main", errMsgPrefix(e.pos)))
			}
			if f.isBuildIn {
				return null, new error(sprintf("%s fucntion '%s' is buildin",
					e.pos.errMsgPrefix(), f.name))
			}
			if f.templateFunction != null {
				return null, new error(sprintf("%s fucntion '%s' a template function",
					e.pos.errMsgPrefix(), f.name))
			}
			it, should := shouldAccessFromImports(block , identifier.name, e.pos, f.pos)
			if should {
				f.reduceFindUsageInstances(block)
				return .checkIdentifierThroughImports(block,identifier , e , it)
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.setLocationDefinition(f)
				return 
			}
			result := new Type()
			result.Type = VariableTypeFunction
			result.functionType = f.Type
			result.pos = e.pos
			identifier.Function = f
			return result, null
		}
		if t ,ok := d.(Variable) ;ok {
			if t.isBuildIn == false { // try from import
				i, should := shouldAccessFromImports(block , identifier.name, e.pos, t.pos)
				if should {
					t.reduceFindUsageInstances(block)
					return .checkIdentifierThroughImports(block,identifier, e , i)
				}
			}
			if isCaptureVar[0] {
				t.beenCapturedAsRightValue++
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.setLocationDefinition(t)
				return 
			}
			if t.findUsageInstances != null {
				correctLastUsageType("value read" , t.findUsageInstances)
			}
			t.used = true
			result := t.Type.cloneType()
			result.pos = e.pos
			identifier.Variable = t
			return result, null
		}
		if t,ok  := d.(Constant) ;ok {
			if t.isBuildIn == false { // try from import
				i, should := shouldAccessFromImports(block , identifier.name, e.pos, t.pos)
				if should {
					t.reduceFindUsageInstances(block)
					return .checkIdentifierThroughImports(block,identifier , e , i)
				}
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.setLocationDefinition(t)
				return 
			}
			t.used = true
			e.fromConst(t)
			result := t.Type.cloneType()
			result.pos = e.pos
			return result, null
		}
		if c ,ok := d.(Class) ; ok {
			if c.isBuildIn == false { // try from import
				i, should := shouldAccessFromImports(block , identifier.name, e.pos, c.pos)
				if should {
					c.reduceFindUsageInstances(block)
					return .checkIdentifierThroughImports(block,identifier, e , i)
				}
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.setLocationDefinition(c)
				return 
			}
			if c.findUsageInstances != null {
				correctLastUsageType("value read" , c.findUsageInstances)
			}
			result := new Type()
			result.Type = VariableTypeClass
			result.pos = e.pos
			result.Class = c
			return result, null
		}
		if enumName ,ok := d.(EnumName) ; ok {
			if enumName.Enum.isBuildIn == false { // try from import
				i, should := shouldAccessFromImports(block , identifier.name, e.pos, enumName.pos)
				if should {
					enumName.reduceFindUsageInstances(block)
					return .checkIdentifierThroughImports(block,identifier, e , i)
				}
			}
			if identifier.locateDefinition {
				block.inheritedAttribute.p.setLocationDefinition(enumName)
				return 
			}
			result := new Type()
			result.pos = enumName.pos
			result.Type = VariableTypeEnum
			result.enumName = enumName
			result.Enum = enumName.Enum
			identifier.enumName = enumName
			return result, null
		}
		err = new error(sprintf("%s identifier '%s' is not a expression , but '%s'",
			e.pos.errMsgPrefix(), identifier.name, block.identifierIsWhat(d)))
	}
	
	static fn checkIdentifierThroughImports(block Block , identifier ExpressionIdentifier ,  e Expression , it Import) -> (valueType Type,err  error) {
		p, err := block.inheritedAttribute.p.load(it.Import)
		if err != null {
			return null, new error(sprintf("%s %s", e.pos.errMsgPrefix(), err.getMessage()))
		}
		it.mkUsed(e.pos)
		if identifier.locateDefinition {
			block.inheritedAttribute.p.setLocationDefinition(it)
			return 
		}
		valueType = new Type()
		valueType.pos = e.pos
		if pp, ok := p.(Package); ok {
			valueType.Package = pp
			valueType.Type = VariableTypePackage
		} else {
			valueType.Class = p.(Class)
			valueType.Type = VariableTypeClass
		}
	}
} 



