import "lucy/cmd/langtools/compile/common"

{
	registerBuildInFunctions()
}

fn registerBuildInFunctions() {
	{
		//print
		buildInFunctionsMap[common.BuildInFunctionPrint] = new Function()
		buildInFunctionsMap[common.BuildInFunctionPrint].Type = new FunctionType()
        buildInFunctionsMap[common.BuildInFunctionPrint].buildInFunctionChecker = fn(f Function, e ExpressionFunctionCall, block Block, errs []error, args []Type, pos Pos) {
            if len(e.ParameterTypes) > 0 {
                msg := sprintf("%s buildin function expect no typed parameter",
                                          e.ParameterTypes[0].pos.errMsgPrefix() )
                errs . append( new error(msg))
            }
        }

	}
	{
		//catch
		c := new Function()
		buildInFunctionsMap[common.BuildInFunctionCatch] = c
		c.Type.ReturnList = new []Variable(1)
		c.Type.ReturnList[0] = new Variable()
		c.Type.ReturnList[0].name = "returnValue"
		c.Type.ReturnList[0].Type = new Type()
		c.Type.ReturnList[0].Type.Type = VariableTypeObject
		c.Type.ReturnList[0].Type.Class = new Class()
		c.Type.ReturnList[0].Type.Class.name = DefaultExceptionClass
		c.Type.ReturnList[0].Type.Class.notImportedYet = true
		c.buildInFunctionChecker = fn(f Function, e ExpressionFunctionCall, block Block, errs []error, args []Type, pos Pos) {
			if len(e.ParameterTypes) > 0 {
				errs . append(new error( sprintf("%s buildin function expect no typed parameter",
					e.ParameterTypes[0].pos.errMsgPrefix())) )
			}
			if block.inheritedAttribute.Defer == null {
				errs.append(new error( sprintf("%s buildin function '%s' only allow in defer block",
					pos.errMsgPrefix(), common.BuildInFunctionCatch)))
				return
			}
			if len(e.Args) > 1 {
				errs.append(new error( sprintf("%s build function '%s' expect at most 1 argument",
					e.Args[1].pos.errMsgPrefix(), common.BuildInFunctionCatch)))
				return
			}
			if len(e.Args) == 0 {
				if block.inheritedAttribute.Defer.exceptionClass == null {
					c, err := PackageBeenCompile.loadClass(DefaultExceptionClass)
					if err != null {
						errs . append(new error( sprintf("%s load exception class failed,err:%s",
							pos.errMsgPrefix(), err.getMessage())))
						return
					}
					f.Type.ReturnList[0].Type.Class = c
					err = block.inheritedAttribute.Defer.registerExceptionClass(c)
					if err != null {
						errs . append(new error( sprintf("%s %s", pos.errMsgPrefix(), err.getMessage())))
					}
				} else {
					f.Type.ReturnList[0].Type.Class = block.inheritedAttribute.Defer.exceptionClass
				}
				return
			}
			if e.Args[0].Type != ExpressionTypeString {
				errs . append(new error( sprintf("%s build function '%s' expect string argument",
					errMsgPrefix(args[0].pos), common.BuildInFunctionCatch)))
			}
			className := e.Args[0].data.(string)
			c, err := PackageBeenCompile.loadClass(className)
			if err != null {
				errs . append(new error(sprintf("%s %s", e.Args[0].pos.errMsgPrefix(), err.getMessage())))
				return
			}
			have, _ := c.haveSuperClass(e.Args[0].pos, JavaThrowableClass)
			if have == false {
				errs.append(new error(sprintf("%s '%s' does't have super class '%s'",
					e.Args[0].pos.errMsgPrefix(), className, JavaThrowableClass)))
				return
			}
			err = block.inheritedAttribute.Defer.registerExceptionClass(c)
			if err != null {
				errs. append(new error(sprintf("%s %s", args[0].pos.errMsgPrefix(), err.getMessage())))
			}
		}
	}

	{
		//panic
		buildInFunctionsMap[common.BuildInFunctionPanic] = new Function()
		buildInFunctionsMap[common.BuildInFunctionPanic].buildInFunctionChecker = fn(f Function, e ExpressionFunctionCall,
				block Block, errs []error, args []Type, pos Pos) {
				if len(e.ParameterTypes) > 0 {
					errs.append(new error(sprintf("%s buildin function expect no typed parameter",
						errMsgPrefix(e.ParameterTypes[0].pos))))
				}
				if len(args) != 1 {
					errs.append(new error(sprintf("%s buildin function 'panic' expect one argument",
						errMsgPrefix(pos))))
					return
				}
				if len(args) == 0 || args[0] == null {
					return
				}
				meta := new BuildInFunctionPanicMeta()
				e.BuildInFunctionMeta = meta
				if args[0].Type == VariableTypeObject {
					meta.ArgThrowable, _ = args[0].Class.haveSuperClass(args[0].pos, JavaThrowableClass)
				}
			}
		buildInFunctionsMap[common.BuildInFunctionPanic].isBuildIn = true

	}
	/*
	{
		buildInFunctionsMap[common.BuildInFunctionMonitorEnter] = &Function{
			buildInFunctionChecker: monitorChecker,
			isBuildIn:              true,
		}
		buildInFunctionsMap[common.BuildInFunctionMonitorExit] = &Function{
			buildInFunctionChecker: monitorChecker,
			isBuildIn:              true,
		}
	}
	*/
	{
		// len
		buildInFunctionsMap[common.BuildInFunctionLen] = new Function()
		buildInFunctionsMap[common.BuildInFunctionLen].buildInFunctionChecker = fn(
		    f Function,
		    e ExpressionFunctionCall,
		    block Block,
		    errs []error,
		    args []Type,
		    pos Pos) {
				if len(e.ParameterTypes) > 0 {
					errs.append(new error(sprintf("%s buildin function expect no typed parameter",
						errMsgPrefix(e.ParameterTypes[0].pos))))
				}
				if len(args) != 1 {
					errs.append(new error(sprintf("%s expect one argument", errMsgPrefix(pos))))
					return
				}
				if args[0] == null {
					return
				}
				if args[0].Type != VariableTypeArray && args[0].Type != VariableTypeJavaArray &&
					args[0].Type != VariableTypeMap && args[0].Type != VariableTypeString {
					errs.append(new error(sprintf("%s len expect 'array' or 'map' or 'string' argument",
						errMsgPrefix(pos))))
					return
				}
			}
		buildInFunctionsMap[common.BuildInFunctionLen].isBuildIn = true
		Len := buildInFunctionsMap[common.BuildInFunctionLen]
		Len.Type.ReturnList = new []Variable (1)
		Len.Type.ReturnList[0] = new Variable()
		Len.Type.ReturnList[0].Type = new Type()
		Len.Type.ReturnList[0].Type.Type = VariableTypeInt
	}
	{
		// sprintf
		s := new Function()
		buildInFunctionsMap[common.BuildInFunctionSprintf] = s
		s.Type.ReturnList = new []Variable(1)
		s.Type.ReturnList[0] = new Variable()
		s.Type.ReturnList[0].name = "returnValue"
		s.Type.ReturnList[0].Type = new Type()
		s.Type.ReturnList[0].Type.Type = VariableTypeString
		s.buildInFunctionChecker = fn(f Function, e ExpressionFunctionCall, block Block, errs []error,
			args []Type, pos Pos) {
			if len(e.ParameterTypes) > 0 {
				errs.append(new error(sprintf("%s buildin function expect no typed parameter",
					errMsgPrefix(e.ParameterTypes[0].pos))))
			}
			if len(args) == 0 {
				err := new error(sprintf("%s '%s' expect one argument at lease",
					pos.errMsgPrefix(), common.BuildInFunctionSprintf))
				errs.append(err)
				return
			}
			if args[0] == null {
				return
			}
			if args[0].Type != VariableTypeString {
				err := new error(sprintf("%s '%s' first argument must be string",
					pos.errMsgPrefix(), common.BuildInFunctionSprintf))
				errs.append(err)
				return
			}
			_, err := e.Args[0].mustBeOneValueContext(e.Args[0].multiValues)
			if err != null {
				errs.append(err)
				return
			}
			meta := new BuildInFunctionSprintfMeta()
			e.BuildInFunctionMeta = meta
			meta.Format = e.Args[0]
			meta.ArgsLength = len(args) - 1
			e.Args = e.Args[1:]
		}
	}

	/*
	{
		// assert
		typeOf := &Function{}
		buildInFunctionsMap[common.BuildInFunctionAssert] = typeOf
		typeOf.isBuildIn = true
		typeOf.buildInFunctionChecker = func(f Function, e ExpressionFunctionCall, block Block, errs []error,
			args []Type, pos Pos) {
			if len(e.ParameterTypes) > 0 {
				*errs = append(*errs, new error(sprintf("%s buildin function expect no typed parameter",
					errMsgPrefix(e.ParameterTypes[0].pos)))
			}
			if len(args) == 0 {
				err := new error(sprintf("%s '%s' expect one argument at lease",
					pos.errMsgPrefix(), typeOf.name)
				errs.append(err)
				return
			}
			for _, a := range args {
				if a == null {
					continue
				}
				if a.Type != VariableTypeBool {
					err := new error(sprintf("%s not a bool expression",
						errMsgPrefix(pos))
					errs.append(err)
				}
			}
		}
	}*/

	{
		// printf
		buildInFunctionsMap[common.BuildInFunctionPrintf] = new Function()
		buildInFunctionsMap[common.BuildInFunctionPrintf].buildInFunctionChecker = fn(f Function, e ExpressionFunctionCall, block Block, 	errs []error, args []Type, pos Pos) {
				if len(e.ParameterTypes) > 0 {
					errs.append(new error(sprintf("%s buildin function expect no typed parameter",
						errMsgPrefix(e.ParameterTypes[0].pos))))
				}
				meta := new BuildInFunctionPrintfMeta()
				e.BuildInFunctionMeta = meta
				if len(args) == 0 {
					err := new error(sprintf("%s '%s' expect one argument at least",
						pos.errMsgPrefix(), common.BuildInFunctionPrintf) )
					errs.append(err)
					return
				}
				if args[0] == null {
					return
				}
				if len(args) == 0 {
					err := new error(sprintf("%s missing format argument",
						errMsgPrefix(pos)))
					errs.append(err)
					return
				}
				if args[0] == null {
					return
				}
				if args[0].Type != VariableTypeString {
					err := new error(sprintf("%s format must be string",
						errMsgPrefix(pos)))
					errs.append(err)
					return
				}
				_, err := e.Args[0].mustBeOneValueContext(e.Args[0].multiValues)
				if err != null {
					errs.append(err)
					return
				}
				meta.Format = e.Args[0]
				e.Args = e.Args[1:]
				meta.ArgsLength = len(args)
			}
		
	}

	/*
	buildInFunctionsMap[common.BuildInFunctionBlockHole] = &Function{
		buildInFunctionChecker: func(f Function, e ExpressionFunctionCall, block Block, errs []error,
			args []Type, pos Pos) {
		},
		isBuildIn: true,
	}
	*/
	for k, v := range buildInFunctionsMap {
		v.name = k
		v.isBuildIn = true
	}
}





/*
fn monitorChecker(f Function, e ExpressionFunctionCall, block Block, errs []error,
	args []Type, pos Pos) {
	if len(e.ParameterTypes) > 0 {
		*errs = append(*errs, new error(sprintf("%s buildin function expect no typed parameter",
			errMsgPrefix(e.ParameterTypes[0].pos)))
	}
	if len(e.Args) == 0 {
		*errs = append(*errs, new error(sprintf("%s expect one argument", errMsgPrefix(pos)))
		return
	}
	if len(e.Args) > 1 {
		*errs = append(*errs, new error(sprintf("%s only expect one argument", errMsgPrefix(e.Args[1].pos)))
		return
	}
	if args[0] == null {
		return
	}
	if args[0].isPointer() == false {
		*errs = append(*errs, new error(sprintf("%s '%s' is not valid type to call",
			errMsgPrefix(args[0].pos), args[0].typeString()))
		return
	}
}
*/