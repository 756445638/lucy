import "lucy/cmd/langtools/compile/jvm/cg"


public class StatementSwitchCase  {
	public matches []Expression
	public block   Block
	public inlineComment string 
}

public class StatementSwitch  {
	public prefixExpressions    []Expression
	initExpressionBlock  Block = new Block() 
	public pos                  Pos
	public EndPos               Pos
	public condition            Expression //switch
	public StatementSwitchCases []StatementSwitchCase
	public Default              Block
	public exits                []cg.Exit
	public inlineComment string 
	public defaultInlineComment string 
	
	fn check(block Block) ->(errs []error = []error{})  {
		if this.condition == null { // must be a error at parse stage
			return errs
		}
		this.initExpressionBlock.inherit(block)
		for _, v := range this.prefixExpressions {
			v.isStatementExpression = true
			_, es := v.check(this.initExpressionBlock)
			errs.appendAll(es)
			if err := v.canBeUsedAsStatement(); err != null {
				errs.append(err)
			}
		}
		if this.condition == null {
			return errs
		}
		conditionType, es := this.condition.checkSingleValueContextExpression(this.initExpressionBlock)
		errs.appendAll(es)
		if conditionType == null {
			return errs
		}
		if err := conditionType.isTyped(); err != null {
			errs.append(err)
			return errs
		}
		if conditionType.Type == VariableTypeBool {
			errs.append(new error(sprintf("%s bool expression not allow for switch",
				conditionType.pos.errMsgPrefix())))
			return errs
		}
		if len(this.StatementSwitchCases) == 0 {
			errs.append(new error(sprintf("%s switch statement has no cases",
				this.EndPos.errMsgPrefix())))
			return errs
		}
		longMap :=  new map { long -> Pos } ()
		doubleMap := new map { double -> Pos }()
		stringMap := new map{ string -> Pos }()
		enumNamesMap := new map {string -> Pos }()
		enumPackageName := ""
		var longValue long
		var doubleValue double
		var stringValue string
		var enumName string
		for _, v := range this.StatementSwitchCases {
			for _, e := range v.matches {
				valueValid := false
				t, es := e.checkSingleValueContextExpression(this.initExpressionBlock)
				errs.appendAll(es)
				if t == null {
					continue
				}
				if t.Type == VariableTypeBool { // bool condition
					continue
				}
				if conditionType.assignAble(errs, t) == false {
					errs.append(new error(sprintf("%s cannot use '%s' as '%s'",
						e.pos.errMsgPrefix(), t.typeString(), conditionType.typeString())))
					continue
				}
				if conditionType.Type == VariableTypeEnum {
					if t.enumName == null {
						errs.append(new error(sprintf("%s enum value is not literal",
							errMsgPrefix(e.pos))))
						continue
					} else {
						if e.value.Type == VariableTypePackage &&
							enumPackageName == "" {
							enumPackageName = e.value.Package.name
						}
						enumName = t.enumName.name
						valueValid = true
					}
				}
				if conditionType.isPrimitive() {
					if e.isLiteral() {
						switch e.Type {
						case ExpressionTypeByte , ExpressionTypeShort,
							ExpressionTypeChar,ExpressionTypeInt , ExpressionTypeLong:
							longValue = e.longValue
						case ExpressionTypeFloat , ExpressionTypeDouble:
							doubleValue = e.doubleValue
						case ExpressionTypeString:
							stringValue = e.stringValue
						default:
						}
						valueValid = true
					} else {
						errs.append(new error(sprintf("%s expression is not literal",
							errMsgPrefix(e.pos))))
						continue
					}
				}
				if err := e.canBeUsedAsCondition(); err != null {
					errs.append(err)
					continue
				}
				if valueValid {
					fn errMsg(first Pos, which string) -> (err error) {
						errMsg := sprintf("%s  '%s' duplicate case,first declared at:\n",
							e.pos.errMsgPrefix(), which)
						errMsg += sprintf("\t%s", first.errMsgPrefix())
						return new error(errMsg)
					}
					switch conditionType.Type {
					case VariableTypeByte , VariableTypeShort ,VariableTypeChar ,  VariableTypeInt , VariableTypeLong:
						if first := longMap[longValue]; first != null {
							errs.append(errMsg(first, longValue + ""))
							continue // no check body
						} else {
							longMap[longValue] = e.pos
						}
					case VariableTypeDouble:
						if first := doubleMap[doubleValue]; first != null {
							errs.append( errMsg(first, doubleValue + ""))
							continue // no check body
						} else {
							doubleMap[doubleValue] = e.pos
						}
					case VariableTypeString:
						if first := stringMap[stringValue]; first != null {
							errs . append( errMsg(first, stringValue ))
							continue // no check body
						} else {
							stringMap[stringValue] = e.pos
						}
					case VariableTypeEnum:
						if first := enumNamesMap[enumName]; first != null {
							errs . append(errMsg(first, enumName))
							continue // no check body
						} else {
							enumNamesMap[enumName] = e.pos
						}
					default:
					}
				}
			}
			if v.block != null {
				v.block.inherit(this.initExpressionBlock)
				v.block.inheritedAttribute.forBreak = this
				errs.appendAll(v.block.check())
			}
		}
		if this.Default != null {
			this.Default.inherit(this.initExpressionBlock)
			this.Default.inheritedAttribute.forBreak = this
			errs.appendAll(this.Default.check())
		}
		/*
		if conditionType.Type == VariableTypeEnum &&
			len(enumNamesMap) < len(conditionType.Enum.enums) &&
			this.Default == null &&
			containsBool == false {
			//some enum are missing, not allow
			errMsg := sprintf("%s switch for enum '%s' is not complete\n",
				this.EndPos.errMsgPrefix(), conditionType.Enum.name)
			errMsg += "\tyou can use 'default:' or give missing enums,which are:\n"
			for _, v := range conditionType.Enum.enums {
				ok := enumNamesMap.keyExist(v.name)
				if ok {
					//handled
					continue
				}
				if enumPackageName == "" {
					errMsg += sprintf("\t\tcase %s:\n", v.name)
				} else {
					errMsg += sprintf("\t\tcase %s.%s:\n", enumPackageName, v.name)
				}
			}
			errs.append(new error(errMsg))
		}*/
		return errs
	}	
}



