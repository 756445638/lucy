 
class StatementSwitchCase  {
	Matches []Expression
	Block   Block
}

class StatementSwitch  {
	PrefixExpressions    []Expression
	initExpressionBlock  Block = new Block() 
	Pos                  Pos
	EndPos               Pos
	Condition            Expression //switch
	StatementSwitchCases []StatementSwitchCase
	Default              Block
	Exits                []cg.Exit

	fn check(block Block) ->(errs []error = []error{})  {
		if this.Condition == null { // must be a error at parse stage
			return errs
		}
		this.initExpressionBlock.inherit(block)
		for _, v := range this.PrefixExpressions {
			v.IsStatementExpression = true
			_, es := v.check(&this.initExpressionBlock)
			errs.appendAll(es)
			if err := v.canBeUsedAsStatement(); err != null {
				errs.append(err)
			}
		}
		if this.Condition == null {
			return errs
		}
		conditionType, es := this.Condition.checkSingleValueContextExpression(&this.initExpressionBlock)
		errs.appendAll(es)
		if conditionType == null {
			return errs
		}
		if err := conditionType.isTyped(); err != null {
			errs.append(err)
			return errs
		}
		if conditionType.Type == VariableTypeBool {
			errs.append(new error(sprintf("%s bool expression not allow for switch",
				conditionType.Pos.ErrMsgPrefix())))
			return errs
		}
		if len(this.StatementSwitchCases) == 0 {
			errs.append(new error(sprintf("%s switch statement has no cases",
				this.EndPos.ErrMsgPrefix())))
			return errs
		}
		longMap :=  new map { int64 -> Pos } ()  
		floatMap := new map { float32 -> Pos } ()
		doubleMap := new map { float64 -> Pos }()
		stringMap := new map{ string -> Pos }()
		enumNamesMap := new map {string -> Pos }()
		enumPackageName := ""
		var longValue int64
		var floatValue float32
		var doubleValue float64
		var stringValue string
		var enumName string
		containsBool := false
		for _, v := range this.StatementSwitchCases {
			for _, e := range v.Matches {
				valueValid := false
				t, es := e.checkSingleValueContextExpression(&this.initExpressionBlock)
				errs.appendAll(es)
				if t == null {
					continue
				}
				if t.Type == VariableTypeBool { // bool condition
					containsBool = true
					continue
				}
				if conditionType.assignAble(errs, t) == false {
					errs = append(errs, fmt.Errorf("%s cannot use '%s' as '%s'",
						e.Pos.ErrMsgPrefix(), t.TypeString(), conditionType.TypeString()))
					continue
				}
				if conditionType.Type == VariableTypeEnum {
					if t.EnumName == null {
						errs = append(errs, fmt.Errorf("%s enum value is not literal",
							errMsgPrefix(e.Pos)))
						continue
					} else {
						if e.Value.Type == VariableTypePackage &&
							enumPackageName == "" {
							enumPackageName = e.Value.Package.Name
						}
						enumName = t.EnumName.Name
						valueValid = true
					}
				}
				if conditionType.IsPrimitive() {
					if e.isLiteral() {
						switch e.Type {
						case ExpressionTypeByte:
							fallthrough
						case ExpressionTypeShort:
							fallthrough
						case ExpressionTypeChar:
							fallthrough
						case ExpressionTypeInt:
							fallthrough
						case ExpressionTypeLong:
							longValue = e.Data.(int64)
						case ExpressionTypeFloat:
							floatValue = e.Data.(float32)
						case ExpressionTypeDouble:
							doubleValue = e.Data.(float64)
						case ExpressionTypeString:
							stringValue = e.Data.(string)
						}
						valueValid = true
					} else {
						errs.append(new error(sprintf("%s expression is not literal",
							errMsgPrefix(e.Pos))))
						continue
					}
				}
				if err := e.canBeUsedAsCondition(); err != null {
					errs.append(err)
					continue
				}
				if valueValid {
					fn errMsg(first Pos, which string) error {
						errMsg := fmt.Sprintf("%s  '%s' duplicate case,first declared at:\n",
							e.Pos.ErrMsgPrefix(), which)
						errMsg += fmt.Sprintf("\t%s", first.ErrMsgPrefix())
						return errors.New(errMsg)
					}
					switch conditionType.Type {
					case VariableTypeByte:
						fallthrough
					case VariableTypeShort:
						fallthrough
					case VariableTypeChar:
						fallthrough
					case VariableTypeInt:
						fallthrough
					case VariableTypeLong:
						if first, ok := longMap[longValue]; ok {
							errs . append(errMsg(first, longValue + ""))
							continue // no check body
						} else {
							longMap[longValue] = e.Pos
						}
					case VariableTypeFloat:
						if first, found := floatMap[floatValue]; found {
							errs . append(errMsg(first, floatValue + ""))
							continue // no check body
						} else {
							floatMap[floatValue] = e.Pos
						}
					case VariableTypeDouble:
						if first, found := doubleMap[doubleValue]; found {
							errs . append( errMsg(first, doubleValue + ""))
							continue // no check body
						} else {
							doubleMap[doubleValue] = e.Pos
						}
					case VariableTypeString:
						if first, ok := stringMap[stringValue]; ok {
							errs . append( errMsg(first, stringValue ))
							continue // no check body
						} else {
							stringMap[stringValue] = e.Pos
						}
					case VariableTypeEnum:
						if first, ok := enumNamesMap[enumName]; ok {
							errs . append(errMsg(first, enumName))
							continue // no check body
						} else {
							enumNamesMap[enumName] = e.Pos
						}
					}
				}
			}
			if v.Block != null {
				v.Block.inherit(&this.initExpressionBlock)
				v.Block.InheritedAttribute.ForBreak = this
				errs = append(errs, v.Block.check()...)
			}
		}
		if this.Default != null {
			this.Default.inherit(&this.initExpressionBlock)
			this.Default.InheritedAttribute.ForBreak = this
			errs = append(errs, this.Default.check()...)
		}
		if conditionType.Type == VariableTypeEnum &&
			len(enumNamesMap) < len(conditionType.Enum.Enums) &&
			this.Default == null &&
			containsBool == false {
			//some enum are missing, not allow
			errMsg := sprintf("%s switch for enum '%s' is not complete\n",
				this.EndPos.ErrMsgPrefix(), conditionType.Enum.Name)
			errMsg += "\tyou can use 'default:' or give missing enums,which are:\n"
			for _, v := range conditionType.Enum.Enums {
				_, ok := enumNamesMap[v.Name]
				if ok {
					//handled
					continue
				}
				if enumPackageName == "" {
					errMsg += sprintf("\t\tcase %s:\n", v.Name)
				} else {
					errMsg += sprintf("\t\tcase %s.%s:\n", enumPackageName, v.Name)
				}
			}
			errs.append(new error(errMsg))
		}
		return errs
	}	
}



