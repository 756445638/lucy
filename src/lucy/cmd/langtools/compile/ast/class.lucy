import "lucy/cmd/langtools/compile/jvm/cg" 
import "java/lang/Object"
import "lucy/cmd/langtools/compile/common"


/*
	public abstract final class {}
	unlike function class not accept capture
*/
public class Class {
	public isGlobal                          bool
	public isBuildIn                         bool
	public used                              bool
	resolveFatherCalled               bool
	loadSuperClassCalled              bool
	resolveInterfacesCalled           bool
	resolveFieldsAndMethodsTypeCalled bool
	public notImportedYet                    bool   // not imported
	public name                              string // binary name
	public pos                               Pos
	public finalPos                          Pos // final pos
	public isJava                            bool //class imported from CLASSPATH
	public block                             Block
	public accessFlags                       char
	public fields                            map { string -> ClassField }
	public methods                           map { string -> []ClassMethod }
	public superClassName                    NameWithPos
	public superClass                        Class
	public interfaceNames                    []NameWithPos
	public interfaces                        []Class
	public loadFromOutSide                   bool
	public staticBlocks                      []Block
	public comment                           string
	closure                           Closure


    fn HaveStaticsCodes() -> (is bool)  {
        return len(this.staticBlocks) > 0
    }

    public fn IsInterface() -> (is bool)  {
        return this.accessFlags&cg.AccClassInterface != 0
    }
    public fn IsAbstract() -> (is bool)  {
        return this.accessFlags&cg.AccClassAbstract != 0
    }
    fn IsFinal() -> (is bool)  {
        return this.accessFlags&cg.AccClassFinal != 0
    }
    fn isPublic() -> (is bool)  {
        return this.accessFlags&cg.AccClassPublic != 0
    }
    
    fn loadSelf(pos Pos) -> (err error) {
        if this.notImportedYet == false { // current compile class
            return null
        }
        this.notImportedYet = false
        load, err := PackageBeenCompile.loadClass(this.name)
        if err != null {
            return new error(sprintf("%s %s", pos.ErrMsgPrefix(), err.getMessage()))
        }
		this.accessFlags = load.accessFlags
		this.fields = load.fields
		this.methods = load.methods
		this.superClass = load.superClass
		this.interfaces = load.interfaces
        return null
    }

    fn mkDefaultConstruction() {
        if this.IsInterface() {
            return
        }
        if this.methods == null {
            this.methods = new map { string -> []ClassMethod } ( )
        }
        if len(this.methods[SpecialMethodInit]) > 0 {
            return
        }
        m := new ClassMethod()
        m.IsCompilerAuto = true
        m.Function = new Function()
        m.Function.accessFlags |= cg.AccMethodPublic
        m.Function.pos = this.pos
        m.Function.block.isFunctionBlock = true
        m.Function.block.Fn = m.Function
        m.Function.name = SpecialMethodInit
        {
            e := new Expression()
            e.op = "methodCall"
            e.Type = ExpressionTypeMethodCall
            e.pos = this.pos
            call := new ExpressionMethodCall()
            call.name = SUPER
            {
                t := new Expression()
                t.Type = ExpressionTypeIdentifier
                t.pos = this.pos
                t.op = "methodCall"
                t2 := new ExpressionIdentifier()
                t2.name = ThisPointerName
                call.Expression = t
            }
            e.data = call
            m.Function.block.statements = new []Statement(1)
            {
                t := new Statement()
                t.Type = StatementTypeExpression
                t.Expression = e
                m.Function.block.statements[0] = t
            }
        }
        this.methods[SpecialMethodInit] = []ClassMethod{m}
    }

    fn mkClassInitMethod() {
        if this.HaveStaticsCodes() == false {
            return
        }
        method := new ClassMethod()
        method.Function = new Function()
        method.Function.Type.ParameterList = new []Variable( 0)
        method.Function.Type.ReturnList =  new []Variable( 0)
        f := method.Function
        f.pos = this.pos
        f.block.statements =new []Statement ( len(this.staticBlocks))
        for k, _ := range f.block.statements {
            s := new Statement()
            s.Type = StatementTypeBlock
            s.block = this.staticBlocks[k]
            f.block.statements[k] = s
        }
        f.makeLastReturnStatement()
        f.accessFlags |= cg.AccMethodPublic
        f.accessFlags |= cg.AccMethodStatic
        f.accessFlags |= cg.AccMethodFinal
        f.accessFlags |= cg.AccMethodBridge
        f.name = classInitMethod
        f.block.isFunctionBlock = true
        f.block.Fn = method.Function
        if this.methods == null {
            this.methods = new map { string -> []ClassMethod } ()
        }
        f.block.inherit(this.block)
        f.block.inheritedAttribute.Function = f
        f.block.inheritedAttribute.classMethod = method
        this.methods[f.name] = []ClassMethod{method}
    }

    fn resolveFieldsAndMethodsType()-> (errs []error = []error{}){
        if this.resolveFieldsAndMethodsTypeCalled {
            return []error{}
        }
        this.resolveFieldsAndMethodsTypeCalled = true
        var err error
        for _, v := range this.fields {
            if v.name == SUPER {
                errs.append(new error(sprintf("%s 'super' not allow for field name",
                    errMsgPrefix(v.pos))))
                continue
            }
            err = v.Type.resolve(this.block)
            if err != null {
                errs.append(err)
            }
        }
        for _, ms := range this.methods {
            for _, m := range ms {
                if m.IsAbstract() {
                    for _, v := range m.Function.Type.ParameterList {
                        if v.defaultValueExpression != null {
                            errs.append( new error(sprintf("%s abstract method parameter '%s' cannot have default value '%s'",
                                    errMsgPrefix(v.pos), v.name, v.defaultValueExpression.op)))
                        }
                    }
                    for _, v := range m.Function.Type.ReturnList {
                        if v.defaultValueExpression != null {
                            errs.append(new error(sprintf("%s abstract method return variable '%s' cannot have default value '%s'",
                                    errMsgPrefix(v.pos), v.name, v.defaultValueExpression.op)))
                        }
                    }
                }
                m.Function.block.inherit(this.block)
                m.Function.block.inheritedAttribute.Function = m.Function
                m.Function.block.inheritedAttribute.classMethod = m
                m.Function.checkParametersAndReturns(errs, false, m.IsAbstract())
                if len(m.Function.Type.TemplateNames) > 0 {
                    errs.append(new error(sprintf("%s cannot use template for method",
                        errMsgPrefix(m.Function.pos))))
                }
                if m.IsStatic() == false { // bind this
                    if m.Function.block.Variables == null {
                        m.Function.block.Variables = new map { string-> Variable } ()
                    }
                    m.Function.block.Variables[ThisPointerName] = new Variable()
                    m.Function.block.Variables[ThisPointerName].name = ThisPointerName
                    m.Function.block.Variables[ThisPointerName].pos = m.Function.pos
                    {
                        t := new Type()
                        t.Type = VariableTypeObject
                        t.Class = this
                        m.Function.block.Variables[ThisPointerName].Type = t
                    }
                }
            }
        }
        return errs
    }

    fn resolveFather() -> (err error) {
        if this.resolveFatherCalled {
            return null
        }
        this.resolveFatherCalled = true
        if this.superClassName == null {
            superClassName := ""
            if PackageBeenCompile.name == common.CorePackage {
                superClassName = JavaRootClass
            } else {
                if this.IsInterface() {
                    superClassName = JavaRootClass
                } else {
                    superClassName = LucyRootClass
                }
            }
            {
                t := new Class()
                t.name = superClassName
                t.notImportedYet = true
                this.superClass = t
            }
        } else {
            variableType := new Type()
            variableType.Type = VariableTypeName // naming
            variableType.name = this.superClassName.name
            variableType.pos = this.superClassName.pos
            err := variableType.resolve(this.block)
            if err != null {
                return err
            }
            if variableType.Type != VariableTypeObject {
                err := new error(sprintf("%s '%s' is not a class",
                    this.pos.ErrMsgPrefix(), this.superClassName.name))
                return err
            }
            this.superClass = variableType.Class
            if this.IsInterface() {
                if this.superClass.name != JavaRootClass {
                    err := new error(sprintf("%s interface`s super-class must be '%s'",
                        errMsgPrefix(this.superClassName.pos), JavaRootClass))

                    return err
                }
            }
        }
        return null
    }

    fn resolveInterfaces()-> (errs []error = []error{}){
        if this.resolveInterfacesCalled {
            return null
        }
        this.resolveInterfacesCalled = true
        this.interfaces = []Class{}
        for _, i := range this.interfaceNames {
            t := new Type()
            t.Type = VariableTypeName
            t.pos = i.pos
            t.name = i.name
            err := t.resolve(this.block)
            if err != null {
                errs.append(err)
                continue
            }
            if t.Type != VariableTypeObject {
                errs.append(new error(sprintf("%s '%s' is not a object , but '%s'",
                    errMsgPrefix(i.pos), i.name, t.typeString())))
                continue
            }
            if t.Class.IsInterface() == false {
                errs.append(new error(sprintf("%s '%s' is not a interface",
                    errMsgPrefix(i.pos), i.name)))
                continue
            }
            this.interfaces.append(t.Class)
        }
        return errs
    }

    fn implementMethod(
        pos Pos,
        m ClassMethod,
        nameMatched []ClassMethod,
        fromSub bool,
        errs []error) ->(method ClassMethod) {
        if this.methods != null {
            for _, v := range this.methods[m.Function.name] {
                if v.IsAbstract() {
                    continue
                }
                if fromSub && v.ableAccessFromSubClass() == false {
                    return null
                }
                if nameMatched == null {
                    nameMatched[0] = v
                }
                if v.Function.Type.equal(m.Function.Type) {
                    return v
                }
            }
        }
        //no same name method at current class
        if this.name == JavaRootClass {
            return null
        }
        err := this.loadSuperClass(pos)
        if err != null {
            errs.append(err)
            return null
        }

        if this.superClass == null {
            return null
        }

        return this.superClass.implementMethod(pos, m, nameMatched, true, errs)
    }

    fn haveSuperClass(pos Pos, superclassName string) -> (have bool,err  error) {
        err = this.loadSelf(pos)
        if err != null {
            return false, err
        }
        if this.name == superclassName {
            return true, null
        }
        if this.name == JavaRootClass {
            return false, null
        }

        err = this.loadSuperClass(pos)
        if err != null {
            return false, err
        }

        if this.superClass == null {
            return false, null
        }

        return this.superClass.haveSuperClass(pos, superclassName) // check father is implements
    }

    fn implementedInterface(pos Pos, inter string) -> (implemented bool,err  error) {
        err = this.loadSelf(pos)
        if err != null {
            return false, err
        }
        for _, v := range this.interfaces {
            if v.name == inter {
                return true, null
            }
            im, _ := v.implementedInterface(pos, inter)
            if im {
                return im, null
            }
        }
        if this.name == JavaRootClass {
            return false, null
        }
        err = this.loadSuperClass(pos)
        if err != null {
            return false, err
        }
        if this.superClass == null {
            return false, null
        }
        return this.superClass.implementedInterface(pos, inter) // check father is implements
    }

    fn loadSuperClass(pos Pos) -> (err error) {
        if this.superClass != null {
            return this.superClass.loadSelf(pos)
        }
        if this.resolveFatherCalled ||
            this.loadSuperClassCalled {
            return null
        }
        this.loadSuperClassCalled = true
        if this.name == JavaRootClass {
            err := new error(sprintf("%s root class already", errMsgPrefix(pos)))
            return err
        }
        if this.superClassName == null {
            this.superClassName = new NameWithPos(JavaRootClass ,this.pos )
        }
        c, err := PackageBeenCompile.loadClass(this.superClassName.name)
        if err != null {
            err := new error(sprintf("%s %s", pos.ErrMsgPrefix(), err.getMessage()))
            return err
        }
        this.superClass = c
        return null
    }

    fn accessConstructionMethod(
        pos Pos,
        errs []error,
        newCase ExpressionNew,
        callFatherCase ExpressionMethodCall,
        callArgs []Type) -> (ms []ClassMethod = []ClassMethod {} , matched bool, err error) {
        err = this.loadSelf(pos)
        if err != null {
            return null, false, err
        }
        var args []Expression
        if newCase != null {
            args = newCase.Args
        } else {
            args = callFatherCase.Args
        }
        for _, v := range this.methods[SpecialMethodInit] {
            vArgs, err := v.Function.Type.fitArgs(pos, args, callArgs, v.Function)
            if err == null {
                if newCase != null {
                    newCase.VArgs = vArgs
                } else {
                    callFatherCase.VArgs = vArgs
                }
                return []ClassMethod{v}, true, null
            } else {
                if this.isJava {
                    ms.append(v)
                } else {
                    return null, false, err
                }
            }
        }
        return ms, false, null
    }

    /*
        ret is *ClassField or *ClassMethod
    */
    fn getFieldOrMethod(
        pos Pos,
        name string,
        fromSub bool) -> (f Object,err error) {
        err = this.loadSelf(pos)
        if err != null {
            return null, err
        }
        notFoundErr := new error(sprintf("%s field or method named '%s' not found", pos.ErrMsgPrefix(), name))
        if this.fields != null && null != this.fields[name] {
            if fromSub && this.fields[name].ableAccessFromSubClass() == false {
                // private field
                // break find
                return null, notFoundErr
            } else {
                return this.fields[name], null
            }
        }
        if this.methods != null && null != this.methods[name] {
            m := this.methods[name][0]
            if fromSub && m.ableAccessFromSubClass() == false {
                return null, notFoundErr
            } else {
                return m, null
            }
        }
        if this.name == JavaRootClass { // root class
            return null, notFoundErr
        }
        err = this.loadSuperClass(pos)
        if err != null {
            return null, err
        }
        if this.superClass == null {
            return null, notFoundErr
        }
        return this.superClass.getFieldOrMethod(pos, name, true)
    }

    fn constructionMethodAccessAble(pos Pos, method ClassMethod) -> (err error) {
        if this.loadFromOutSide {
            if this.isPublic() == false {
                return new error(sprintf("%s class '%s' is not public",
                    pos.ErrMsgPrefix(), this.name))
            }
            if method.isPublic() == false {
                return new error(sprintf("%s method '%s' is not public",
                    pos.ErrMsgPrefix(), method.Function.name))
            }
        } else {
            if method.IsPrivate() {
                return new error(sprintf("%s method '%s' is private",
                    pos.ErrMsgPrefix(), method.Function.name))
            }
        }
        return null
    }

    fn getField(pos Pos, name string, fromSub bool) -> (f ClassField,err  error) {
            err = this.loadSelf(pos)
            if err != null {
                return null, err
            }
            notFoundErr := new error(sprintf("%s field named '%s' not found",
                pos.ErrMsgPrefix(), name))
            if this.fields != null && null != this.fields[name] {
                if fromSub && this.fields[name].ableAccessFromSubClass() == false {
                    // private field
                    return null, notFoundErr
                } else {
                    return this.fields[name], null
                }
            }
            if this.name == JavaRootClass { // root class
                return null, notFoundErr
            }
            err = this.loadSuperClass(pos)
            if err != null {
                return null, err
            }
            if this.superClass == null {
                return null, notFoundErr
            }
            return this.superClass.getField(pos, name, true)
    }





    fn accessInterfaceObjectMethod(
        pos Pos,
        errs []error,
        name string,
        call ExpressionMethodCall,
        callArgTypes []Type,
        fromSub bool) -> (ms []ClassMethod, matched bool, err error) {
        ms, matched, err = this.accessInterfaceMethod(pos, errs, name, call, callArgTypes, fromSub)
        if err != null {
            return null, false, err
        }
        if matched {
            return ms, matched, err
        }
        err = this.loadSuperClass(pos)
        if err != null {
            return null, false, err
        }
        if this.superClass == null {
            return null, false, null
        }
        return this.superClass.accessMethod(pos, errs, call, callArgTypes, fromSub, null)
    }

    fn accessInterfaceMethod(
        pos Pos,
        errs []error,
        name string,
        call ExpressionMethodCall,
        callArgTypes []Type,
        fromSub bool) -> (ms []ClassMethod, matched bool, err error) {
        err = this.loadSelf(pos)
        if err != null {
            return null, false, err
        }
        if null != this.methods {
            for _, m := range this.methods[name] {
                if fromSub && m.ableAccessFromSubClass() == false {
                    continue
                }
                call.VArgs, err = m.Function.Type.fitArgs(pos, call.Args, callArgTypes, null)
                if err == null {
                    return []ClassMethod{m}, true, null
                } else {
                    return null, false, err
                }
            }
        }
        for _, v := range this.interfaces {
            err := v.loadSelf(pos)
            if err != null {
                return null, false, err
            }
            ms2, matched2, err2 := v.accessInterfaceMethod(pos, errs, name, call, callArgTypes, true)
            if err2 != null {
                return null, false, err2
            }
            if matched {
                return ms2, matched2, null
            }
        }
        return null, false, null // no found , no error
    }

    /*
        access method lucy style
    */
    fn accessMethod(
        pos Pos,
        errs []error,
        call ExpressionMethodCall,
        callArgTypes []Type,
        fromSub bool,
        fieldMethodHandler []ClassField) -> (ms []ClassMethod, matched bool, err error) {
        err = this.loadSelf(pos)
        if err != null {
            return null, false, err
        }
        if this.isJava {
            return this.accessMethodAsJava(pos, errs, call, callArgTypes, false)
        }
        if this.fields != null {
            if f := this.fields[call.name]; f != null &&
                f.Type.Type == VariableTypeFunction &&
                fieldMethodHandler != null {
                if fromSub && f.ableAccessFromSubClass() == false {
                    //cannot access this field
                } else {
                    call.VArgs, err = this.fields[call.name].Type.functionType.fitArgs(pos, call.Args,
                        callArgTypes, null)
                    if err == null {
                        fieldMethodHandler[0] = f
                        matched = true
                        return
                    } else {
                        return null, false, err
                    }
                }
            }
        }
        if this.methods != null {
            if len(this.methods[call.name]) > 0 {
                for _, m := range this.methods[call.name] {
                    if fromSub && m.ableAccessFromSubClass() == false {
                        return null, false, new error(sprintf("%s method '%s' not found",
                            pos.ErrMsgPrefix(), call.name))
                    }
                    call.VArgs, err = m.Function.Type.fitArgs(pos, call.Args,
                        callArgTypes, m.Function)
                    if err == null {
                        return []ClassMethod{m}, true, null
                    } else {
                        return []ClassMethod{m}, false, err
                    }
                }
            }
        }

        err = this.loadSuperClass(pos)
        if err != null {
            return ms, false, err
        }
        if this.superClass == null {
            return ms, false, null
        }
        return this.superClass.accessMethod(pos, errs, call,
            callArgTypes, true, fieldMethodHandler)
    }

    /*
        access method java style
    */
    fn accessMethodAsJava(
        pos Pos,
        errs []error,
        call ExpressionMethodCall,
        callArgTypes []Type,
        fromSub bool) -> (ms []ClassMethod, matched bool, err error) {
        if this.methods != null {
            for _, m := range this.methods[call.name] {
                if fromSub == true && m.ableAccessFromSubClass() == false {
                    //cannot access from sub
                    continue
                }
                call.VArgs, err = m.Function.Type.fitArgs(pos, call.Args, callArgTypes, m.Function)
                if err == null {
                    return []ClassMethod{m}, true, null
                } else {
                    ms.append(m)
                }
            }
        }
        if this.name == JavaRootClass {
            return ms, false, null
        }
        err = this.loadSuperClass(pos)
        if err != null {
            return null, false, err
        }
        if this.superClass == null {
            return ms, false, null
        }
        ms_, matched, err := this.superClass.accessMethodAsJava(pos, errs, call, callArgTypes, true)
        if err != null {
            return ms, false, err
        }
        if matched { // perfect match in father
            return ms_, matched, null
        }
        ms.appendAll(ms_)
        return ms, false, null // methods have the same name
    }



    fn check(father Block) -> (errs []error = []error{}){
        this.block.inherit(father)
        this.block.inheritedAttribute.Class = this
        errs.appendAll(this.checkPhase1())
        errs.appendAll( this.checkPhase2())
        return errs
    }

    fn checkPhase1()-> (errs []error = []error{}){
        if this.block.inheritedAttribute.classAndFunctionNames == "" {
            this.block.inheritedAttribute.classAndFunctionNames = common.getBaseName(this.name)
        } else {
            this.block.inheritedAttribute.classAndFunctionNames += "$" + common.getBaseName(this.name)
        }
        this.mkDefaultConstruction()
        errs.appendAll(this.block.checkConstants())
        err := this.resolveFather()
        if err != null {
            errs.append(err)
        } else {
            err = this.checkIfClassHierarchyErr()
            if err != null {
                errs.append(err)
            }
        }
        errs.appendAll(this.checkModifierOk())
        errs.appendAll(this.resolveFieldsAndMethodsType())
        return errs
    }

    fn checkPhase2()-> (errs []error = []error{}){
        errs.appendAll(this.checkFields())
        if PackageBeenCompile.shouldStop(errs) {
            return errs
        }
        this.mkClassInitMethod()
        for name, ms := range this.methods {
            if this.fields != null && this.fields[name] != null {
                f := this.fields[name]
                if f.pos.Line < ms[0].Function.pos.Line {
                    errMsg := sprintf("%s method named '%s' already declared as field,at:\n",
                        errMsgPrefix(ms[0].Function.pos), name)
                    errMsg += sprintf("\t%s", errMsgPrefix(f.pos))
                    errs.append(new error(errMsg))
                } else {
                    errMsg := sprintf("%s field named '%s' already declared as method,at:\n",
                        errMsgPrefix(f.pos), name)
                    errMsg += sprintf("\t%s", errMsgPrefix(ms[0].Function.pos))
                    errs.append(new error(errMsg))
                }
                continue
            }
            if len(ms) > 1 {
                errMsg := sprintf("%s class method named '%s' has declared %d times,which are:\n",
                    errMsgPrefix(ms[0].Function.pos),
                    ms[0].Function.name, len(ms))
                for _, v := range ms {
                    errMsg += sprintf("\t%s\n", errMsgPrefix(v.Function.pos))
                }
                errs.append(new error(errMsg))
            }
        }
        errs.appendAll(this.checkMethods())
        if PackageBeenCompile.shouldStop(errs) {
            return errs
        }
        errs.appendAll(this.checkIfOverrideFinalMethod())
        errs.appendAll(this.resolveInterfaces())
        if this.IsInterface() {
            errs.appendAll( this.checkOverrideInterfaceMethod())
        }
        if this.IsAbstract() {
            errs.appendAll( this.checkOverrideAbstractMethod())
        }
        errs.appendAll( this.suitableForInterfaces())
        if this.superClass != null {
            errs.appendAll(this.suitableSubClassForAbstract(this.superClass))
        }
        return errs
    }

    fn suitableSubClassForAbstract(super Class)-> (errs []error = []error{}){
        if super.name != JavaRootClass {
            err := super.loadSuperClass(this.pos)
            if err != null {
                errs.append(err)
                return errs
            }
            if super.superClass == null {
                return errs
            }
            length := len(errs)
            errs.appendAll(this.suitableSubClassForAbstract(super.superClass))
            if len(errs) > length {
                return errs
            }
        }
        if super.IsAbstract() {
            for _, v := range super.methods {
                m := v[0]
                if m.IsAbstract() == false {
                    continue
                }
                nameMatch :=  []ClassMethod {null}
                implementation := this.implementMethod(this.pos, m, nameMatch, false, errs)
                if implementation != null {
                    if err := m.implementationMethodIsOk(this.pos, implementation); err != null {
                        errs.append(err)
                    }
                } else {
                    pos := this.pos
                    if nameMatch[0] != null && nameMatch[0].Function.pos != null {
                        pos = nameMatch[0].Function.pos
                    }
                    if nameMatch[0] != null {
                        errMsg := sprintf("%s method is suitable for abstract super class\n", errMsgPrefix(pos))
                        errMsg += sprintf("\t have %s\n", nameMatch[0].Function.readableMsg())
                        errMsg += sprintf("\t want %s\n", m.Function.readableMsg())
                        errs.append(new error(errMsg))
                    } else {
                        errs.append(new error(sprintf("%s missing implementation method '%s' define on abstract class '%s'",
                                pos.ErrMsgPrefix(), m.Function.readableMsg(), super.name)))
                    }
                }
            }
        }
        return errs
    }

    fn interfaceMethodExists(name string) ->(c Class) {
        if this.IsInterface() == false {
            panic("not a interface")
        }
        if this.methods != null && len(this.methods[name]) > 0 {
            return this
        }
        for _, v := range this.interfaces {
            if v.interfaceMethodExists(name) != null {
                return v
            }
        }
        return null
    }

    fn abstractMethodExists(pos Pos, name string) -> (c Class,err error) {
        if this.IsAbstract() {
            if this.methods != null && len(this.methods[name]) > 0 {
                method := this.methods[name][0]
                if method.IsAbstract() {
                    return this, null
                }
            }
        }
        if this.name == JavaRootClass {
            return null, null
        }
        err = this.loadSuperClass(pos)
        if err != null {
            return null, err
        }
        if this.superClass == null {
            return null, null
        }
        return this.superClass.abstractMethodExists(pos, name)
    }

    fn checkOverrideAbstractMethod()-> (errs []error = []error{}){
        err := this.loadSuperClass(this.pos)
        if err != null {
            errs.append(err)
            return errs
        }
        if this.superClass == null {
            return errs
        }
        for _, v := range this.methods {
            m := v[0]
            name := m.Function.name
            if m.IsAbstract() == false {
                continue
            }
            exist, err := this.superClass.abstractMethodExists(m.Function.pos, name)
            if err != null {
                errs.append(err)
                continue
            }
            if exist != null {
                errs.append(new error(sprintf("%s method '%s' override '%s'",
                    errMsgPrefix(v[0].Function.pos), name, exist.name)))
            }
        }
        return errs
    }

    fn checkOverrideInterfaceMethod()-> (errs []error = []error{}){
        for name, v := range this.methods {
            var exist Class
            for _, vv := range this.interfaces {
                exist = vv.interfaceMethodExists(name)
                if exist != null {
                    break
                }
            }
            if exist != null {
                errs.append(new error(sprintf("%s method '%s' override '%s'",
                    errMsgPrefix(v[0].Function.pos), name, exist.name)))
            }
        }
        return errs
    }

    fn checkIfClassHierarchyErr()-> (err error){
        m := new map { string -> bool}( )
        arr := []string{}
        is := false
        c := this
        pos := this.pos
        if err := this.loadSuperClass(pos); err != null {
            return err
        }
        if this.superClass == null {
            return null
        }

        if this.superClass.IsFinal() {
            return new error(sprintf("%s class name '%s' have super class  named '%s' that is final",
                this.pos.ErrMsgPrefix(), this.name, this.superClass.name))
        }
        for c.name != JavaRootClass {
            ok := m.keyExist(c.name)
            if ok {
                arr.append(c.name)
                is = true
                break
            }
            m[c.name] = true
            arr.append(c.name)
            err := c.loadSuperClass(pos)
            if err != null {
                return err
            }
            if this.superClass == null {
                return null
            }
            c = c.superClass
        }
        if is == false {
            return null
        }
        errMsg := sprintf("%s class named '%s' detects a circularity in class hierarchy",
            this.pos.ErrMsgPrefix(), this.name)
        tab := "\t"
        index := len(arr) - 1
        for index >= 0 {
            errMsg += tab + arr[index] + "\n"
            tab += " "
            index--
        }
        return new error(errMsg)
    }

    fn checkIfOverrideFinalMethod()-> (errs []error = []error{}){
        if this.superClass != null {
            for name, v := range this.methods {
                if name == SpecialMethodInit {
                    continue
                }
                if len(v) == 0 {
                    continue
                }
                if len(this.superClass.methods[name]) == 0 {
                    // this class not found at super
                    continue
                }
                m := v[0]
                for _, v := range this.superClass.methods[name] {
                    if v.IsFinal() == false {
                        continue
                    }
                    f1 := new Type()
                    f1.Type = VariableTypeFunction
                    f1.functionType = m.Function.Type
                    f2 := new Type()
                    f2.Type = VariableTypeFunction
                    f2.functionType = v.Function.Type
                    if f1.equal(f2) {
                        errs.append(new error(sprintf("%s override final method",
                            errMsgPrefix(m.Function.pos))))
                    }
                }
            }
        }
        return errs
    }

    fn suitableForInterfaces()-> (errs []error = []error{}){
        if this.IsInterface() {
            return errs
        }
        for _, i := range this.interfaces {
            errs.appendAll(this.suitableForInterface(i))
        }
        return errs
    }

    fn suitableForInterface(inter Class)-> (errs []error = []error{}){
        err := inter.loadSelf(this.pos)
        if err != null {
            errs.append(err)
            return errs
        }
        for _, v := range inter.methods {
            m := v[0]
            nameMatch := []ClassMethod {null}
            implementation := this.implementMethod(this.pos, m, nameMatch, false, errs)
            if implementation != null {
                if err := m.implementationMethodIsOk(this.pos, implementation); err != null {
                    errs.append(err)
                }
            } else {
                pos := this.pos
                if nameMatch != null && nameMatch[0].Function.pos != null {
                    pos = nameMatch[0].Function.pos
                }
                errs.append(new error(sprintf("%s missing implementation method '%s' define on interface '%s'",
                    pos.ErrMsgPrefix(), m.Function.readableMsg(), inter.name)))
            }
        }
        for _, v := range inter.interfaces {
            es := this.suitableForInterface(v)
            errs.appendAll(es)
        }
        return errs
    }

    fn checkFields()-> (errs []error = []error{}){
        if this.IsInterface() {
            for _, v := range this.fields {
                errs.append(new error(sprintf("%s interface '%s' expect no field named '%s'",
                    errMsgPrefix(v.pos), this.name, v.name)))
            }
            return errs
        }
        staticFieldAssignStatements := []Statement{}
        for _, v := range this.fields {
            if v.defaultValueExpression != null {
                assignment, es := v.defaultValueExpression.
                    checkSingleValueContextExpression(this.methods[SpecialMethodInit][0].Function.block)
                errs.appendAll(es)
                if assignment == null {
                    continue
                }
                if v.Type.assignAble(errs, assignment) == false {
                    errs.append(new error(sprintf("%s cannot assign '%s' as '%s' for default value",
                        errMsgPrefix(v.pos), assignment.typeString(), v.Type.typeString())))
                    continue
                }
                if assignment.Type == VariableTypeNull {
                   errs.append( new error(sprintf("%s pointer types default value is '%s' already",
                        v.pos.ErrMsgPrefix(), assignment.typeString())))
                    continue
                }
                if v.IsStatic() &&
                    v.defaultValueExpression.isLiteral() {
                    v.DefaultValue = v.defaultValueExpression.data
                    continue
                }
                if v.IsStatic() == false {
                    // nothing to do
                    continue
                }
                bin := new ExpressionBinary()
                bin.Right = new Expression()
                bin.Right.Type = ExpressionTypeList
                bin.Right.op =  "list"
                bin.Right.data =  []Expression{v.defaultValueExpression}
                {
                    selection := new ExpressionSelection()
                    selection.Expression = new Expression()
                    selection.Expression.op = "selection"
                    selection.Expression.value = new Type()
                    selection.Expression.value.Type = VariableTypeClass
                    selection.Expression.value.Class = this
                    selection.name = v.name
                    selection.Field = v
                    left := new Expression()
                    left.Type =  ExpressionTypeSelection
                    left.data =  selection
                    left.op =   "selection"
                    left.value = v.Type
                    bin.Left = new Expression()
                    bin.Left.Type = ExpressionTypeList
                    bin.Left.data = []Expression{left}
                }
                e := new Expression()
                e.Type =  ExpressionTypeAssign
                e.data =  bin
                e.isStatementExpression =  true
                e.op =  "assign"
                {
                    t := new Statement()
                    t.Type = StatementTypeExpression
                    t.Expression = e
                    t.isStaticFieldDefaultValue = true
                    staticFieldAssignStatements.append(t)
                }
            }
        }
        if len(staticFieldAssignStatements) > 0 {
            b := new Block()
            b.statements = staticFieldAssignStatements
            if this.staticBlocks != null {
                t := new []Block(1 + len(this.staticBlocks))
                t[0] = b
                for k,v := range this.staticBlocks{
                    t[k+ 1] = b
                }
                this.staticBlocks = t
            } else {
                this.staticBlocks = []Block{b}
            }
        }
        return errs
    }

    fn checkMethods()-> (errs []error = []error{}){
        if this.IsInterface() {
            return errs
        }
        for name, methods := range this.methods {
            for _, method := range methods {
                errs.appendAll( method.checkModifierOk())
                if method.IsAbstract() {
                    //nothing
                } else {
                    if this.IsInterface() {
                        errs.append( new error(sprintf("%s interface method cannot have implementation",
                            errMsgPrefix(method.Function.pos))))
                        continue
                    }
                    errs.appendAll(method.Function.checkReturnVarExpression())
                    isConstruction := name == SpecialMethodInit
                    if isConstruction {
                        if method.IsFirstStatementCallFatherConstruction() == false {
                            errs.append( new error(sprintf("%s construction method should call father construction method first",
                                errMsgPrefix(method.Function.pos))))
                        }
                    }
                    if isConstruction && method.Function.Type.VoidReturn() == false {
                        errs.append( new error(sprintf("%s construction method expect no return values",
                            errMsgPrefix(method.Function.Type.ParameterList[0].pos))))
                    }
                    method.Function.block.inheritedAttribute.isConstructionMethod = isConstruction
                    method.Function.checkBlock(errs)
                }
            }
        }
        return errs
    }

    fn checkModifierOk()-> (errs []error = []error{}){
        if this.IsInterface() && this.IsFinal() {
            errs.append(new error(sprintf("%s interface '%s' cannot be final",
                errMsgPrefix(this.finalPos), this.name)))
        }
        if this.IsAbstract() && this.IsFinal() {
            errs.append(new error(sprintf("%s abstract class '%s' cannot be final",
                errMsgPrefix(this.finalPos), this.name)))
        }
        return errs
    }


}

