import "java/lang/Object"

public enum  VariableTypeKind {
	VariableTypeBool =1 ,
	VariableTypeByte,
	VariableTypeShort,
	VariableTypeChar,
	VariableTypeInt,
	VariableTypeLong,
	VariableTypeFloat,
	VariableTypeDouble,
	//enum 
	VariableTypeEnum,
	//ref types 
	VariableTypeString,
	VariableTypeObject,
	VariableTypeMap,
	VariableTypeArray,
	VariableTypeJavaArray,
	VariableTypeFunction,
	VariableTypeClass,
	VariableTypeName,
	VariableTypeTemplate,
	VariableTypeVoid,
	
	VariableTypePackage,
	VariableTypeNull,
	VariableTypeGlobal,
	VariableTypeDynamicSelector 
}


public class Map {
	public K Type
	public V Type
}

public class Type {
	public Type           VariableTypeKind
	public isBuildIn      bool // build in type alias
	public isVariableArgs bool // int ...
	public resolved       bool
	public pos            Pos
	public name           string
	public array          Type
	public Class          Class
	public Enum           Enum
	public enumName       EnumName // indicate a const
	public Function       Function
	public functionType   FunctionType
	public Map            Map
	public Package        Package
	public alias          TypeAlias
	public locateDefinition  bool 
	public findUsage  bool 
	public rename bool 
	public getHover bool 
	
	// copy to t 
	fn cp(t Type) {
	    t.Type = this.Type
	    t.isBuildIn = this.isBuildIn
	    t.isVariableArgs = this.isVariableArgs
	    t.pos = this.pos
	    t.name = this.name
	    t.array = this.array
	    t.Class = this.Class
	    t.Enum = this.Enum
	    t.enumName = this.enumName
	    t.Function = this.Function
	    t.functionType = this.functionType
	    t.Map = this.Map
	    t.Package = this.Package
	    t.alias = this.alias
	}
	fn validForTypeAssertOrConversion() -> (valid bool) {
		if this.isPointer() == false {
			return false
		}
		return true
		// object or string
		if this.Type == VariableTypeObject || this.Type == VariableTypeString {
			return true
		}
		if this.Type == VariableTypeArray && this.array.isPrimitive() {
			return true
		}
		if this.Type == VariableTypeJavaArray {
			if this.array.isPointer() {
				return this.array.validForTypeAssertOrConversion()
			} else {
				return true
			}
		}
		return false
	}

	fn mkDefaultValueExpression() -> (d Expression) {
		e := new Expression()
		e.op = "defaultValueByCompiler"
		e.isCompileAuto = true
		e.pos = this.pos
		e.value = this.Clone()
		switch this.Type {
		case VariableTypeBool:
			e.Type = ExpressionTypeBool
			e.boolValue = false
		case VariableTypeByte:
			e.Type = ExpressionTypeByte
			e.longValue =  long(0)
		case VariableTypeShort:
			e.Type = ExpressionTypeInt
			e.longValue =  long(0)
		case VariableTypeChar:
			e.Type = ExpressionTypeInt
			e.longValue =  long(0)
		case VariableTypeInt:
			e.Type = ExpressionTypeInt
			e.longValue =  long(0)
		case VariableTypeLong:
			e.Type = ExpressionTypeLong
			e.longValue = long(0)
		case VariableTypeFloat:
			e.Type = ExpressionTypeFloat
			e.doubleValue = double(0)
		case VariableTypeDouble:
			e.Type = ExpressionTypeDouble
			e.doubleValue = double(0)
		case VariableTypeEnum:
			e.Type = ExpressionTypeInt
			e.longValue = long(this.Enum.defaultValue)
		default:
			e.Type = ExpressionTypeNull
		}
		return e
	}

	fn rightValueValid() -> (err error) {
		if this.Type == VariableTypeBool ||
			this.isNumber() ||
			this.Type == VariableTypeString ||
			this.Type == VariableTypeObject ||
			this.Type == VariableTypeArray ||
			this.Type == VariableTypeMap ||
			this.Type == VariableTypeNull ||
			this.Type == VariableTypeJavaArray ||
			this.Type == VariableTypeEnum ||
			this.Type == VariableTypeFunction {
			return null
		}
		switch this.Type {
		case VariableTypePackage:
			return new error(sprintf("%s use package '%s' without selector",
				this.pos.errMsgPrefix(), this.Package.name))
		case VariableTypeClass:
			return new error(sprintf("%s use class '%s' without selector",
				this.pos.errMsgPrefix(), this.Class.name))
		default:
			return new error(sprintf("%s '%s' is not right value valid",
				this.pos.errMsgPrefix(), this.typeString()))
		}
	}

	/*
		have type or not
	*/
	fn isTyped() -> (err error) {
		if err = this.rightValueValid(); err != null {
			return err
		}
		/*
			null is only untyped right value
		*/
		if this.Type == VariableTypeNull {
			return new error(sprintf("%s '%s' is not typed",
				this.pos.errMsgPrefix(), this.typeString()))
		}
		return null
	}

	/*
		deep clone
	*/
	public fn Clone() ->(cloned Type) {
		cloned = new Type()
		cloned.Type = this.Type
		cloned.isBuildIn  = this.isBuildIn
		cloned.isVariableArgs  = this.isVariableArgs
		cloned.resolved      = this.  resolved
		cloned.pos     = this.   pos    
		cloned.name = this.  name                
		cloned.Class  = this. Class        
		cloned.Enum  = this.   Enum       
		cloned.enumName = this. enumName      
		cloned.Function  = this. Function        
		cloned.Package   = this.Package      
		cloned.alias     = this.alias      

		//TODO:: 
		if cloned.Type == VariableTypeArray ||
			cloned.Type == VariableTypeJavaArray {
			cloned.array = this.array.Clone()
		}
		if cloned.Type == VariableTypeMap {
			cloned.Map = new Map()
			cloned.Map.K = this.Map.K.Clone()
			cloned.Map.V = this.Map.V.Clone()
		}
		if this.Type == VariableTypeFunction {
			cloned.functionType = this.functionType.Clone()
		}
	}

	fn resolve(block Block) -> (err error) {
		if this.resolved {
			return null
		}
		if this.locateDefinition {
			block.inheritedAttribute.p.locateDefinition = this.pos 
		}
		this.resolved = true // single threading
		switch this.Type {
		case VariableTypeTemplate:
			if block.inheritedAttribute.Function.parameterTypes == null {
				return new error(sprintf("%s parameter type '%s' not in a template function",
					errMsgPrefix(this.pos), this.name))
			}
			if block.inheritedAttribute.Function.parameterTypes[this.name] == null {
				return new error(sprintf("%s parameter type '%s' not found",
					errMsgPrefix(this.pos), this.name))
			}
			pos := this.pos // keep pos
			if this.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = 
					block.inheritedAttribute.Function.parameterTypes[this.name].pos 
			}
			block.inheritedAttribute.Function.parameterTypes[this.name].cp(this)
			this.pos = pos // keep pos
			return null
		case VariableTypeName:
			return this.resolveName(block)
		case VariableTypeGlobal:
			d, exists := block.inheritedAttribute.p.block.nameExists(this.name , this.pos )
			if exists == false {
				return new error(sprintf("%s '%s' not found",
					errMsgPrefix(this.pos), this.name))
			}
			return this.makeTypeFrom(block , d)
		case VariableTypeArray, VariableTypeJavaArray:
			return this.array.resolve(block)
		case VariableTypeMap:
			if this.Map.K != null {
				err = this.Map.K.resolve(block)
				if err != null {
					return err
				}
			}
			if this.Map.V != null {
				return this.Map.V.resolve(block)
			}
		case VariableTypeFunction:
			for _, v := range this.functionType.parameterList {
				if err = v.Type.resolve(block); err != null {
					return err
				}
			}
			for _, v := range this.functionType.returnList {
				if err = v.Type.resolve(block); err != null {
					return err
				}
			}
		default:
		}
		return null
	}

	fn resolveName(block Block) -> (err error ) {
		var d  Object
		if this.name.indexOf(".")  < 0  {
			var loadFromImport bool
			d = block.searchType(this.name,this.pos)
			if d != null {
				if t, ok := d.(Class); ok &&
					t.isBuildIn == false {
					_, loadFromImport = shouldAccessFromImports(block , this.name, this.pos, t.pos)
				}
				if t, ok := d.(Type); ok &&
						t.isBuildIn == false {
						_, loadFromImport = shouldAccessFromImports(block , this.name, this.pos, t.pos)
				}
				if t, ok := d.(Enum); ok &&
						t.isBuildIn == false {
						_, loadFromImport = shouldAccessFromImports(block , this.name, this.pos, t.pos)
				}
			} else {
				loadFromImport = true
			}
			if loadFromImport {
				d, err = this.getNameFromImport(block)
				if err != null {
					return err
				}
			}
		} else { // a.b  in type situation,must be package name
			d, err = this.getNameFromImport(block)
			if err != null {
				return err
			}
		}
		if d == null {
			return new error(sprintf("%s type named '%s' not found", errMsgPrefix(this.pos), this.name))
		}
		err = this.makeTypeFrom(block , d)
		if err != null {
			return err
		}
		return null
	}

	fn getNameFromImport(block Block) -> (d Object, err error) {
		if this.name.indexOf(".") < 0  {
			i := block.inheritedAttribute.p.getImport(this.pos.filename, this.name)
			if i != null {
				i.used = true
				return loaded.load(i.Import)
			}
			return null, new error(sprintf("%s type named '%s' not found",
				errMsgPrefix(this.pos), this.name))
		}
		index := this.name.indexOf(".")
		packageName := this.name[:index]
		className := this.name[index+1:]
		i := block.inheritedAttribute.p.getImport(this.pos.filename, packageName)
		if null == i {
			return null, new error(sprintf("%s package '%s' not imported",
				errMsgPrefix(this.pos), packageName))
		}
		i.used = true
		p, err := loaded.load(i.Import)
		if err != null {
			return null, new error(sprintf("%s %.getMessage()",
				errMsgPrefix(this.pos), err.getMessage()))
		}
		if pp, ok := p.(Package); ok &&
			pp != null {
			var exists bool
			d, exists = pp.block.nameExists(className , this.pos)
			if exists == false {
				err = new error(sprintf("%s '%s' not found",
					errMsgPrefix(this.pos), className))
			}
			return d, err
		} else {
			return null, new error(sprintf("%s '%s' is not a package",
				errMsgPrefix(this.pos), packageName))
		}
	}

	fn makeTypeFrom(block Block , d Object) -> (err error)  {
		if c ,ok := d.(Class) ; ok{
			if c.loadFromOutSide && c.isPublic() == false {
                err = new error(sprintf("%s class '%s' is not public",
                           errMsgPrefix(this.pos), c.name))
			}
			if this.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = c.pos
			}
			this.Type = VariableTypeObject
			this.Class = c 
			return err
		}
		if t ,ok := d.(Type) ; ok{
			pos := this.pos
			alias := this.alias
			resolved := this.resolved
			t.cp(this)
			if this.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = t.pos
			}
			this.pos = pos
			this.alias = alias
			this.resolved = resolved
			return null
		}
		if dd ,ok:= d.(Enum) ; ok {
			if dd.loadFromOutSide && dd.isPublic() == false {
				block.inheritedAttribute.p.errors.append(
					new error(sprintf("%s enum '%s' is not public",
						errMsgPrefix(this.pos), dd.name)))
			}
			if this.locateDefinition {
				block.inheritedAttribute.p.locateDefinition = dd.pos 
			}
			this.Type = VariableTypeEnum
			this.Enum = dd
			return null
		}
		return new error(sprintf("%s name '%s' is not a type",
			errMsgPrefix(this.pos), this.name))
	}

	public fn isNumber() -> (is bool) {
		return this.isInteger() ||
			this.isFloat()
	}

	public fn isPointer() -> (is bool)  {
		return this.Type == VariableTypeObject ||
			this.Type == VariableTypeArray ||
			this.Type == VariableTypeJavaArray ||
			this.Type == VariableTypeMap ||
			this.Type == VariableTypeString ||
			this.Type == VariableTypeNull ||
			this.Type == VariableTypeFunction
	}

	public fn isInteger() -> (is bool)  {
		return this.Type == VariableTypeByte ||
			this.Type == VariableTypeShort ||
			this.Type == VariableTypeInt ||
			this.Type == VariableTypeLong ||
			this.Type == VariableTypeChar
	}

	/*
		float or double
	*/
	fn isFloat() -> (is bool)  {
		return this.Type == VariableTypeFloat ||
			this.Type == VariableTypeDouble
	}

	public fn isPrimitive() -> (is bool)  {
		return this.isNumber() ||
			this.Type == VariableTypeString ||
			this.Type == VariableTypeBool
	}

	public fn typeString(prefix string = "") ->(ret string) {
		if this.alias != null {
			return prefix + this.alias.name
		}
		switch this.Type {
		case VariableTypeBool:
			return prefix +  "bool"
		case VariableTypeByte:
			return prefix +  "byte"
		case VariableTypeChar:
			return prefix +  "char"
		case VariableTypeShort:
			return prefix +  "short"
		case VariableTypeInt:
			return prefix +  "int"
		case VariableTypeLong:
			return prefix +  "long"
		case VariableTypeFloat:
			return prefix +  "float"
		case VariableTypeDouble:
			return prefix +  "double"
		case VariableTypeString:
			return prefix +  "string"
		case VariableTypeObject: // class name
			return prefix +  "object@" + this.Class.name
		case VariableTypeMap:
			ret =prefix + "map{"
			ret += this.Map.K.typeString()
			ret += " -> "
			ret += this.Map.V.typeString()
			ret += "}"
			return ret 
		case VariableTypeArray:
			return this.array.typeString(prefix + "[]")
		case VariableTypeJavaArray:
			if this.isVariableArgs {
				ret = prefix + this.array.typeString() + "..."
				return ret 
			} else {
				ret = prefix + this.array.typeString() + "[]"
				return ret 
			}
		case VariableTypeFunction:
			ret = prefix + "fn " + this.functionType.typeString()
			return 
		case VariableTypeEnum:
			ret = prefix + "enum(" + this.Enum.name + ")"
		case VariableTypeClass:
			ret = prefix + sprintf("class@%s", this.Class.name)
		case VariableTypeName:
			ret = prefix + this.name // resolve wrong, but typeString is ok to return
		case VariableTypeTemplate:
			ret = prefix + this.name
		case VariableTypeDynamicSelector:
			ret = prefix + "dynamicSelector@" + this.Class.name
		case VariableTypeVoid:
			ret = prefix + "void"
		case VariableTypePackage:
			ret = prefix + "package@" + this.Package.name
		case VariableTypeNull:
			ret = prefix + "null"
		case VariableTypeGlobal:
			ret = prefix + this.name
		}
	}

	fn getParameterType(ft FunctionType) -> (pts []string) {
		if this.Type == VariableTypeName &&
			ft.haveTemplateName(this.name) {
			this.Type = VariableTypeTemplate // convert to type
		}
		if this.Type == VariableTypeTemplate {
			return []string{this.name}
		}
		if this.Type == VariableTypeArray ||
			this.Type == VariableTypeJavaArray {
			return this.array.getParameterType(ft)
		}
		if this.Type == VariableTypeMap {
			pts = []string{}
			pts.appendAll(this.Map.K.getParameterType(ft))
			pts.appendAll( this.Map.V.getParameterType(ft))
			return
		}
		return null
	}

	fn canBeBindWithParameterTypes(parameterTypes map{ string->Type }) -> (err error) {
		if this.Type == VariableTypeTemplate {
			 ok := parameterTypes.keyExist(this.name)
			if ok == false {
				return new error(sprintf("typed parameter '%s' not found", this.name))
			}
			return null
		}
		if this.Type == VariableTypeArray ||
			this.Type == VariableTypeJavaArray {
			return this.array.canBeBindWithParameterTypes(parameterTypes)
		}
		if this.Type == VariableTypeMap {
			err = this.Map.K.canBeBindWithParameterTypes(parameterTypes)
			if err != null {
				return err
			}
			return this.Map.V.canBeBindWithParameterTypes(parameterTypes)
		}
		return null
	}

	/*
		if there is error,this function will crash
	*/
	fn bindWithParameterTypes(ft FunctionType, parameterTypes map{string->Type})  {
		if this.Type == VariableTypeTemplate {
			ok := parameterTypes.keyExist(this.name)
			if ok == false {
				panic(sprintf("typed parameter '%s' not found", this.name))
			}
			//TODO ::
			//*typ = *t.Clone() // real bind
			parameterTypes[this.name].cp(this)
			return 
		}
		if this.Type == VariableTypeArray || this.Type == VariableTypeJavaArray {
			this.array.bindWithParameterTypes(ft, parameterTypes)
			return
		}
		if this.Type == VariableTypeMap {
			if len(this.Map.K.getParameterType(ft)) > 0 {
				this.Map.K.bindWithParameterTypes(ft, parameterTypes) 
			}
			if len(this.Map.V.getParameterType(ft)) > 0 {
				this.Map.V.bindWithParameterTypes(ft, parameterTypes)
				return 
			}
		}
		panic("not T")
	}
	
	/*
		
	 */
	fn canBeBindWithType(ft FunctionType, mkParameterTypes map{string->Type}, bind Type) -> (err error)  {
		if err = bind.rightValueValid(); err != null {
			return err
		}
		if bind.Type == VariableTypeNull {
			return new error(sprintf("'%s' is un typed", bind.typeString()))
		}
		if this.Type == VariableTypeTemplate {
			mkParameterTypes[this.name] = bind
			return null
		}
		if this.Type == VariableTypeArray && bind.Type == VariableTypeArray {
			return this.array.canBeBindWithType(ft, mkParameterTypes, bind.array)
		}
		if this.Type == VariableTypeJavaArray && bind.Type == VariableTypeJavaArray {
			return this.array.canBeBindWithType(ft, mkParameterTypes, bind.array)
		}
		if this.Type == VariableTypeMap && bind.Type == VariableTypeMap {
			if len(this.Map.K.getParameterType(ft)) > 0 {
				err = this.Map.K.canBeBindWithType(ft, mkParameterTypes, bind.Map.K)
				if err != null {
					return err
				}
			}
			if len(this.Map.V.getParameterType(ft)) > 0 {
				return this.Map.V.canBeBindWithType(ft, mkParameterTypes, bind.Map.V)
			}
		}
		return new error(sprintf("cannot bind '%s' to '%s'", bind.typeString(), this.typeString()))
	}

	fn assignAble(errs []error, rightValue Type) ->(able bool) {
		leftValue := this
		if leftValue == rightValue { // equal
			return true
		}
		if leftValue.isPrimitive() &&
			rightValue.isPrimitive() {
			return leftValue.Type == rightValue.Type
		}
		if leftValue.isPointer() && rightValue.Type == VariableTypeNull {
			return true
		}
		if leftValue.Type == VariableTypeObject &&
			leftValue.Class.name == JavaRootClass &&
			rightValue.isPointer() {
			return true
		}
		if leftValue.Type == VariableTypeArray &&
			rightValue.Type == VariableTypeArray {
			return leftValue.array.assignAble(errs, rightValue.array)
		}
		if leftValue.Type == VariableTypeJavaArray &&
			rightValue.Type == VariableTypeJavaArray {
			if leftValue.isVariableArgs != rightValue.isVariableArgs {
				return false
			}
			return leftValue.array.assignAble(errs, rightValue.array)
		}
		if leftValue.Type == VariableTypeEnum && rightValue.Type == VariableTypeEnum {
			return leftValue.Enum.name == rightValue.Enum.name // same enum
		}
		if leftValue.Type == VariableTypeMap && rightValue.Type == VariableTypeMap {
			return leftValue.Map.K.assignAble(errs, rightValue.Map.K) &&
				leftValue.Map.V.assignAble(errs, rightValue.Map.V)
		}
		if leftValue.Type == VariableTypeFunction &&
			rightValue.Type == VariableTypeFunction {
			return leftValue.functionType.equal(rightValue.functionType)
		}
		if leftValue.Type == VariableTypeObject && rightValue.Type == VariableTypeObject { // object
			if leftValue.Class.name == rightValue.Class.name {
				return true
			}
			if err := leftValue.Class.loadSelf(rightValue.pos); err != null {
				errs.append(new error(sprintf("%s %s", errMsgPrefix(rightValue.pos), err.getMessage())))
				return false
			}
			if err := rightValue.Class.loadSelf(rightValue.pos); err != null {
				errs.append(err)
				return false
			}
			if leftValue.Class.IsInterface() {
				i, err := rightValue.Class.implementedInterface(leftValue.pos, leftValue.Class.name)
				if err != null {
					errs.append(err)
				}
				return i
			} else { // class
				has, err := rightValue.Class.haveSuperClass(rightValue.pos, leftValue.Class.name)
				if err != null {
					errs.append(err)
				}
				return has == true
			}
		}
		return false
	}

	public fn equal(compareTo Type) -> (is bool) {
		leftValue := this
		if leftValue.Type != compareTo.Type {
			return false //early check
		}
		if leftValue.isPrimitive() {
			return true //
		}
		if leftValue.Type == VariableTypeVoid {
			return true
		}
		if leftValue.Type == VariableTypeArray ||
			leftValue.Type == VariableTypeJavaArray {
			if leftValue.Type == VariableTypeJavaArray &&
				leftValue.isVariableArgs != compareTo.isVariableArgs {
				return false
			}
			assert(leftValue != null)
			assert(compareTo.array != null)
			return leftValue.array.equal(compareTo.array)
		}
		if leftValue.Type == VariableTypeMap {
			return leftValue.Map.K.equal(compareTo.Map.K) &&
				leftValue.Map.V.equal(compareTo.Map.V)
		}
		if leftValue.Type == VariableTypeEnum {
			return leftValue.Enum.name == compareTo.Enum.name
		}
		if leftValue.Type == VariableTypeObject {
			return leftValue.Class.name == compareTo.Class.name
		}
		if leftValue.Type == VariableTypeFunction {
			return leftValue.functionType.equal(compareTo.functionType)
		}
		return false
	}
}







