// all rights reserved , check the LICENSE file

import "java/lang/Object"

public class Type {
	public Type                    VariableTypeKind
	public isBuildIn               bool             // build in type alias
	public isVariableArgs          bool             // int ...
	public resolved                bool
	public pos                     Pos
	public name                    string
	public array                   Type
	public Class                   Class
	public Enum                    Enum
	public enumName                EnumName         // indicate a const
	public Function                Function
	public functionType            FunctionType
	public Map                     Map
	public Package                 Package
	public alias                   TypeAlias
	public locateDefinition        bool
	public locatePackageDefinition bool
	public packagePos              Pos
	public findUsage               bool
	public getHover                bool
	public autoCompletion          bool
	/*
		a // this is a inline comment
	*/
	public inlineComment string //   in

	public containsLf bool // contains "\n"

	public fn containsLfOrInlineComment() -> (contains bool) {
		return this.containsLf || this.inlineComment != null
	}
	// copy to t 
	fn cp(t Type) {
		t.Type = this.Type
		t.isBuildIn = this.isBuildIn
		t.isVariableArgs = this.isVariableArgs
		t.pos = this.pos
		t.name = this.name
		t.array = this.array
		t.Class = this.Class
		t.Enum = this.Enum
		t.enumName = this.enumName
		t.Function = this.Function
		t.functionType = this.functionType
		t.Map = this.Map
		t.Package = this.Package
		t.alias = this.alias
	}
	fn validForTypeAssertOrConversion() -> (valid bool) {
		if this.isPointer() == false {
			return false
		}
		return true
		// object or string
		if this.Type == VariableTypeObject ||
			this.Type == VariableTypeString {
			return true
		}
		if this.Type == VariableTypeArray &&
			this.array.isPrimitive() {
			return true
		}
		if this.Type == VariableTypeJavaArray {
			if this.array.isPointer() {
				return this.array.validForTypeAssertOrConversion()
			} else {
				return true
			}

		}
		return false
	}

	fn mkDefaultValueExpression() -> (d Expression) {
		e := new Expression()
		e.op = "defaultValueByCompiler"
		e.isCompilerAuto = true
		e.pos = this.pos
		e.value = this.cloneType()
		switch this.Type {
			case VariableTypeBool:
				e.Type = ExpressionTypeBool
				e.boolValue = false
			case VariableTypeByte:
				e.Type = ExpressionTypeByte
				e.longValue = long(0)
			case VariableTypeShort:
				e.Type = ExpressionTypeInt
				e.longValue = long(0)
			case VariableTypeChar:
				e.Type = ExpressionTypeInt
				e.longValue = long(0)
			case VariableTypeInt:
				e.Type = ExpressionTypeInt
				e.longValue = long(0)
			case VariableTypeLong:
				e.Type = ExpressionTypeLong
				e.longValue = long(0)
			case VariableTypeFloat:
				e.Type = ExpressionTypeFloat
				e.doubleValue = double(0)
			case VariableTypeDouble:
				e.Type = ExpressionTypeDouble
				e.doubleValue = double(0)
			case VariableTypeEnum:
				e.Type = ExpressionTypeInt
				e.longValue = long(this.Enum.defaultValue)
			default:
				e.Type = ExpressionTypeNull
		}

		return e
	}

	fn rightValueValid() -> (err error) {
		if this.Type == VariableTypeBool ||
			this.isNumber() ||
			this.Type == VariableTypeString ||
			this.Type == VariableTypeObject ||
			this.Type == VariableTypeArray ||
			this.Type == VariableTypeMap ||
			this.Type == VariableTypeNull ||
			this.Type == VariableTypeJavaArray ||
			this.Type == VariableTypeEnum ||
			this.Type == VariableTypeFunction {
			return null
		}
		switch this.Type {
			case VariableTypePackage:
				return new error(sprintf("%s use package '%s' without selector",
							this.pos.errMsgPrefix() , this.Package.name))
			case VariableTypeClass:
				return new error(sprintf("%s use class '%s' without selector",
							this.pos.errMsgPrefix() , this.Class.name))
			default:
				return new error(sprintf("%s '%s' is not right value valid",
							this.pos.errMsgPrefix() , this.typeString()))
		}

	}

	/*
		have type or not
	*/
	fn isTyped() -> (err error) {
		if err = this.rightValueValid() ; err != null {
			return err
		}
		/*
			null is only untyped right value
		*/
		if this.Type == VariableTypeNull {
			return new error(sprintf("%s '%s' is not typed",
						this.pos.errMsgPrefix() , this.typeString()))
		}
		return null
	}

	public fn cloneType() -> (cloned Type) {
		cloned = this.clone().(Type)
	}

	public fn clone() -> (x Object) {
		cloned := new Type()
		x = cloned
		cloned.Type = this.Type
		cloned.isBuildIn = this.isBuildIn
		cloned.isVariableArgs = this.isVariableArgs
		cloned.resolved = this.resolved
		cloned.pos = this.pos
		cloned.packagePos = this.packagePos
		cloned.name = this.name
		cloned.Class = this.Class
		cloned.Enum = this.Enum
		cloned.locateDefinition = this.locateDefinition
		cloned.locatePackageDefinition = this.locatePackageDefinition
		cloned.findUsage = this.findUsage
		cloned.getHover = this.getHover
		cloned.enumName = this.enumName
		cloned.Function = this.Function
		cloned.Package = this.Package
		cloned.alias = this.alias
		cloned.autoCompletion = this.autoCompletion

		if cloned.Type == VariableTypeArray ||
			cloned.Type == VariableTypeJavaArray {
			cloned.array = this.array.cloneType()
		}
		if cloned.Type == VariableTypeMap {
			cloned.Map = new Map()
			cloned.Map.K = this.Map.K.cloneType()
			cloned.Map.V = this.Map.V.cloneType()
		}
		if this.Type == VariableTypeFunction {
			cloned.functionType = this.functionType.cloneFunctionType()
		}
	}

	fn resolve(block Block) -> (err error) {
		if this.resolved {
			return null
		}
		this.resolved = true // single threading
		switch this.Type {
			case VariableTypeTemplate:
				if block.inheritedAttribute.Function.parameterTypes == null {
					return new error(sprintf("%s parameter type '%s' not in a template function",
								errMsgPrefix(this.pos) , this.name))
				}
				if block.inheritedAttribute.Function.parameterTypes[this.name] == null {
					return new error(sprintf("%s parameter type '%s' not found",
								errMsgPrefix(this.pos) , this.name))
				}
				pos := this.pos // keep pos
				if this.locateDefinition {
					block.inheritedAttribute.p.setLocatedDefinitionPos(block.inheritedAttribute.Function.parameterTypes[this.name])
				}
				block.inheritedAttribute.Function.parameterTypes[this.name].cp(this)
				this.pos = pos // keep pos
				return null
			case VariableTypeName:
				return this.resolveName(block)
			case VariableTypeGlobal:
				d , exists := block.inheritedAttribute.p.block.nameExists(this.name , this.pos)
				if exists == false {
					return new error(sprintf("%s '%s' not found",
								errMsgPrefix(this.pos) , this.name))
				}
				return this.makeTypeFrom(block , d)
			case VariableTypeArray , VariableTypeJavaArray:
				return this.array.resolve(block)
			case VariableTypeMap:
				if this.Map.K != null {
					err = this.Map.K.resolve(block)
					if err != null {
						return err
					}
				}
				if this.Map.V != null {
					return this.Map.V.resolve(block)
				}
			case VariableTypeFunction:
				for _ , v := range this.functionType.parameterList {
					if err = v.Type.resolve(block) ; err != null {
						return err
					}
				}

				for _ , v := range this.functionType.returnList {
					if err = v.Type.resolve(block) ; err != null {
						return err
					}
				}

			case this.isPrimitive():
				if this.locateDefinition {
					block.inheritedAttribute.p.setLocatedDefinitionPos(this)
				}
		}

		return null
	}

	fn resolveName(block Block) -> (err error) {
		var d Object
		if this.name.indexOf(".") < 0 {
			if this.autoCompletion {
				block.inheritedAttribute.p.autoCompletionItems = searchTypeForAutoCompletionItems(this.pos , block)
				return null
			}
			var loadFromImport bool
			d = block.searchType(this.name , this.pos)
			if d != null {
				if t , ok := d.(Class) ; ok &&
					t.isBuildIn == false {
					_ , loadFromImport = shouldAccessFromImports(block , this.name , this.pos , t.pos)
					if loadFromImport {
						t.reduceFindUsageInstances(block)
					}
				}
				if t , ok := d.(Type) ; ok &&
					t.isBuildIn == false {
					_ , loadFromImport = shouldAccessFromImports(block , this.name , this.pos , t.pos)
					if loadFromImport && t.alias != null {
						t.alias.reduceFindUsageInstances(block)
					}
				}
				if t , ok := d.(Enum) ; ok &&
					t.isBuildIn == false {
					_ , loadFromImport = shouldAccessFromImports(block , this.name , this.pos , t.pos)
					if loadFromImport {
						t.reduceFindUsageInstances(block)
					}
				}
			} else {
				loadFromImport = true
			}
			if loadFromImport {
				d , err = this.getNameFromImport(block)
				if err != null {
					return err
				}
			}
		} else {
			d , err = this.getNameFromImport(block)
			if err != null {
				return err
			}
		}
		if d == null {
			return new error(sprintf("%s type named '%s' not found" , errMsgPrefix(this.pos) , this.name))
		}
		err = this.makeTypeFrom(block , d)
		if err != null {
			return err
		}
		return null
	}

	fn getNameFromImport(block Block) -> (d Object , err error) {
		if this.name.indexOf(".") < 0 {
			i := block.inheritedAttribute.p.getImport(this.pos.filename , this.name)
			if i != null {
				if this.locateDefinition {
					block.inheritedAttribute.p.setLocatedDefinitionPos(i)
				}
				i.mkUsed(this.pos)
				return block.inheritedAttribute.p.load(i.Import)
			}
			return null , new error(sprintf("%s type named '%s' not found",
						errMsgPrefix(this.pos) , this.name))
		}
		index := this.name.indexOf(".")
		packageName := this.name[:index]
		className := this.name[index + 1:]
		i := block.inheritedAttribute.p.getImport(this.pos.filename , packageName)
		if null == i {
			return null , new error(sprintf("%s package '%s' not imported",
						errMsgPrefix(this.pos) , packageName))
		}
		{
			pos := this.pos
			if this.packagePos != null {
				pos = this.packagePos
			}
			i.mkUsed(pos)
		}

		if this.locatePackageDefinition {
			block.inheritedAttribute.p.setLocatedDefinitionPos(i)
		}
		p , err := block.inheritedAttribute.p.load(i.Import)
		if err != null {
			return null , new error(sprintf("%s %s",
						errMsgPrefix(this.pos) , err.getMessage()))
		}
		if this.autoCompletion {
			items := []AutoCompletionItem{}
			if pp , ok := p.(Package) ; ok {
				for name , v := range pp.block.classes {
					item := new AutoCompletionItem()
					item.Type = "class"
					item.name = name
					items.append(item)
				}

				for name , v := range pp.block.enums {
					item := new AutoCompletionItem()
					item.Type = "enum"
					item.name = name
					items.append(item)
				}

				for name , v := range pp.block.typeAliases {
					item := new AutoCompletionItem()
					item.Type = "typealias"
					item.name = name
					items.append(item)
				}

				block.inheritedAttribute.p.autoCompletionItems = items
			} else {
				return null , new error(sprintf("%s '%s' is not a package",
							errMsgPrefix(this.pos) , packageName))
			}
			return null , new error("FALSE ERROR") // it's ok 
		}
		if pp , ok := p.(Package) ; ok {
			var exists bool
			// print(pp.name , pp , pp.name , pp.block.classes)
			d , exists = pp.block.nameExists(className , this.pos)
			if exists == false {
				err = new error(sprintf("%s '%s' not found",
						errMsgPrefix(this.pos) , className))
			}
			return d , err
		} else {
			return null , new error(sprintf("%s '%s' is not a package",
						errMsgPrefix(this.pos) , packageName))
		}
	}

	fn makeTypeFrom(block Block , d Object) -> (err error) {
		if c , ok := d.(Class) ; ok {
			if c.loadFromOutSide && c.isPublic() == false {
				err = new error(sprintf("%s class '%s' is not public",
						errMsgPrefix(this.pos) , c.name))
			}
			if this.locateDefinition && c.pos != null {
				block.inheritedAttribute.p.setLocatedDefinitionPos(c)
			}
			this.Type = VariableTypeObject
			this.Class = c
			return err
		}
		if t , ok := d.(Type) ; ok {
			pos := this.pos
			alias := this.alias
			resolved := this.resolved
			t.cp(this)
			if this.locateDefinition {
				if t.alias == null {
					block.inheritedAttribute.p.setLocatedDefinitionPos(t)
				} else {
					block.inheritedAttribute.p.setLocatedDefinitionPos(t.alias)
				}

			}
			this.pos = pos
			this.alias = alias
			this.resolved = resolved
			return null
		}
		if dd , ok := d.(Enum) ; ok {
			if dd.loadFromOutSide && dd.isPublic() == false {
				block.inheritedAttribute.p.errors.append(new error(sprintf("%s enum '%s' is not public",
							errMsgPrefix(this.pos) , dd.name)))
			}
			if this.locateDefinition {
				block.inheritedAttribute.p.setLocatedDefinitionPos(dd)
				return
			}
			this.Type = VariableTypeEnum
			this.Enum = dd
			return null
		}
		return new error(sprintf("%s name '%s' is not a type",
					errMsgPrefix(this.pos) , this.name))
	}

	public fn isNumber() -> (is bool) {
		return this.isInteger() ||
				this.isFloat()
	}

	public fn isPointer() -> (is bool) {
		return this.Type == VariableTypeObject ||
				this.Type == VariableTypeArray ||
				this.Type == VariableTypeJavaArray ||
				this.Type == VariableTypeMap ||
				this.Type == VariableTypeString ||
				this.Type == VariableTypeNull ||
				this.Type == VariableTypeFunction
	}

	public fn isInteger() -> (is bool) {
		return this.Type == VariableTypeByte ||
				this.Type == VariableTypeShort ||
				this.Type == VariableTypeInt ||
				this.Type == VariableTypeLong ||
				this.Type == VariableTypeChar
	}

	/*
		float or double
	*/
	fn isFloat() -> (is bool) {
		return this.Type == VariableTypeFloat ||
				this.Type == VariableTypeDouble
	}

	public fn isPrimitive() -> (is bool) {
		return this.isNumber() ||
				this.Type == VariableTypeString ||
				this.Type == VariableTypeBool
	}

	public fn typeName(prefix string = "") -> (ret string) {
		switch this.Type {
			case VariableTypeBool:
				return prefix + "bool"
			case VariableTypeByte:
				return prefix + "byte"
			case VariableTypeChar:
				return prefix + "char"
			case VariableTypeShort:
				return prefix + "short"
			case VariableTypeInt:
				return prefix + "int"
			case VariableTypeLong:
				return prefix + "long"
			case VariableTypeFloat:
				return prefix + "float"
			case VariableTypeDouble:
				return prefix + "double"
			case VariableTypeString:
				return prefix + "string"
			case VariableTypeObject:
				return prefix + this.name
			case VariableTypeMap:
				ret = prefix + "map{"
				ret += this.Map.K.typeName()
				ret += " -> "
				ret += this.Map.V.typeName()
				ret += "}"
				return ret
			case VariableTypeArray:
				return this.array.typeName(prefix + "[]")
			case VariableTypeJavaArray:
				if this.isVariableArgs {
					ret = prefix + this.array.typeName() + "..."
					return ret
				} else {
					ret = prefix + this.array.typeName() + "[]"
					return ret
				}
			case VariableTypeFunction:
				ret = prefix + "fn" + this.functionType.typeName()
				return
			case VariableTypeEnum:
				ret = prefix + this.name
			case VariableTypeClass:
				panic("not happening")
			case VariableTypeName:
				ret = prefix + this.name // resolve wrong, but typeString is ok to return
			case VariableTypeTemplate:
				ret = prefix + this.name
			case VariableTypeDynamicSelector:
				panic("not happening")
			case VariableTypeVoid:
				panic("not happening")
			case VariableTypePackage:
				panic("not happening")
			case VariableTypeNull:
				panic("not happening")
			case VariableTypeGlobal:
				ret = prefix + this.name
		}

	}

	public fn typeString(prefix string = "") -> (ret string) {
		// if this.alias != null {
		switch this.Type {
			case VariableTypeBool:
				return prefix + "bool"
			case VariableTypeByte:
				return prefix + "byte"
			case VariableTypeChar:
				return prefix + "char"
			case VariableTypeShort:
				return prefix + "short"
			case VariableTypeInt:
				return prefix + "int"
			case VariableTypeLong:
				return prefix + "long"
			case VariableTypeFloat:
				return prefix + "float"
			case VariableTypeDouble:
				return prefix + "double"
			case VariableTypeString:
				return prefix + "string"
			case VariableTypeObject:
				return prefix + "object@" + this.Class.name
			case VariableTypeMap:
				ret = prefix + "map{"
				ret += this.Map.K.typeString()
				ret += " -> "
				ret += this.Map.V.typeString()
				ret += "}"
				return ret
			case VariableTypeArray:
				return this.array.typeString(prefix + "[]")
			case VariableTypeJavaArray:
				if this.isVariableArgs {
					ret = prefix + this.array.typeString() + "..."
					return ret
				} else {
					ret = prefix + this.array.typeString() + "[]"
					return ret
				}

			case VariableTypeFunction:
				ret = prefix + "fn " + this.functionType.typeString()
				return
			case VariableTypeEnum:
				ret = prefix + "enum(" + this.Enum.name + ")"
			case VariableTypeClass:
				ret = prefix + sprintf("class@%s" , this.Class.name)
			case VariableTypeName:
				ret = prefix + this.name // resolve wrong, but typeString is ok to return
			case VariableTypeTemplate:
				ret = prefix + this.name
			case VariableTypeDynamicSelector:
				ret = prefix + "dynamicSelector@" + this.Class.name
			case VariableTypeVoid:
				ret = prefix + "void"
			case VariableTypePackage:
				ret = prefix + "package@" + this.Package.name
			case VariableTypeNull:
				ret = prefix + "null"
			case VariableTypeGlobal:
				ret = prefix + "global." + this.name
		}

	}

	fn getParameterType(ft FunctionType) -> (pts []string) {
		if this.Type == VariableTypeName &&
			ft.haveTemplateName(this.name) {
			this.Type = VariableTypeTemplate // convert to type
		}
		if this.Type == VariableTypeTemplate {
			return []string{this.name}
		}
		if this.Type == VariableTypeArray ||
			this.Type == VariableTypeJavaArray {
			return this.array.getParameterType(ft)
		}
		if this.Type == VariableTypeMap {
			pts = []string{}
			pts.appendAll(this.Map.K.getParameterType(ft))
			pts.appendAll(this.Map.V.getParameterType(ft))
			return
		}
		return null
	}

	fn canBeBindWithParameterTypes(parameterTypes map{string -> Type}) -> (err error) {
		if this.Type == VariableTypeTemplate {
			ok := parameterTypes.keyExist(this.name)
			if ok == false {
				return new error(sprintf("typed parameter '%s' not found" , this.name))
			}
			return null
		}
		if this.Type == VariableTypeArray ||
			this.Type == VariableTypeJavaArray {
			return this.array.canBeBindWithParameterTypes(parameterTypes)
		}
		if this.Type == VariableTypeMap {
			err = this.Map.K.canBeBindWithParameterTypes(parameterTypes)
			if err != null {
				return err
			}
			return this.Map.V.canBeBindWithParameterTypes(parameterTypes)
		}
		return null
	}

	/*
		if there is error,this function will crash
	*/
	fn bindWithParameterTypes(ft FunctionType , parameterTypes map{string -> Type}) {
		if this.Type == VariableTypeTemplate {
			ok := parameterTypes.keyExist(this.name)
			if ok == false {
				panic(sprintf("typed parameter '%s' not found" , this.name))
			}
			//TODO ::
			parameterTypes[this.name].cp(this)
			return
		}
		if this.Type == VariableTypeArray || this.Type == VariableTypeJavaArray {
			this.array.bindWithParameterTypes(ft , parameterTypes)
			return
		}
		if this.Type == VariableTypeMap {
			if len(this.Map.K.getParameterType(ft)) > 0 {
				this.Map.K.bindWithParameterTypes(ft , parameterTypes)
			}
			if len(this.Map.V.getParameterType(ft)) > 0 {
				this.Map.V.bindWithParameterTypes(ft , parameterTypes)
				return
			}
		}
		panic("not T")
	}

	/*
		
	 */
	fn canBeBindWithType(ft FunctionType , mkParameterTypes map{string -> Type} , bind Type) -> (err error) {
		if err = bind.rightValueValid() ; err != null {
			return err
		}
		if bind.Type == VariableTypeNull {
			return new error(sprintf("'%s' is un typed" , bind.typeString()))
		}
		if this.Type == VariableTypeTemplate {
			mkParameterTypes[this.name] = bind
			return null
		}
		if this.Type == VariableTypeArray && bind.Type == VariableTypeArray {
			return this.array.canBeBindWithType(ft , mkParameterTypes , bind.array)
		}
		if this.Type == VariableTypeJavaArray && bind.Type == VariableTypeJavaArray {
			return this.array.canBeBindWithType(ft , mkParameterTypes , bind.array)
		}
		if this.Type == VariableTypeMap && bind.Type == VariableTypeMap {
			if len(this.Map.K.getParameterType(ft)) > 0 {
				err = this.Map.K.canBeBindWithType(ft , mkParameterTypes , bind.Map.K)
				if err != null {
					return err
				}
			}
			if len(this.Map.V.getParameterType(ft)) > 0 {
				return this.Map.V.canBeBindWithType(ft , mkParameterTypes , bind.Map.V)
			}
		}
		return new error(sprintf("cannot bind '%s' to '%s'" , bind.typeString() , this.typeString()))
	}

	fn assignAble(block Block , errs []error , rightValue Type) -> (able bool) {
		leftValue := this
		if leftValue == rightValue {
			return true
		}
		{
			// try string first
			if leftValue.isString() && rightValue.isString() {
				return true
			}
		}

		if leftValue.isPrimitive() &&
			rightValue.isPrimitive() {
			return leftValue.Type == rightValue.Type
		}
		if leftValue.isPointer() && rightValue.Type == VariableTypeNull {
			return true
		}
		if leftValue.Type == VariableTypeObject &&
			leftValue.Class.name == JavaRootClass &&
			rightValue.isPointer() {
			return true
		}
		if leftValue.Type == VariableTypeArray &&
			rightValue.Type == VariableTypeArray {
			return leftValue.array.assignAble(block , errs , rightValue.array)
		}
		if leftValue.Type == VariableTypeJavaArray &&
			rightValue.Type == VariableTypeJavaArray {
			if leftValue.isVariableArgs != rightValue.isVariableArgs {
				return false
			}
			return leftValue.array.assignAble(block , errs , rightValue.array)
		}
		if leftValue.Type == VariableTypeEnum && rightValue.Type == VariableTypeEnum {
			return leftValue.Enum.name == rightValue.Enum.name // same enum
		}
		if leftValue.Type == VariableTypeMap && rightValue.Type == VariableTypeMap {
			return leftValue.Map.K.assignAble(block , errs , rightValue.Map.K) &&
					leftValue.Map.V.assignAble(block , errs , rightValue.Map.V)
		}
		if leftValue.Type == VariableTypeFunction &&
			rightValue.Type == VariableTypeFunction {
			return leftValue.functionType.equal(rightValue.functionType)
		}
		if leftValue.Type == VariableTypeString {
			leftValue = new Type()
			leftValue.Type = VariableTypeObject
			leftValue.Class = new Class()
			leftValue.Class.name = JavaStringClassName
			leftValue.Class.notImportedYet = true
		}
		if rightValue.Type == VariableTypeString {
			rightValue = new Type()
			rightValue.Type = VariableTypeObject
			rightValue.Class = new Class()
			rightValue.Class.name = JavaStringClassName
			rightValue.Class.notImportedYet = true
		}
		if leftValue.Type == VariableTypeObject && rightValue.Type == VariableTypeObject {
			if leftValue.Class.name == rightValue.Class.name {
				return true
			}
			if err := leftValue.Class.loadSelf(block , rightValue.pos) ; err != null {
				errs.append(err)
				return false
			}
			if err := rightValue.Class.loadSelf(block , rightValue.pos) ; err != null {
				errs.append(err)
				return false
			}
			if leftValue.Class.isInterface() {
				i , err := rightValue.Class.implementedInterface(block , new map{string -> bool}() , leftValue.pos , leftValue.Class.name)
				if err != null {
					errs.append(err)
				}
				return i
			} else {
				has , err := rightValue.Class.haveSuperClass(block , new map{string -> bool}() , rightValue.pos , leftValue.Class.name)
				if err != null {
					errs.append(err)
				}
				return has == true
			}
		}
		return false
	}

	public fn equal(compareTo Type) -> (is bool) {
		leftValue := this
		if leftValue.Type != compareTo.Type {
			if leftValue.isString() && compareTo.isString() {
				return true
			}
			return false //early check
		}
		if leftValue.isPrimitive() {
			return true //
		}
		if leftValue.Type == VariableTypeVoid {
			return true
		}
		if leftValue.Type == VariableTypeArray ||
			leftValue.Type == VariableTypeJavaArray {
			if leftValue.Type == VariableTypeJavaArray &&
				leftValue.isVariableArgs != compareTo.isVariableArgs {
				return false
			}
			return leftValue.array.equal(compareTo.array)
		}
		if leftValue.Type == VariableTypeMap {
			return leftValue.Map.K.equal(compareTo.Map.K) &&
					leftValue.Map.V.equal(compareTo.Map.V)
		}
		if leftValue.Type == VariableTypeEnum {
			return leftValue.Enum.name == compareTo.Enum.name
		}
		if leftValue.Type == VariableTypeObject {
			return leftValue.Class.name == compareTo.Class.name
		}
		if leftValue.Type == VariableTypeFunction {
			return leftValue.functionType.equal(compareTo.functionType)
		}
		return false
	}
	fn isString() -> (is bool) {
		if this.Type == VariableTypeString {
			return true
		}
		if this.Type != VariableTypeObject {
			return false
		}
		return this.Class != null && this.Class.name == JavaStringClassName
	}
}

