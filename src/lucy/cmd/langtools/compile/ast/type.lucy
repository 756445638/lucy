import "java/lang/Object"

public enum  VariableTypeKind {
	VariableTypeBool =1 ,
	VariableTypeByte,
	VariableTypeShort,
	VariableTypeChar,
	VariableTypeInt,
	VariableTypeLong,
	VariableTypeFloat,
	VariableTypeDouble,
	//enum 
	VariableTypeEnum,
	//ref types 
	VariableTypeString,
	VariableTypeObject,
	VariableTypeMap,
	VariableTypeArray,
	VariableTypeJavaArray,
	VariableTypeFunction,
	VariableTypeClass,
	VariableTypeName,
	VariableTypeTemplate,
	VariableTypeVoid,
	
	VariableTypePackage,
	VariableTypeNull,
	VariableTypeGlobal,
	VariableTypeMagicFunction,
	VariableTypeDynamicSelector 
}


public class Map {
	K Type
	V Type
}

public class Type {
	public Type           VariableTypeKind
	public IsBuildIn      bool // build in type alias
	public IsVariableArgs bool // int ...
	public Resolved       bool
	public Pos            Pos
	public Name           string
	public Array          Type
	public Class          Class
	public Enum           Enum
	public EnumName       EnumName // indicate a const
	public Function       Function
	public FunctionType   FunctionType
	public Map            Map
	public Package        Package
	public Alias          TypeAlias
	

	// copy to t 
	fn cp(t Type) {
	    t.Type = this.Type
	    t.IsBuildIn = this.IsBuildIn
	    t.IsVariableArgs = this.IsVariableArgs
	    t.Resolved = this.Resolved
	    t.Pos = this.Pos
	    t.Name = this.Name
	    t.Array = this.Array
	    t.Class = this.Class
	    t.Enum = this.Enum
	    t.EnumName = this.EnumName
	    t.Function = this.Function
	    t.Map = this.Map
	    t.Package = this.Package
	    t.Alias = this.Alias
	}
	fn validForTypeAssertOrConversion() -> (valid bool) {
		if this.IsPointer() == false {
			return false
		}
		// object or string
		if this.Type == VariableTypeObject || this.Type == VariableTypeString {
			return true
		}
		if this.Type == VariableTypeArray && this.Array.IsPrimitive() {
			return true
		}
		if this.Type == VariableTypeJavaArray {
			if this.Array.IsPointer() {
				return this.Array.validForTypeAssertOrConversion()
			} else {
				return true
			}
		}
		return false
	}

	fn mkDefaultValueExpression() -> (d Expression) {
		e := new Expression()
		e.Op = "defaultValueByCompiler"
		e.IsCompileAuto = true
		e.Pos = this.Pos
		e.Value = this.Clone()
		switch this.Type {
		case VariableTypeBool:
			e.Type = ExpressionTypeBool
			e.longValue = 0
		case VariableTypeByte:
			e.Type = ExpressionTypeByte
			e.longValue =  0
		case VariableTypeShort:
			e.Type = ExpressionTypeInt
			e.longValue =  0
		case VariableTypeChar:
			e.Type = ExpressionTypeInt
			e.longValue =  0
		case VariableTypeInt:
			e.Type = ExpressionTypeInt
			e.longValue =  0
		case VariableTypeLong:
			e.Type = ExpressionTypeLong
			e.longValue = 0
		case VariableTypeFloat:
			e.Type = ExpressionTypeFloat
			e.doubleValue = float(0)
		case VariableTypeDouble:
			e.Type = ExpressionTypeDouble
			e.doubleValue = double(0)
		case VariableTypeEnum:
			e.Type = ExpressionTypeInt
			e.longValue = long(this.Enum.DefaultValue)
		default:
			e.Type = ExpressionTypeNull
		}
		return e
	}

	fn rightValueValid() -> (err error) {
		if this.Type == VariableTypeBool ||
			this.IsNumber() ||
			this.Type == VariableTypeString ||
			this.Type == VariableTypeObject ||
			this.Type == VariableTypeArray ||
			this.Type == VariableTypeMap ||
			this.Type == VariableTypeNull ||
			this.Type == VariableTypeJavaArray ||
			this.Type == VariableTypeEnum ||
			this.Type == VariableTypeFunction {
			return null
		}
		switch this.Type {
		case VariableTypePackage:
			return new error(sprintf("%s use package '%s' without selector",
				this.Pos.ErrMsgPrefix(), this.Package.Name))
		case VariableTypeClass:
			return new error(sprintf("%s use class '%s' without selector",
				this.Pos.ErrMsgPrefix(), this.Class.Name))
		case VariableTypeMagicFunction:
			return new error(sprintf("%s use '%s' without selector",
				this.Pos.ErrMsgPrefix(), magicIdentifierFunction))
		default:
			return new error(sprintf("%s '%s' is not right value valid",
				this.Pos.ErrMsgPrefix(), this.TypeString()))
		}
	}

	/*
		have type or not
	*/
	fn isTyped() -> (err error) {
		if err := this.rightValueValid(); err != null {
			return err
		}
		/*
			null is only untyped right value
		*/
		if this.Type == VariableTypeNull {
			return new error(sprintf("%s '%s' is not typed",
				this.Pos.ErrMsgPrefix(), this.TypeString()))
		}
		return null
	}

	/*
		deep clone
	*/
	public fn Clone() ->(cloned Type) {
		cloned = new Type()
		cloned.Type = this.Type

		//TODO:: 
		if cloned.Type == VariableTypeArray ||
			cloned.Type == VariableTypeJavaArray {
			cloned.Array = this.Array.Clone()
		}
		if cloned.Type == VariableTypeMap {
			cloned.Map = new Map()
			cloned.Map.K = this.Map.K.Clone()
			cloned.Map.V = this.Map.V.Clone()
		}
		if this.Type == VariableTypeFunction {
			cloned.FunctionType = this.FunctionType.Clone()
		}
	}

	fn resolve(block Block) -> (err error) {
		if this.Resolved {
			return null
		}
		this.Resolved = true // single threading
		switch this.Type {
		case VariableTypeTemplate:
			if block.InheritedAttribute.Function.parameterTypes == null {
				return new error(sprintf("%s parameter type '%s' not in a template function",
					errMsgPrefix(this.Pos), this.Name))
			}
			if block.InheritedAttribute.Function.parameterTypes[this.Name] == null {
				return new error(sprintf("%s parameter type '%s' not found",
					errMsgPrefix(this.Pos), this.Name))
			}
			pos := this.Pos // keep pos
			//TODO:: copy
			//*typ = *block.InheritedAttribute.Function.parameterTypes[this.Name]
			this.Pos = pos // keep pos
			return null
		case VariableTypeName:
			return this.resolveName(block)
		case VariableTypeGlobal:
			d, exists := PackageBeenCompile.Block.nameExists(this.Name)
			if exists == false {
				return new error(sprintf("%s '%s' not found",
					errMsgPrefix(this.Pos), this.Name))
			}
			return this.makeTypeFrom(d)
		case VariableTypeArray, VariableTypeJavaArray:
			return this.Array.resolve(block)
		case VariableTypeMap:
			var err error
			if this.Map.K != null {
				err = this.Map.K.resolve(block)
				if err != null {
					return err
				}
			}
			if this.Map.V != null {
				return this.Map.V.resolve(block)
			}
		case VariableTypeFunction:
			for _, v := range this.FunctionType.ParameterList {
				if err := v.Type.resolve(block); err != null {
					return err
				}
			}
			for _, v := range this.FunctionType.ReturnList {
				if err := v.Type.resolve(block); err != null {
					return err
				}
			}
		default:
		}
		return null
	}

	fn resolveName(block Block) -> (err error ) {
		var d  Object
		if this.Name.indexOf(".")  < 0  {
			var loadFromImport bool
			d = block.searchType(this.Name)
			if d != null {
				if t, ok := d.(Class); ok &&
					t.IsBuildIn == false {
					_, loadFromImport = shouldAccessFromImports(this.Name, this.Pos, t.Pos)
				}
				if t, ok := d.(Type); ok &&
						t.IsBuildIn == false {
						_, loadFromImport = shouldAccessFromImports(this.Name, this.Pos, t.Pos)
				}
				if t, ok := d.(Enum); ok &&
						t.IsBuildIn == false {
						_, loadFromImport = shouldAccessFromImports(this.Name, this.Pos, t.Pos)
				}
			} else {
				loadFromImport = true
			}
			if loadFromImport {
				d, err = this.getNameFromImport()
				if err != null {
					return err
				}
			}
		} else { // a.b  in type situation,must be package name
			d, err = this.getNameFromImport()
			if err != null {
				return err
			}
		}
		if d == null {
			return new error(sprintf("%s type named '%s' not found", errMsgPrefix(this.Pos), this.Name))
		}
		err = this.makeTypeFrom(d)
		if err != null {
			return err
		}
		return null
	}

	fn getNameFromImport() -> (d Object, err error) {
		if this.Name.indexOf(".")  > 0  {
			i := PackageBeenCompile.getImport(this.Pos.Filename, this.Name)
			if i != null {
				i.Used = true
				return PackageBeenCompile.load(i.Import)
			}
			return null, new error(sprintf("%s type named '%s' not found",
				errMsgPrefix(this.Pos), this.Name))
		}
		packageAndName := this.Name.split(".")
		i := PackageBeenCompile.getImport(this.Pos.Filename, packageAndName[0])
		if null == i {
			return null, new error(sprintf("%s package '%s' not imported",
				errMsgPrefix(this.Pos), packageAndName[0]))
		}
		i.Used = true
		p, err := PackageBeenCompile.load(i.Import)
		if err != null {
			return null, new error(sprintf("%s %.getMessage()",
				errMsgPrefix(this.Pos), err.getMessage()))
		}
		if pp, ok := p.(Package); ok &&
			pp != null {
			var exists bool
			d, exists = pp.Block.nameExists(packageAndName[1])
			if exists == false {
				err = new error(sprintf("%s '%s' not found",
					errMsgPrefix(this.Pos), packageAndName[1]))
			}
			return d, err
		} else {
			return null, new error(sprintf("%s '%s' is not a package",
				errMsgPrefix(this.Pos), packageAndName[0]))
		}
	}

	fn makeTypeFrom(d Object) -> (err error)  {
		if dd := d.(Class) ; dd != null {
			if dd.LoadFromOutSide && dd.IsPublic() == false {
				PackageBeenCompile.errors.append(
				    new error(sprintf("%s class '%s' is not public",
						       errMsgPrefix(this.Pos), dd.Name)))
			}
			this.Type = VariableTypeObject
			this.Class = dd
			return null
		}
		if t := d.(Type) ; t != null {
			pos := this.Pos
			alias := this.Alias
			resolved := this.Resolved
			//TODO ::
			this.Pos = pos
			this.Alias = alias
			this.Resolved = resolved
			return null
		}
		if dd := d.(Enum) ; dd != null {
			if dd.LoadFromOutSide && dd.isPublic() == false {
				PackageBeenCompile.errors.append(
					new error(sprintf("%s enum '%s' is not public",
						errMsgPrefix(this.Pos), dd.Name)))
			}
			this.Type = VariableTypeEnum
			this.Enum = dd
			return null
		}
		return new error(sprintf("%s name '%s' is not a type",
			errMsgPrefix(this.Pos), this.Name))
	}

	fn IsNumber() -> (is bool) {
		return this.isInteger() ||
			this.isFloat()
	}

	fn IsPointer() -> (is bool)  {
		return this.Type == VariableTypeObject ||
			this.Type == VariableTypeArray ||
			this.Type == VariableTypeJavaArray ||
			this.Type == VariableTypeMap ||
			this.Type == VariableTypeString ||
			this.Type == VariableTypeNull ||
			this.Type == VariableTypeFunction
	}

	fn isInteger() -> (is bool)  {
		return this.Type == VariableTypeByte ||
			this.Type == VariableTypeShort ||
			this.Type == VariableTypeInt ||
			this.Type == VariableTypeLong ||
			this.Type == VariableTypeChar
	}

	/*
		float or double
	*/
	fn isFloat() -> (is bool)  {
		return this.Type == VariableTypeFloat ||
			this.Type == VariableTypeDouble
	}

	fn IsPrimitive() -> (is bool)  {
		return this.IsNumber() ||
			this.Type == VariableTypeString ||
			this.Type == VariableTypeBool
	}

	fn TypeString(prefix string = "") ->(ret string) {
		if this.Alias != null {
			return prefix + this.Alias.Name
		}
		switch this.Type {
		case VariableTypeBool:
			return prefix +  "bool"
		case VariableTypeByte:
			return prefix +  "byte"
		case VariableTypeChar:
			return prefix +  "char"
		case VariableTypeShort:
			return prefix +  "short"
		case VariableTypeInt:
			return prefix +  "int"
		case VariableTypeLong:
			return prefix +  "long"
		case VariableTypeFloat:
			return prefix +  "float"
		case VariableTypeDouble:
			return prefix +  "double"
		case VariableTypeString:
			return prefix +  "string"
		case VariableTypeObject: // class name
			return prefix +  "object@" + this.Class.Name
		case VariableTypeMap:
			ret =prefix + "map{"
			ret += this.Map.K.TypeString()
			ret += " -> "
			ret += this.Map.V.TypeString()
			ret += "}"
			return ret 
		case VariableTypeArray:
			return this.Array.TypeString(prefix + "[]")
		case VariableTypeJavaArray:
			if this.IsVariableArgs {
				ret = prefix + this.Array.TypeString() + "..."
				return ret 
			} else {
				ret = prefix + this.Array.TypeString() + "[]"
				return ret 
			}
		case VariableTypeFunction:
			ret = prefix + "fn " + this.FunctionType.TypeString()
			return 
		case VariableTypeEnum:
			ret = prefix + "enum(" + this.Enum.Name + ")"
		case VariableTypeClass:
			ret = prefix + sprintf("class@%s", this.Class.Name)
		case VariableTypeName:
			ret = prefix + this.Name // resolve wrong, but TypeString is ok to return
		case VariableTypeTemplate:
			ret = prefix + this.Name
		case VariableTypeDynamicSelector:
			ret = prefix + "dynamicSelector@" + this.Class.Name
		case VariableTypeVoid:
			ret = prefix + "void"
		case VariableTypePackage:
			ret = prefix + "package@" + this.Package.Name
		case VariableTypeNull:
			ret = prefix + "null"
		case VariableTypeGlobal:
			ret = prefix + this.Name
		case VariableTypeMagicFunction:
			ret = prefix + magicIdentifierFunction
		}
	}

	fn getParameterType(ft FunctionType) -> (pts []string) {
		if this.Type == VariableTypeName &&
			ft.haveTemplateName(this.Name) {
			this.Type = VariableTypeTemplate // convert to type
		}
		if this.Type == VariableTypeTemplate {
			return []string{this.Name}
		}
		if this.Type == VariableTypeArray ||
			this.Type == VariableTypeJavaArray {
			return this.Array.getParameterType(ft)
		}
		if this.Type == VariableTypeMap {
			pts = []string{}
			pts.appendAll(this.Map.K.getParameterType(ft))
			pts.appendAll( this.Map.V.getParameterType(ft))
			return
		}
		return null
	}

	fn canBeBindWithParameterTypes(parameterTypes map{ string->Type }) -> (err error) {
		if this.Type == VariableTypeTemplate {
			 ok := parameterTypes.keyExist(this.Name)
			if ok == false {
				return new error(sprintf("typed parameter '%s' not found", this.Name))
			}
			return null
		}
		if this.Type == VariableTypeArray ||
			this.Type == VariableTypeJavaArray {
			return this.Array.canBeBindWithParameterTypes(parameterTypes)
		}
		if this.Type == VariableTypeMap {
			err := this.Map.K.canBeBindWithParameterTypes(parameterTypes)
			if err != null {
				return err
			}
			return this.Map.V.canBeBindWithParameterTypes(parameterTypes)
		}
		return null
	}

	/*
		if there is error,this function will crash
	*/
	fn bindWithParameterTypes(ft FunctionType, parameterTypes map{string->Type}) -> (err error) {
		if this.Type == VariableTypeTemplate {
			ok := parameterTypes.keyExist(this.Name)
			if ok == false {
				panic(sprintf("typed parameter '%s' not found", this.Name))
			}
			//TODO ::
			//*typ = *t.Clone() // real bind
			parameterTypes[this.Name].cp(this)
			return null
		}
		if this.Type == VariableTypeArray || this.Type == VariableTypeJavaArray {
			return this.Array.bindWithParameterTypes(ft, parameterTypes)
		}
		if this.Type == VariableTypeMap {
			if len(this.Map.K.getParameterType(ft)) > 0 {
				err := this.Map.K.bindWithParameterTypes(ft, parameterTypes)
				if err != null {
					return err
				}
			}
			if len(this.Map.V.getParameterType(ft)) > 0 {
				return this.Map.V.bindWithParameterTypes(ft, parameterTypes)
			}
		}
		panic("not T")
	}

	/*

	 */
	fn canBeBindWithType(ft FunctionType, mkParameterTypes map{string->Type}, bind Type) -> (err error)  {
		if err := bind.rightValueValid(); err != null {
			return err
		}
		if bind.Type == VariableTypeNull {
			return new error(sprintf("'%s' is un typed", bind.TypeString()))
		}
		if this.Type == VariableTypeTemplate {
			mkParameterTypes[this.Name] = bind
			return null
		}
		if this.Type == VariableTypeArray && bind.Type == VariableTypeArray {
			return this.Array.canBeBindWithType(ft, mkParameterTypes, bind.Array)
		}
		if this.Type == VariableTypeJavaArray && bind.Type == VariableTypeJavaArray {
			return this.Array.canBeBindWithType(ft, mkParameterTypes, bind.Array)
		}
		if this.Type == VariableTypeMap && bind.Type == VariableTypeMap {
			if len(this.Map.K.getParameterType(ft)) > 0 {
				err := this.Map.K.canBeBindWithType(ft, mkParameterTypes, bind.Map.K)
				if err != null {
					return err
				}
			}
			if len(this.Map.V.getParameterType(ft)) > 0 {
				return this.Map.V.canBeBindWithType(ft, mkParameterTypes, bind.Map.V)
			}
		}
		return new error(sprintf("cannot bind '%s' to '%s'", bind.TypeString(), this.TypeString()))
	}

	fn assignAble(errs []error, rightValue Type) ->(able bool) {
		leftValue := this
		if leftValue == rightValue { // equal
			return true
		}
		if leftValue.IsPrimitive() &&
			rightValue.IsPrimitive() {
			return leftValue.Type == rightValue.Type
		}
		if leftValue.IsPointer() && rightValue.Type == VariableTypeNull {
			return true
		}
		if leftValue.Type == VariableTypeObject &&
			leftValue.Class.Name == JavaRootClass &&
			rightValue.IsPointer() {
			return true
		}
		if leftValue.Type == VariableTypeArray &&
			rightValue.Type == VariableTypeArray {
			return leftValue.Array.assignAble(errs, rightValue.Array)
		}
		if leftValue.Type == VariableTypeJavaArray &&
			rightValue.Type == VariableTypeJavaArray {
			if leftValue.IsVariableArgs != rightValue.IsVariableArgs {
				return false
			}
			return leftValue.Array.assignAble(errs, rightValue.Array)
		}

		if leftValue.Type == VariableTypeEnum && rightValue.Type == VariableTypeEnum {
			return leftValue.Enum.Name == rightValue.Enum.Name // same enum
		}
		if leftValue.Type == VariableTypeMap && rightValue.Type == VariableTypeMap {
			return leftValue.Map.K.assignAble(errs, rightValue.Map.K) &&
				leftValue.Map.V.assignAble(errs, rightValue.Map.V)
		}
		if leftValue.Type == VariableTypeFunction &&
			rightValue.Type == VariableTypeFunction {
			return leftValue.FunctionType.equal(rightValue.FunctionType)
		}
		if leftValue.Type == VariableTypeObject && rightValue.Type == VariableTypeObject { // object
			if err := leftValue.Class.loadSelf(leftValue.Pos); err != null {
				errs.append(new error( sprintf("%s %s", errMsgPrefix(rightValue.Pos), err.getMessage())))
				return false
			}
			if err := rightValue.Class.loadSelf(rightValue.Pos); err != null {
				errs.append(err)
				return false
			}
			if leftValue.Class.IsInterface() {
				i, err := rightValue.Class.implementedInterface(leftValue.Pos, leftValue.Class.Name)
				if err != null {
					errs.append(err)
				}
				return i
			} else { // class
				has, err := rightValue.Class.haveSuperClass(rightValue.Pos, leftValue.Class.Name)
				if err != null {
					errs.append(err)
				}
				return has
			}
		}
		return false
	}

	fn Equal(compareTo Type) -> (is bool) {
		leftValue := this
		if leftValue.Type != compareTo.Type {
			return false //early check
		}
		if leftValue.IsPrimitive() {
			return true //
		}
		if leftValue.Type == VariableTypeVoid {
			return true
		}
		if leftValue.Type == VariableTypeArray ||
			leftValue.Type == VariableTypeJavaArray {
			if leftValue.Type == VariableTypeJavaArray &&
				leftValue.IsVariableArgs != compareTo.IsVariableArgs {
				return false
			}
			return leftValue.Array.Equal(compareTo.Array)
		}
		if leftValue.Type == VariableTypeMap {
			return leftValue.Map.K.Equal(compareTo.Map.K) &&
				leftValue.Map.V.Equal(compareTo.Map.V)
		}
		if leftValue.Type == VariableTypeEnum {
			return leftValue.Enum.Name == compareTo.Enum.Name
		}
		if leftValue.Type == VariableTypeObject {
			return leftValue.Class.Name == compareTo.Class.Name
		}
		if leftValue.Type == VariableTypeFunction {
			return leftValue.FunctionType.equal(compareTo.FunctionType)
		}
		return false
	}
}







