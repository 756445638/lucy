
import "lucy/os"
import "lucy/cmd/langtools/compile/common"



public class Package {
	public name                         string
	public block                        Block = new Block() // package always have a default block
	files                        map { string -> SourceFile}
	public initFunctions                []Function
	public nErrors2Stop                 int // number of errors should stop compile
	errors                       []error
	public triggerPackageInitMethodName string //
	statementLevelFunctions      []Function
	statementLevelClass          []Class
	disableCheckUnuse  				bool 
	javaPackage JavaPackage
	public hasMain bool 
	/*
		for lucy tool goto definition
	*/
	public locateDefinition Pos 

	/*
		for lucy tool hover
	*/
	hover Hover
	/*
		for usage 
	*/
	public findUsage []Usage 
	public findUsageIsGlobal bool 

	public onlyAnalyzeGlobals bool 

	public renameIsGlobal bool 

	public autoCompletionItems []AutoCompletionItem
	
	public fn Package(name string,disableCheckUnuse bool){
		this.super()
		assert(name != null )
		this.disableCheckUnuse = disableCheckUnuse
		this.name =  name
	}

	fn isSame(compare Package) -> (is bool) {
		return this.name == compare.name
	}

	fn markBuildIn() {
		for _, v := range this.block.variables {
			v.isBuildIn = true
		}
		for _, v := range this.block.constants {
			v.isBuildIn = true
		}
		for _, v := range this.block.enums {
			v.isBuildIn = true
		}
		for _, v := range this.block.Classes {
			v.isBuildIn = true
		}
		for _, v := range this.block.functions {
			v.isBuildIn = true
			v.loadedFromCorePackage = true
		}
		for _, v := range this.block.typeAliases {
			v.isBuildIn = true
		}
	}

	fn loadCorePackage() -> (err error) {
		if this.name == common.CorePackage {
			return null
		}
		pp, err := loaded.load(common.CorePackage)
		if err != null {
			return err
		}
		lucyBuildInPackage = pp.(Package)
		lucyBuildInPackage.markBuildIn()
		this.block.outer = lucyBuildInPackage.block
		lucyBuildInPackage.block.inheritedAttribute = new InheritedAttribute()
		return null
	}

	fn getImport(file string, accessName string) -> (i Import) {
		if this.files == null {
			return null
		}
		if t := this.files[file]; t != null && t.imports != null {
			return t.imports[accessName]
		} else {
			return null
		}
	}

	fn mkInitFunctions(bs []Block) {
		this.initFunctions = new []Function(len(bs))
		for k, b := range bs {
			b.isFunctionBlock = true
			f := new Function()
			b.Fn = f
			f.pos = b.pos
			f.block = b
			this.initFunctions[k] = f
			f.isPackageInitBlockFunction = true
			f.used = true
		}
	}

	fn shouldStop(errs []error) -> (should bool) {
		return len(this.errors)+len(errs) >= this.nErrors2Stop
	}

	fn insert(nodes []TopNode) -> ( errs []error = []error{}){
		if len(nodes) == 0 {
			errs = []error{new error("nothing to compile")}
			return
		}
		if this.block == null {
			this.block = new Block()
		}
		if this.block.inheritedAttribute == null {
			this.block.inheritedAttribute = new InheritedAttribute()
		}
		if err := this.loadCorePackage(); err != null {
			printf("load lucy buildin package failed,err:%s\n", err.getMessage())
			os.exit(1)
		}
		bs := []Block{}
		expressions := []Expression{}
		for _, v := range nodes {
			if _,ok := v.node.(Comment) ; ok {
				continue
			}
			if _,ok := v.node.(Line) ; ok {
				continue
			}
			if t,ok := v.node.(Block) ; ok {
				bs.append(t)
				continue
			}
			if t,ok := v.node.(Function) ; ok {
				t.isGlobal = true
				err := this.block.insert(t.name, t.pos, t)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t ,ok := v.node.(Enum) ; ok {
				t.isGlobal = true
				err := this.block.insert(t.name, t.pos,t)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t,ok := v.node.(Class) ; ok {
				t.isGlobal = true
				err := this.block.insert(t.name, t.pos, t)
				if err != null {
					errs.append(err)
				}
				continue
			}

			if t,ok := v.node.(TypeAlias) ; ok {
				err := this.block.insert(t.name, t.pos, t.Type)
				t.Type.alias = t
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t,ok := v.node.(Constant) ; ok{
				t.isGlobal = true
				err := this.block.insert(t.name, t.pos, t)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t ,ok:= v.node.(Import) ; ok {
				if t.accessName != null && t.accessName == UnderScore{
					errs.append(new error(sprintf("%s '%s' is not a valid name" , t.pos.errMsgPrefix()  , UnderScore)))
				}else {
					err := this.insertImport(t)
					if err != null {
						errs.append(err)
					}
				}
			}
			if t ,ok:= v.node.(Expression) ; ok {
				if t.Type == ExpressionTypeVar || t.Type == ExpressionTypeVarAssign {
					expressions.append(t)
				} else {
					errs.append(new error(sprintf("%s cannot have '%s' in top",
						t.pos.errMsgPrefix(), t.op)))
				}	
			}
		}
		
		if len(expressions) > 0 {
			s := new []Statement(len(expressions))
			for k, v := range expressions {
			    s[k] = new  Statement()
				s[k].Type = StatementTypeExpression
				s[k].Expression = v
				s[k].pos = v.pos
			}
			b := new Block()
			b.pos = expressions[0].pos
			b.statements = s
			t := []Block{b}
			t.appendAll(bs)
			bs = t
		}
		this.mkInitFunctions(bs)
		return
	}

	public fn typeCheck(nodes []TopNode) -> (es []error) {
		this.block.inheritedAttribute.p = this
		if t := this.insert(nodes) ; len(t) > 0 {
			return t
		}
		if this.nErrors2Stop <= 2 {
			this.nErrors2Stop = 10
		}
		this.errors = []error{}
		if this.block == null {
		    panic("block is null")
		}
		this.errors.appendAll(this.block.checkConstants())
		for _, v := range this.block.constants {
			if v.findUsage {
				v.findUsageInstances = []Usage{}
				this.findUsageIsGlobal = true 
				this.findUsage = v.findUsageInstances
			}
		}
		for _, v := range this.block.enums {
			if v.findUsage {
				v.findUsageInstances = []Usage{}
				this.findUsageIsGlobal = true 
				this.findUsage = v.findUsageInstances
			}
			for _,vv := range v.enums {
				vv.findUsageInstances = []Usage{}
				this.findUsageIsGlobal = true 
				this.findUsage = vv.findUsageInstances
			}
			v.name = this.name + "/" + v.name
			this.errors.appendAll(v.check())
		}
		for _, v := range this.block.typeAliases {
			if v.locateDefinition {
				this.locateDefinition = v.pos 
			}
			if v.findUsage {
				v.alias.findUsageInstances = []Usage{}
				this.findUsageIsGlobal = true 
				this.findUsage = v.alias.findUsageInstances
			}
			err := v.resolve(this.block)
			if err != null {
				this.errors.append(err)
			}
		}
		for _, v := range this.block.functions {
			if v.findUsage {
				v.findUsageInstances = []Usage{}
				this.findUsageIsGlobal = true 
				this.findUsage = v.findUsageInstances
			}
			if v.isBuildIn {
				continue
			}
			v.block.inherit(this.block)
			v.block.inheritedAttribute.Function = v
			v.checkParametersAndReturns(this.errors, false, false)
			if v.isGlobalMain() {
				this.hasMain = true
				defineMainOK := false
				if len(v.Type.parameterList) == 1 {
					defineMainOK = v.Type.parameterList[0].Type.Type == VariableTypeArray &&
						v.Type.parameterList[0].Type.array.Type == VariableTypeString
				}
				if defineMainOK == false {
					this.errors.append(new error(sprintf("%s function '%s' expect declared as 'main(args []string)'",
							errMsgPrefix(v.pos), MainFunctionName)))
				}
			}
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.block.Classes {
			v.name = this.name + "/" + v.name
			if v.findUsage {
				v.findUsageInstances = []Usage{}
				this.findUsageIsGlobal = true 
				this.findUsage = v.findUsageInstances
			}
			if v.locateDefinition {
				this.locateDefinition = v.pos 
			}
			this.errors.appendAll(v.block.checkConstants())
			v.block.inherit(this.block)
			v.block.inheritedAttribute.Class = v
		}
		for _, v := range this.block.Classes { 
			v.mkDefaultConstruction()
		} 
		for _, v := range this.block.Classes {
			err := v.resolveFather()
			if err != null {
				this.errors.append(err)
			}
			this.errors.appendAll(v.resolveInterfaces())
			this.errors.appendAll (v.resolveFieldsAndMethodsType())
		}

		for _, v := range this.block.Classes {
			es = v.checkPhase1()
			this.errors.appendAll(es)
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.initFunctions {
			this.errors.appendAll( v.check(this.block))
			if this.shouldStop(null) {
				return this.errors
			}
		}
		if this.onlyAnalyzeGlobals {
			return this.errors
		}
		for _, v := range this.block.functions {
			if v.TemplateFunction != null {
				continue
			}
			this.errors.appendAll(v.checkReturnVarExpression())
		}
		for _, v := range this.block.Classes {
			this.errors.appendAll( v.checkPhase2())
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.block.functions {
			if v.isBuildIn {
				continue
			}
			if v.TemplateFunction != null {
				continue
			}
			v.checkBlock(this.errors)
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.statementLevelFunctions {
			v.isClosureFunction = v.Closure.captureCount(v) > 0
		}
		for _, v := range this.statementLevelClass {
			for f, meta := range v.closure.functions {
				if f.isClosureFunction == false {
					continue
				}
				this.errors.append( new error(sprintf("%s trying to access capture function '%s' from outside",
					meta.pos.errMsgPrefix(), f.name)))
			}
		}
		if this.shouldStop(null) {
			return this.errors
		}
		this.errors.appendAll(this.checkUnUsedPackage())
		return this.errors
	}
	
	fn checkUnUsedPackage() -> (errs []error=[]error{}  ) {
		if this.disableCheckUnuse {
			return null
		}
		for _, v := range this.files {
			for _, i := range v.imports {
				if i.used == false {
					errs.append(new error(sprintf("%s '%s' imported not used",
						errMsgPrefix(i.pos), i.Import)))
				}
			}
		}
		return errs
	}
	
	fn insertSouceFiles(filenames []string) {
		if this.files == null {
			this.files = new map {string->SourceFile} ()
		}
		for v := range filenames {
			x := this.files[v]
			if x == null {
				x = new SourceFile(v)
				this.files[v] = x
			}
		}
	}

	public fn insertImport(i Import) -> (err error) {
		if this.files == null {
			this.files = new map {string->SourceFile} ()
		}
		x := this.files[i.pos.filename]
		if x == null {
			x = new SourceFile(i.pos.filename)
			this.files[i.pos.filename] = x
		}
		return x.insertImport(i)
	}

	public fn setFileDirty(filename string ) {
		//set right file is "isDirty"
		this.files[filename].isDirty = true
	}

	public fn getDirtyFiles() ->(files map{string->bool}) {
		files = new map{string->bool}()
		for f := range this.files {
			if f.isDirty {
				files[f.filename] = true 
			}
		}
	}


}
