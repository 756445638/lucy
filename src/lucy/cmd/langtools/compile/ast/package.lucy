
import "lucy/os"
import "lucy/cmd/langtools/compile/common"
import "java/lang/Object"


public class Package {
	public name                         string
	public block                        Block = new Block() // package always have a default block
	files                        map {string -> SourceFile}
	public initFunctions                []Function
	public nErrors2Stop                 int // number of errors should stop compile
	errors                       []error
	public triggerPackageInitMethodName string //
	statementLevelFunctions      []Function
	statementLevelClass          []Class
	disableCheckUnuse  				bool 
	javaPackage JavaPackage
	public hasMain bool 
	public matchFile string 
	public matchLine int 
	public loader LoadImport
	/*
		for lucy tool goto definition
	*/
	public locateDefinition Pos 

	/*
		for lucy tool hover
	*/
	hover Hover
	/*
		for usage 
	*/
	public findUsage []Usage 
	public findUsageIsGlobal bool 
	
	public onlyAnalyzeGlobals bool 

	public renameIsGlobal bool 

	public autoCompletionItems []AutoCompletionItem

	public lucyBuildInPackage Package 
	
	public fn matchFileAndLine(file string , name string ,  startLine int , endLine int ) ->(need bool){
		if this.matchFile == null || this.matchFile == "" {  // no match at all 
			return true 
		}
		need = this.matchFile == file
		if need == false {  // file not match
			// printf("file '%s' not match\n" , file)
			return false  
		}
		if this.matchLine == -1 {
			return  true // no match line 
		}
		if false ==  startLine <= this.matchLine && this.matchLine <= endLine {
			// printf("'%s' not match\n" , name)
			return false 
		}
		return true 
	}
	
	public fn Package(name string,disableCheckUnuse bool , loader LoadImport){
		this.super()
		this.disableCheckUnuse = disableCheckUnuse
		this.name =  name
		this.matchLine =  -1
		this.loader = loader
	}
	public fn locateDefinitionOrAutoCompletionFetched() ->(fetched bool) {
		fetched = this.locateDefinition != null || 
			len(this.autoCompletionItems) > 0 
	}
	
	fn isSame(compare Package) -> (is bool) {
		return this.name == compare.name
	}

	fn markBuildIn() {
		for _, v := range this.block.variables {
			v.isBuildIn = true
		}
		for _, v := range this.block.constants {
			v.isBuildIn = true
		}
		for _, v := range this.block.enums {
			v.isBuildIn = true
		}
		for _, v := range this.block.classes {
			v.isBuildIn = true
		}
		for _, v := range this.block.functions {
			v.isBuildIn = true
			v.loadedFromCorePackage = true
		}
		for _, v := range this.block.typeAliases {
			v.isBuildIn = true
		}
	}

	fn loadCorePackage() -> (err error) {
		if this.name == common.CorePackage {
			return null
		}
		var pp Object
		pp, err = this.load(common.CorePackage)
		if err != null {
			return err
		}
		lucyBuildInPackage := pp.(Package)
		lucyBuildInPackage.markBuildIn()
		this.block.outer = lucyBuildInPackage.block
		lucyBuildInPackage.block.inheritedAttribute = new InheritedAttribute()
		this.lucyBuildInPackage = lucyBuildInPackage
		return null
	}
	
	fn getImport(file string, accessName string) -> (i Import) {
		if this.files == null {
			return null
		}
		if t := this.files[file]; t != null && t.imports != null {
			return t.imports[accessName]
		} else {
			return null
		}
	}

	fn mkInitFunctions(bs []Block) {
		this.initFunctions = new []Function(len(bs))
		for k, b := range bs {
			b.isFunctionBlock = true
			f := new Function()
			b.Fn = f
			f.pos = b.pos
			f.block = b
			this.initFunctions[k] = f
			f.isPackageInitBlockFunction = true
			f.used = true
		}
	}
	fn shouldStop(errs []error) -> (should bool) {
		return len(this.errors)+len(errs) >= this.nErrors2Stop
	}

	fn insert(nodes []TopNode) -> ( errs []error = []error{}){
		if len(nodes) == 0 {
			errs = []error{new error("nothing to compile")}
			return
		}
		if this.block == null {
			this.block = new Block()
		}
		if this.block.inheritedAttribute == null {
			this.block.inheritedAttribute = new InheritedAttribute()
		}
		if err := this.loadCorePackage(); err != null {
			printf("load lucy buildin package failed,err:%s\n", err.getMessage())
			os.exit(1)
		}
		bs := []Block{}
		expressions := []Expression{}
		for _, v := range nodes {
			if _,ok := v.node.(Comment) ; ok {
				continue
			}
			if _,ok := v.node.(Line) ; ok {
				continue
			}
			if t,ok := v.node.(Block) ; ok {
				bs.append(t)
				continue
			}
			if t,ok := v.node.(Function) ; ok {
				t.isGlobal = true
				err := this.block.insert(t.name, t.pos, t)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t ,ok := v.node.(Enum) ; ok {
				t.isGlobal = true
				err := this.block.insert(t.name, t.pos,t)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t,ok := v.node.(Class) ; ok {
				t.isGlobal = true
				err := this.block.insert(t.name, t.pos, t)
				if err != null {
					errs.append(err)
				}
				continue
			}
			
			if t,ok := v.node.(TypeAlias) ; ok {
				err := this.block.insert(t.name, t.pos, t.Type)
				t.Type.alias = t
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t,ok := v.node.(Constant) ; ok{
				t.isGlobal = true
				err := this.block.insert(t.name, t.pos, t)
				if err != null {
					errs.append(err)
				}
				continue
			}
			if t ,ok:= v.node.(Import) ; ok {
				if t.accessName != null && t.accessName == UnderScore{
					errs.append(new error(sprintf("%s '%s' is not a valid name" , t.pos.errMsgPrefix()  , UnderScore)))
				}else {
					err := this.insertImport(t)
					if err != null {
						errs.append(err)
					}
				}
			}
			if t ,ok:= v.node.(Expression) ; ok {
				if t.Type == ExpressionTypeVar || t.Type == ExpressionTypeVarAssign {
					expressions.append(t)
				} else {
					errs.append(new error(sprintf("%s cannot have '%s' in top",
						t.pos.errMsgPrefix(), t.op)))
				}	
			}
		}
		
		if len(expressions) > 0 {
			s := new []Statement(len(expressions))
			for k, v := range expressions {
			    s[k] = new  Statement()
				s[k].Type = StatementTypeExpression
				s[k].Expression = v
				s[k].pos = v.pos
			}
			b := new Block()
			b.pos = expressions[0].pos
			b.statements = s
			t := []Block{b}
			t.appendAll(bs)
			bs = t
		}
		this.mkInitFunctions(bs)
		return
	}

	public fn typeCheck(nodes []TopNode) -> (es []error = []error{}) {
		this.block.inheritedAttribute.p = this
		if t := this.insert(nodes) ; len(t) > 0 {
			es.appendAll(t)
		}
		if this.nErrors2Stop <= 2 {
			this.nErrors2Stop = 10
		}
		this.errors = []error{}
		if this.block == null {
		    panic("block is null")
		}
		this.errors.appendAll(this.block.checkConstants())
		for _, v := range this.block.constants {
			if v.findUsage {
				u := new Usage()
                u.Type = "declaration"
                u.pos = v.pos 
				v.findUsageInstances = [u]
				this.findUsageIsGlobal = true 
				this.findUsage = v.findUsageInstances
			}
		}
		if this.locateDefinitionOrAutoCompletionFetched() {
			return this.errors 
		}
		for _, v := range this.block.enums {
			v.name = this.name + "/" + v.name
			this.errors.appendAll(v.check(this.block))
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
		}
		if this.locateDefinitionOrAutoCompletionFetched() {
			return this.errors 
		}
		for _, v := range this.block.typeAliases {
			if v.alias.locateDefinition {
				this.locateDefinition = v.alias.pos
				return this.errors 
			}
			if v.alias.findUsage {
				u := new Usage()
                u.Type = "declaration"
                u.pos = v.pos 
				v.alias.findUsageInstances = [u]
				this.findUsageIsGlobal = true 
				this.findUsage = v.alias.findUsageInstances
			}
			err := v.resolve(this.block)
			if err != null {
				this.errors.append(err)
			}
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
		}

		for _, v := range this.block.functions {
			if v.locateDefinition {
				this.locateDefinition = v.pos 
				return this.errors 
			}
			if v.findUsage {
				u := new Usage()
                u.Type = "declaration"
                u.pos = v.pos 
				v.findUsageInstances = [u]
				this.findUsageIsGlobal = true 
				this.findUsage = v.findUsageInstances
			}
		}

		for _, v := range this.block.functions {
			if v.isBuildIn {
				continue
			}
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
			v.block.inherit(this.block)
			v.block.inheritedAttribute.Function = v
			v.checkParametersAndReturns(this.errors, false, false)
			if v.isGlobalMain() {
				this.hasMain = true
				defineMainOK := false
				if len(v.Type.parameterList) == 1 {
					defineMainOK = v.Type.parameterList[0].Type.Type == VariableTypeArray &&
						v.Type.parameterList[0].Type.array.Type == VariableTypeString
				}
				if defineMainOK == false {
					this.errors.append(new error(sprintf("%s function '%s' expect declared as 'main(args []string)'",
						errMsgPrefix(v.pos), MainFunctionName)))
				}
			}
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.block.classes {
			if v.locateDefinition {
				this.locateDefinition = v.pos 
				return this.errors
			}
			v.name = this.name + "/" + v.name
			if v.findUsage {
				u := new Usage()
                u.Type = "declaration"
                u.pos = v.pos 
				v.findUsageInstances = [u]
				this.findUsageIsGlobal = true 
				this.findUsage = v.findUsageInstances
			}
			v.block.inherit(this.block)
			assert(v.block.inheritedAttribute.p != null)
			this.errors.appendAll(v.block.checkConstants())
			v.block.inheritedAttribute.Class = v
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
		}
		if this.locateDefinitionOrAutoCompletionFetched() {
			return this.errors 
		}
		for _, v := range this.block.classes { 
			v.mkDefaultConstruction()
		} 
		for _, v := range this.block.classes {
			err := v.resolveFather()
			if err != null {
				this.errors.append(err)
			}
			this.errors.appendAll(v.resolveInterfaces())
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
			this.errors.appendAll (v.resolveFieldsAndMethodsType())
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
		}
		for _, v := range this.block.classes {
			assert(v.block.inheritedAttribute.p != null)
			es = v.checkPhase1()
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
			this.errors.appendAll(es)
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.initFunctions {
			this.errors.appendAll( v.check(this.block))
			if this.shouldStop(null) {
				return this.errors
			}
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
		}
		if this.onlyAnalyzeGlobals {
			return this.errors
		}
		for _, v := range this.block.functions {
			if v.TemplateFunction != null {
				continue
			}
			if this.matchFileAndLine(v.pos.filename , v.name,   v.startLine , v.endLine ) == false {
				continue
			}
			this.errors.appendAll(v.checkReturnVarExpression())
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
		}
		for _, v := range this.block.classes {
			if this.matchFileAndLine(v.pos.filename ,v.name, v.startLine , v.endLine) == false {
				continue
			}
			this.errors.appendAll(v.checkPhase2())
			if this.shouldStop(null) {
				return this.errors
			}
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
		}
		for _, v := range this.block.functions {
			if v.isBuildIn {
				continue
			}
			if this.matchFileAndLine(v.pos.filename ,v.name,v.startLine , v.endLine) == false {
				continue
			}
			if v.TemplateFunction != null {
				continue
			}
			v.checkBlock(this.errors)
			if this.shouldStop(null) {
				return this.errors
			}
			if this.locateDefinitionOrAutoCompletionFetched() {
				return this.errors 
			}
		}
		for _, v := range this.statementLevelFunctions {
			v.isClosureFunction = v.Closure.captureCount(v) > 0
		}
		for _, v := range this.statementLevelClass {
			for f, meta := range v.closure.functions {
				if f.isClosureFunction == false {
					continue
				}
				this.errors.append( new error(sprintf("%s trying to access capture function '%s' from outside",
					meta.pos.errMsgPrefix(), f.name)))
			}
		}
		if this.shouldStop(null) {
			return this.errors
		}
		this.errors.appendAll(this.checkUnUsedPackage())
		return this.errors
	}
	
	fn checkUnUsedPackage() -> (errs []error=[]error{}  ) {
		if this.disableCheckUnuse {
			return null
		}
		for _, v := range this.files {
			for _, i := range v.imports {
				if i.used == false {
					errs.append(new error(sprintf("%s '%s' imported not used",
						errMsgPrefix(i.pos), i.Import)))
				}
			}
		}
		return errs
	}
	
	fn insertSouceFiles(filenames []string) {
		if this.files == null {
			this.files = new map {string->SourceFile} ()
		}
		for v := range filenames {
			x := this.files[v]
			if x == null {
				x = new SourceFile(v)
				this.files[v] = x
			}
		}
	}

	public fn insertImport(i Import) -> (err error) {
		if this.files == null {
			this.files = new map {string->SourceFile} ()
		}
		x := this.files[i.pos.filename]
		if x == null {
			x = new SourceFile(i.pos.filename)
			this.files[i.pos.filename] = x
		}
		return x.insertImport(i)
	}

	public fn setFileDirty(filename string ) {
		//set right file is "isDirty"
		this.files[filename].isDirty = true
	}

	public fn getDirtyFiles() ->(files map{string->bool}) {
		files = new map{string->bool}()
		for f := range this.files {
			if f.isDirty {
				files[f.filename] = true 
			}
		}
	}
	
	fn load(resource string) -> (x Object, err error) {
		if resource == "" {
			panic("null string")
		}
		t, err := this.loader.LoadImport(resource)
		if pp, ok := t.(Package); ok {
			if pp.name == common.CorePackage {
				pp.markBuildIn()
			}
		}
		if c, ok := t.(Class); ok && c != null {
			if c.isJava == false {
				return null, new error(sprintf("load lucy class not allow"))
			}
		}
		return t, err
	}
	

	fn loadClass(className string) -> (c Class,err error) {
		x, err := this.loader.LoadImport(className)
		if err != null {
			return null, err
		}
		if t, ok := x.(Class); ok == false || t == null {
			return null, new error(sprintf("'%s' is not class", className))
		}
		cc := x.(Class)
		return cc, null
	}

}



