 
import "java/lang/Object"
import "lucy/cmd/langtools/compile/common"


public class Package {
	public name                         string
	public loadedPackages               map { string -> Package }
	loadedClasses                map { string -> Class }
	public block                        Block // package always have a default block
	files                        map { string -> SourceFile}
	public initFunctions                []Function
	public nErrors2Stop                 int // number of errors should stop compile
	errors                       []error
	public triggerPackageInitMethodName string //
	unUsedPackage                map{string ->  Import }
	statementLevelFunctions      []Function
	statementLevelClass          []Class

	fn isSame(compare Package) -> (is bool) {
		return this.name == compare.name
	}

	fn markBuildIn() {
		for _, v := range this.block.Variables {
			v.isBuildIn = true
		}
		for _, v := range this.block.constants {
			v.isBuildIn = true
		}
		for _, v := range this.block.Enums {
			v.isBuildIn = true
		}
		for _, v := range this.block.Classes {
			v.isBuildIn = true
		}
		for _, v := range this.block.Functions {
			v.isBuildIn = true
			v.loadedFromCorePackage = true
		}
		for _, v := range this.block.TypeAliases {
			v.isBuildIn = true
		}
	}
	fn loadCorePackage() -> (err error) {
		if this.name == common.CorePackage {
			return null
		}
		pp, err := this.load(common.CorePackage)
		if err != null {
			return err
		}
		lucyBuildInPackage = pp.(Package)
		lucyBuildInPackage.markBuildIn()
		this.block.outer = lucyBuildInPackage.block
		return null
	}

	fn getImport(file string, accessName string) -> (i Import) {
		if this.files == null {
			return null
		}
		if file := this.files[file]; file == null {
			return null
		} else {
			return file.Imports[accessName]
		}
	}

	fn mkInitFunctions(bs []Block) {
		this.initFunctions = new []Function(len(bs))
		for k, b := range bs {
			b.isFunctionBlock = true
			f := new Function()
			b.Fn = f
			f.pos = b.pos
			f.block = b
			this.initFunctions[k] = f
			f.isPackageInitBlockFunction = true
			f.used = true
		}
	}

	fn shouldStop(errs []error) -> (should bool) {
		return len(this.errors)+len(errs) >= this.nErrors2Stop
	}

	fn TypeCheck() -> (es []error) {
		if this.nErrors2Stop <= 2 {
			this.nErrors2Stop = 10
		}
		this.errors = []error{}
		this.errors.appendAll(this.block.checkConstants())
		for _, v := range this.block.Enums {
			v.name = this.name + "/" + v.name
			this.errors.appendAll(v.check())
		}
		for _, v := range this.block.TypeAliases {
			err := v.resolve(PackageBeenCompile.block)
			if err != null {
				this.errors.append(err)
			}
		}
		for _, v := range this.block.Functions {
			if v.isBuildIn {
				continue
			}
			v.block.inherit(this.block)
			v.block.inheritedAttribute.Function = v
			v.checkParametersAndReturns(this.errors, false, false)
			if v.isGlobalMain() {
				defineMainOK := false
				if len(v.Type.ParameterList) == 1 {
					defineMainOK = v.Type.ParameterList[0].Type.Type == VariableTypeArray &&
						v.Type.ParameterList[0].Type.array.Type == VariableTypeString
				}
				if defineMainOK == false {
					this.errors.append(new error(sprintf("%s function '%s' expect declared as 'main(args []string)'",
							errMsgPrefix(v.pos), MainFunctionName)))
				}
			}
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.block.Classes {
			v.name = this.name + "/" + v.name
			this.errors.appendAll(v.block.checkConstants())
			v.mkDefaultConstruction()
			v.block.inherit(PackageBeenCompile.block)
			v.block.inheritedAttribute.Class = v
		}

		for _, v := range this.block.Classes {
			err := v.resolveFather()
			if err != null {
				this.errors.append(err)
			}
			this.errors.appendAll(v.resolveInterfaces())
			this.errors.appendAll (v.resolveFieldsAndMethodsType())
		}

		for _, v := range this.block.Classes {
			es := v.checkPhase1()
			this.errors.appendAll(es)
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.block.Functions {
			if v.TemplateFunction != null {
				continue
			}
			this.errors.appendAll( v.checkReturnVarExpression())
		}
		for _, v := range this.initFunctions {
			this.errors.appendAll( v.check(this.block))
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.block.Classes {
			this.errors.appendAll( v.checkPhase2())
			if this.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.block.Functions {
			if v.isBuildIn {
				continue
			}
			if v.TemplateFunction != null {
				continue
			}
			v.checkBlock(this.errors)
			if PackageBeenCompile.shouldStop(null) {
				return this.errors
			}
		}
		for _, v := range this.statementLevelFunctions {
			v.isClosureFunction = v.Closure.captureCount(v) > 0
		}
		for _, v := range this.statementLevelClass {
			for f, meta := range v.closure.Functions {
				if f.isClosureFunction == false {
					continue
				}
				this.errors.append( new error(sprintf("%s trying to access capture function '%s' from outside",
						meta.pos.errMsgPrefix(), f.name)))
			}
		}
		if this.shouldStop(null) {
			return this.errors
		}
		//this.errors.appendAll(this.checkUnUsedPackage()...)
		return this.errors
	}

	/*
		load package or class
	*/
	fn load(resource string) -> (x Object, err error) {
		if resource == "" {
			panic("null string")
		}
		if this.loadedClasses == null {
			this.loadedClasses = new map {string -> Class}()
		}
		if t := this.loadedClasses[resource]; t != null {
			return t, null
		}
		if this.loadedPackages == null {
			this.loadedPackages = new map { string -> Package} ()
		}
		if t := this.loadedPackages[resource]; t != null {
			return t, null
		}
		t, err := ImportsLoader.LoadImport(resource)
		if pp, ok := t.(Package); ok && pp != null {
			PackageBeenCompile.loadedPackages[resource] = pp
			this.mkClassCache(pp)
			if pp.name == common.CorePackage {
				pp.markBuildIn()
			}
		}
		if c, ok := t.(Class); ok && c != null {
			if c.isJava == false {
				return null, new error(sprintf("load lucy class not allow"))
			}
			PackageBeenCompile.loadedClasses[resource] = c
		}
		return t, err
	}


    /*
    //TODO::
	fn checkUnUsedPackage() -> (errs []error=[]error{}  ) {
		if common.CompileFlags.DisableCheckUnUse.getValue() {
			return null
		}
		for _, v := range this.files {
			for _, i := range v.Imports {
				if i.used == false {
					errs = append(errs, new error(sprintf("%s '%s' imported not used",
						errMsgPrefix(i.pos), i.Import)))
				}
			}
		}
		for _, i := range this.unUsedPackage {
			pp, err := this.load(i.Import)
			if err != null {
				errs = append(errs, new error(sprintf("%s %s",
					errMsgPrefix(i.pos), err.getMessage())))
				continue
			}
			if ppp, ok := pp.(Package); ok == false {
				errs = append(errs, new error(sprintf("%s '%s' not a package",
					errMsgPrefix(i.pos), i.Import)))
			} else {
				if ppp.triggerPackageInitMethodName == "" {
					errs.append(new error(sprintf("%s  package named '%s' have no global vars and package "+
							        "init blocks, no need to trigger package init method",
							        errMsgPrefix(i.pos), i.Import)))
				}
			}
		}
		return errs
	}
    */


	fn loadClass(className string) -> (c Class,err error) {
		if this.loadedClasses == null {
			this.loadedClasses = new map{ string -> Class }()
		}
		if c := this.loadedClasses[className];   c != null {
			return c, null
		}
		x, err := ImportsLoader.LoadImport(className)
		if err != null {
			return null, err
		}
		if t, ok := x.(Class); ok == false || t == null {
			return null, new error(sprintf("'%s' is not class", className))
		}
		cc := x.(Class)
		this.loadedClasses[className] = cc
		return cc, null
	}

	fn mkClassCache(loadedPackage Package) {
		for _, v := range loadedPackage.block.Classes {
			this.loadedClasses[v.name] = v // binary name
		}
	}

	fn insertImport(i Import) -> (err error) {
		if this.files == null {
			this.files = new map { string -> SourceFile } ()
		}
		x := this.files[i.pos.filename]
		if x == null {
			x = new SourceFile()
			this.files[i.pos.filename] = x
		}
		return x.insertImport(i)
	}	
}









