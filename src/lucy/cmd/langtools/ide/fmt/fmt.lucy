import "lucy/cmd/langtools/compile/ast"
import "java/io"


class Fmt {

    
    fn fmt(nodes []ast.TopNode) -> (format string = ""){
        for k, n := range nodes {
            if t,ok := n.node.(ast.Block) ; ok {
                format += this.formatBlock("" , t)
            }
            if t,ok := n.node.(ast.Function) ; ok {
                format += this.formatFunction("" , t)
            }
            if t,ok := n.node.(ast.Enum) ; ok {
                format += this.formatEnum("" , t)
            }
            if t,ok := n.node.(ast.Class) ; ok {
                format += this.formatClass("" , t)
            }
            if t,ok := n.node.(ast.Constant) ; ok {
                format += this.formatConstant("" , t)
            }
            if t,ok := n.node.(ast.Import) ; ok {
                format += this.formatImport("" , t)
            }
            if t,ok := n.node.(ast.Expression) ; ok {
               format += this.formatExpression("" , t)
            }
            if t,ok := n.node.(ast.TypeAlias) ; ok {
               format += this.formatTypealais("" , t)
            }
        }
    }
    
    fn formatTypealais(indent string , a ast.TypeAlias ) -> (format string = "") {
        format = indent
        format += sprintf ("typealias %s = %s" , a.name ,a.Type.typeString())
    }
    fn formatConstant(indent string , f ast.Constant ) -> (format string = "") {
        
    }
    fn formatFunction(indent string , f ast.Function ) -> (format string = "") {
        
    }
    fn formatClass(indent string , c ast.Class) -> (format string = "") {

    }
    fn formatEnum(indent string , c ast.Enum) -> (format string = "") {

    }
    fn formatImport(indent string , c ast.Import) -> (format string = "") {

    }

    fn formatBlock(indent string , block ast.Block) -> (format string = ""){
        for s := range block.statements {
            format += this.formatStatement(indent + "    " ,s)
        }
    }

    fn formatStatement(indent string , s ast.Statement) -> (format string = ""){
        switch s.Type {
            case ast.StatementTypeExpression:
                format += this.formatExpression(indent , s.Expression)
            case ast.StatementTypeIf:
                format += this.formatIf(indent , s.StatementIf)
            case ast.StatementTypeBlock:
                format += this.formatBlock(indent , s.block)
            case ast.StatementTypeFor:
                format += this.formatFor(indent , s.StatementFor)
            case ast.StatementTypeContinue:
                format += "continue\n"
            case ast.StatementTypeReturn:
                format += this.formatReturn(indent , s.StatementReturn)
            case ast.StatementTypeBreak:
                format += "break\n"
            case ast.StatementTypeSwitch:
                format += this.formatSwitch(indent , s.StatementSwitch)
            case ast.StatementTypeWhen:
                format += this.formatWhen(indent , s.StatementWhen)
            case ast.StatementTypeLabel:
                format += s.StatementLabel.name + ":\n"
            case ast.StatementTypeGoTo:
                format += this.formatGoto(indent , s.StatementGoTo )
            case ast.StatementTypeDefer:
                format += this.formatDefer(indent , s.Defer )
            case ast.StatementTypeClass:
                format += this.formatClass(indent , s.Class)
            case ast.StatementTypeEnum:y
                format += this.formatEnum(indent , s.Enum)
            case ast.StatementTypeNop:
               //nothing
            case ast.StatementTypeImport:
                format += this.formatImport(indent , s.Import)
            case ast.StatementTypeTypeAlias :
                format += this.formatTypealias(indent , s.TpeAlias)
            case ast.StatementTypeComment:
                format += "//" + this.comment  
            case ast.StatementTypeCommentMultiLine:
                format += "/*" + this.comment + "*/"   
        }
        format += "\n"
    }

    
    fn formatTypealias(indent string ,a ast.TypeAlias )-> (format string = "") {

    }
    fn formatDefer(indent string ,s ast.StatementDefer)-> (format string = "") {
        
    }
    fn formatIf(indent string ,s ast.StatementIf)-> (format string = "") {

    }
    fn formatGoto(indent string , s ast.StatementGoTo)-> (format string = "") {
        
    }
    fn formatFor(indent string ,s ast.StatementFor)-> (format string = "") {
        
    }
    fn formatSwitch(indent string ,s ast.StatementSwitch)-> (format string = "") {
        
    }
    fn formatWhen(indent string ,s ast.StatementWhen)-> (format string = "") {
        
    }
    fn formatReturn(indent string ,s ast.StatementReturn)-> (format string = "") {
        
    }

    fn formatExpression(indent string ,e ast.Expression)-> (format string = "") {
        switch e.Type {
            case ast.ExpressionTypeNull:
                return indent + "null"
            case ast.ExpressionTypeBool:
                return indent + e.boolValue
            case ast.ExpressionTypeByte, ast.ExpressionTypeShort,ast.ExpressionTypeChar, ast.ExpressionTypeInt,
                ast.ExpressionTypeLong, ast.ExpressionTypeFloat , ast.ExpressionTypeDouble, ast.ExpressionTypeString:
                return indent + e.literalRaw  ;
            case ast.ExpressionTypeArray:
                array := e.data.(ast.ExpressionArray)
                if array.Type == null {
                    format = indent + "["
                    for k,v := range array.expressions{
                        format += this.formatExpression(indent + "    " , v)
                        if k != len(array.expressions) {
                            format += " , "
                        }
                    }
                    format += indent + "]"
                }else {
                    format = indent + "[]" + array.Type.typeString() + ""
                    for k,v := range array.expressions{
                        format += this.formatExpression(indent + "    " , v)
                        if k != len(array.expressions) {
                            format += " , "
                        }
                    }
                    format += indent + "}"
                }
            case ast.ExpressionTypeLogicalOr,ast.ExpressionTypeLogicalAnd,  ast.ExpressionTypeOr    ,ast.ExpressionTypeAnd ,
                ast.ExpressionTypeXor, ast.ExpressionTypeLsh , ast.ExpressionTypeRsh ,ast.ExpressionTypeAdd, 
                ast.ExpressionTypeSub , ast.ExpressionTypeMul  ,ast.ExpressionTypeDiv ,ast.ExpressionTypeMod:
                bin := e.data.(ast.ExpressionBinary)
                format = indent + this.formatExpression("" , bin.left) + " "+ 
                    e.op + " " + this.formatExpression("" , bin.right)
            case ast.ExpressionTypeVarAssign:

            case ast.ExpressionTypeAssign, ast.ExpressionTypePlusAssign ,
                ast.ExpressionTypeMinusAssign ,ast.ExpressionTypeMulAssign ,ast.ExpressionTypeDivAssign ,
                ast.ExpressionTypeModAssign,  ast.ExpressionTypeAndAssign ,ast.ExpressionTypeOrAssign  ,
                ast.ExpressionTypeXorAssign ,ast.ExpressionTypeLshAssign , ast.ExpressionTypeRshAssign ,
                ast.ExpressionTypeEq , ast.ExpressionTypeNe ,   ast.ExpressionTypeGe,
                ast.ExpressionTypeGt  , ast.ExpressionTypeLe  ,   ast.ExpressionTypeLt:
                bin := e.data.(ast.ExpressionBinary)
                var lefts []ast.Expression
                if bin.left.Type == ast.ExpressionTypeList {
                    lefts = bin.left.data.([]ast.Expression)
                }else {
                    lefts = [bin.left]
                }
                var rights []ast.Expression
                if bin.right.Type == ast.ExpressionTypeList {
                    rights = bin.right.data.([]ast.Expression)
                }else {
                    rights = [bin.right]
                }
                format = indent 
                for k,v := range lefts {
                    format += this.formatExpression("" , v)
                    if k != len(lefts) {
                        format += " , "
                    }
                }
                format += " " + e.op + " "
                for k,v := range rights {
                    format += this.formatExpression("" , v)
                    if k != len(rights) {
                        format += " , "
                    }
                }
            case ast.ExpressionTypeIndex:   
                index := e.data.(ast.ExpressionIndex)
                format = indent 
                format += this.formatExpression("" , index.Expression)+"["
                format += this.formatExpression("" , index.index)
                format += "]"
            case ast.ExpressionTypeSelection : 
                selection := e.data.(ast.ExpressionSelection)
                format = indent 
                if selection.Expression.Type == ast.ExpressionTypeDot {
                    format += "." + selection.name    
                }else {
                    format += this.formatExpression("" , selection.Expression)+"." + 
                    selection.name    
                }                               
            case ast.ExpressionTypeSelectionConst: 
                selection := e.data.(ast.ExpressionSelection)
                format = indent 
                format += this.formatExpression("" , selection.Expression)+"::" + 
                selection.name     
            case ast.ExpressionTypeMethodCall : 
                call := e.data.(ast.ExpressionMethodCall)
                format = indent
                if call.Expression.Type == ast.ExpressionTypeDot {
                    format += "." + call.name
                }else {
                    format += this.formatExpression("" ,call.Expression) + "." + call.name + " ("
                }
                for k,v := range call.args {
                    format += this.formatExpression("" ,v)
                    if k != len(call.args) - 1 {
                        format += " , "
                    }
                }
                format += " )"                           
            case ast.ExpressionTypeFunctionCall:  
                call := e.data.(ast.ExpressionFunctionCall)
                format = indent
                format += this.formatExpression("" , call.Expression) + " ("
                for k,v := range call.args {
                    format += this.formatExpression("" , v)
                    if k != len(call.args) - 1 {
                        format += " , "
                    }
                }
                format += ")"                                
            case ast.ExpressionTypeIncrement: 
                format = indent
                format += this.formatExpression("" , e.data.(ast.Expression)) + "++"                            
            case ast.ExpressionTypeDecrement:                                 
                format = indent
                format += this.formatExpression("" , e.data.(ast.Expression)) + "--"    
            case ast.ExpressionTypePrefixIncrement :
                format = indent
                format += "++" + this.formatExpression("" , e.data.(ast.Expression))                           
            case ast.ExpressionTypePrefixDecrement:  
                format = indent
                format += "--" + this.formatExpression("" , e.data.(ast.Expression))                     
            case ast.ExpressionTypeNegative ,ast.ExpressionTypeNot,ast.ExpressionTypeBitwiseNot:
                format = indent
                format += e.op + this.formatExpression("" , e.data.(ast.Expression))                             
            case ast.ExpressionTypeIdentifier:
                format = indent + e.data.(ast.ExpressionIdentifier)
            case ast.ExpressionTypeNew: 
                n := e.data.(ast.ExpressionNew)
                format = indent
                format += "new " + n.Type.typeString()+ " ("
                for k,v := range n.args {
                    format += this.formatExpression("" , v)
                    if k != len(n.args) - 1 {
                        format += " , "
                    }
                }
                format += ")"
            case ast.ExpressionTypeList: 
                list := e.data.([]ast.Expression)  
                format = indent
                for k,v := range list {
                    format += this.formatExpression("" , v )
                    if k != len(list) - 1 {
                        format += " , "
                    }
                }                              
            case ast.ExpressionTypeFunctionLiteral:

            case ast.ExpressionTypeVar:  
                vs := e.data.(ast.ExpressionVar)
                format = indent
                format += "var "
                for k,v := range vs.variables {
                    format += v.name 
                    if k != len(vs.variables) -1 {
                        format += " , "
                    }
                }  
                if vs.Type != null {
                    format += " " + vs.Type.typeString()
                }
                if len(vs.InitValues) > 0 {
                    format += " = "
                    for k,v := range vs.InitValues {
                        format += this.formatExpression("" , v ) 
                        if k != len(vs.InitValues) -1 {
                            format += " , "
                        }
                    }  
                }                            
            case ast.ExpressionTypeConst: 
                cs := e.data.([]ast.Constant)
                for v := range cs {
                    t := indent + "cosnt " + v.name + " "
                    if v.Type != null {
                        t += v.Type.typeString() + " "
                    }
                    t += "="
                    t += this.formatExpression("" , v.defaultValueExpression) + "\n"
                    format += t 
                }                                 
            case ast.ExpressionTypeCheckCast:
                c := e.data.(ast.ExpressionTypeConversion) 
                format =  indent
                format += c.Type.typeString() + "("
                format += this.formatExpression("" , c.Expression)
                format += ")"                         
            case ast.ExpressionTypeRange:
                format =  indent + "range " + this.formatExpression("" , e.data.(ast.Expression))
            case ast.ExpressionTypeSlice: 
                s := e.data.(ast.ExpressionSlice)
                format =  indent
                format += this.formatExpression("" , s.ExpressionOn ) + "["
                if s.start != null {
                    format += this.formatExpression("" , s.start ) + "["
                }
                if s.end != null {
                    format += this.formatExpression("" , s.end ) + "["
                }
                format += " : "
                format += "]"                                
            case ast.ExpressionTypeMap:    
                m := e.data.(ast.ExpressionMap)
                format =  indent
                if m.Type == null {
                    format += "{"
                    for k,v := range m.keyValuePairs {
                        format += this.formatExpression("" , v.key) + " -> " 
                        format += this.formatExpression("" , v.value)
                        if k != len(m.keyValuePairs) - 1 {
                            format += " , "
                        } 
                    }
                    format += "}"
                }else {
                    format += sprintf("map{%s -> %s}{" , m.Type.Map.K.typeString() ,  m.Type.Map.V.typeString())
                    for k,v := range m.keyValuePairs{
                        format += this.formatExpression("" , v.key) + " -> " 
                        format += this.formatExpression("" , v.value)
                        if k != len(m.keyValuePairs) - 1 {
                            format += " , "
                        } 
                    }
                    format += "}"
                }                             
            case ast.ExpressionTypeTypeAssert:
                a := e.data.(ast.ExpressionTypeAssert)   
                format = indent 
                format += this.formatExpression("" , a.Expression ) + ".("  
                format += a.Type.typeString()
                format += ")"                        
            case ast.ExpressionTypeQuestion: 
                q := e.data.(ast.ExpressionQuestion)
                format = indent 
                format += this.formatExpression("" , q.selection)  
                format += "?"
                format += this.formatExpression("" , q.True) 
                format += ":"
                format += this.formatExpression("" , q.False)                              
            case ast.ExpressionTypeGlobal:                  
                return indent + "global"               
            case ast.ExpressionTypeParenthesis : 
                return indent + "(" + this.formatExpression("" , e.data.(ast.Expression)) + ")"                                
            case ast.ExpressionTypeVArgs:   
                return      indent + this.formatExpression("" , e.data.(ast.Expression)) + "..."                            
            case ast.ExpressionTypeDot:   
                return indent + "."
            default:
                panic("not possible")                           
        }
    }







}















