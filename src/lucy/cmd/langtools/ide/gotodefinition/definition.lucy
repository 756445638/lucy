import "lucy/cmd/langtools/ide/utils"
import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/common" as langtoolsCommon 
import "java/io"
import "lucy/os"



class FindDefinition {
    lucyFiles []utils.LucyFile 
    packageName string
    printErr bool 
    fn FindDefinition(lucyFiles []utils.LucyFile , packageName string , printErr bool ){
        this.super()
        this.lucyFiles = lucyFiles
        this.packageName = packageName
        this.printErr = printErr 
    }
    
    fn find() -> (result ast.Pos){
        //parse ast and typecheck
        p , es := utils.parseAstAndTypeCheck(this.packageName , this.lucyFiles)
        if this.printErr{
            for v := range es{
                os.stderr.println(v.getMessage())
            }
        }
        if p.locatedIdentifierPos != null {
            if p.locatedIdentifierPos.loadDefinitionFromOutside != null {
                return this.loadDefinitionFromOutside(p.locatedIdentifierPos.loadDefinitionFromOutside)
            }
            return p.locatedIdentifierPos
        }
    }
       

    fn loadDefinitionFromOutside(out ast.LoadDefinitionFromOutside) -> (result ast.Pos) {
        paths := langtoolsCommon.getLucyPath()
        for v := range paths {
            if new io.File(v + "/" + out.packageName).isDirectory() == false {
                continue
            }
            p := v + "/" + out.packageName
            files := new io.File(p).list()
            for vv := range files {
                if vv.endsWith(".lucy") == false {
                    continue
                }
                lucyFile  := utils.readLucyFiles([p + "/" + vv])
                nodes,_ := utils.parseAst(lucyFile)
                if result = this.pinkNameFromNodes(out.name , nodes ) ;result != null {
                    return result
                }
            } 
            panic(sprintf("package '%s' not found" , out.name))
        }
        panic(sprintf("package '%s' not found" , out.packageName))
    }
    
    fn pinkNameFromNodes(name string , nodes []ast.TopNode ) -> (result ast.Pos) {
        for v := range nodes{
            if t,ok := v.node.(ast.Block) ; ok {
				//block has no name
				continue
			}
			if t,ok := v.node.(ast.Function) ; ok {
				if t.name == name {
                    return t.pos 
                }
			}
			if t ,ok := v.node.(ast.Enum) ; ok {
                if t.name == name {
                    return t.pos 
                }
                for vv := range t.enums {
                    if vv.name == name {
                        return vv.pos 
                    }
                }
			}
			if t,ok := v.node.(ast.Class) ; ok {
				if t.name == name {
                    return t.pos 
                }
			}
			if t,ok := v.node.(ast.TypeAlias) ; ok {
				if t.name == name {
                    return t.pos 
                }
			}
			if t,ok := v.node.(ast.Constant) ; ok{
				if t.name == name {
                    return t.pos 
                }
			}
			if t ,ok:= v.node.(ast.Import) ; ok {
				continue
			}
			if t ,ok:= v.node.(ast.Expression) ; ok {
                if t.Type == ast.ExpressionTypeVarAssign {
                    bin := t.data.(ast.ExpressionBinary)
                    var lefts []ast.Expression
                    if bin.left.Type == ast.ExpressionTypeList {
                        lefts = bin.left.data.([]ast.Expression)
                    } else {
                        lefts = []ast.Expression{bin.left}
                    }
                    for vv := range lefts {
                        if vv.Type == ast.ExpressionTypeIdentifier {
                            if t := vv.data.(ast.ExpressionIdentifier) ; t.name == name {
                                return vv.pos
                            }
                        }
                    }
                }
				if t.Type == ast.ExpressionTypeVar {
                    for vv := range t.data.(ast.ExpressionVar).variables {
                        if vv.name == name {
                            return vv.pos 
                        }
                    }
				} 
			}
        }
    }
    

}







