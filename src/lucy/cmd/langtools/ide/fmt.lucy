
//11111111111
import "lucy/cmd/langtools/compile/ast"
//22222
import "java/io"

/* 
    hello world
*/
public class Fmt {
    public fn fmt(nodes []ast.TopNode) -> (format string = ""){
        for k, n := range nodes {
            if t,ok := n.node.(ast.Comment) ; ok {
                if t.isMulti {
                    format += "\n" + sprintf("/*%s*/\n" , t.comment) + "\n"
                }else {
                    format += "\n" + "//" + t.comment + "\n"
                }
            }

            if t,ok := n.node.(ast.Block) ; ok {
                format += this.formatBlock("" , t) + "\n"
            }
            if t,ok := n.node.(ast.Function) ; ok {
                format += this.formatFunction("" , t) + "\n"
            }
            if t,ok := n.node.(ast.Enum) ; ok {
                format += this.formatEnum("" , t) + "\n"
            }
            if t,ok := n.node.(ast.Class) ; ok {
                format += this.formatClass("" , t) + "\n"
            }
            if t,ok := n.node.(ast.Constant) ; ok {
                format += this.formatConstant("" , t)  + "\n"
            }
            if t,ok := n.node.(ast.Import) ; ok {
                format += this.formatImport("" , t) + "\n"
            }
            if t,ok := n.node.(ast.Expression) ; ok {
               format += this.formatExpression("" , t) + "\n"
            }
            if t,ok := n.node.(ast.TypeAlias) ; ok {
               format += this.formatTypealais("" , t) + "\n"
            }
        }
    }
    
    fn formatTypealais(indent string , a ast.TypeAlias ) -> (format string = "") {
        format = indent
        format += sprintf ("typealias %s = %s" , a.name ,a.Type.typeName())
    }
    fn formatConstant(indent string , c ast.Constant ) -> (format string = "") {
        format = indent
        format += "const " + c.name
        if c.Type != null {
            format += " " + c.Type.typeName()
        }
        format += " =" +  c.defaultValueExpression.literalRaw
    }

    fn formatFunction(indent string , f ast.Function ) -> (format string = "") {
        format = indent 
        format += "fn "
        if f.name != null && f.name != "" {
            format += f.name + " "
        }
        format += "{"
        
        format += indent + "}"
    }

    fn formatClass(indent string , c ast.Class) -> (format string = "") {

    }

    fn formatEnum(indent string , e ast.Enum) -> (format string = "") {
        format = indent 
        format += "enum " + e.shortName + " {"
        for k,v := range e.enums{
            format += "    " + v.name
            if v.NoNeed != null {
                format += " " + this.formatExpression("" , v.NoNeed)
            }
            if k != len(e.enums) -1 {
                format += ","
            }
            format += "\n"

        }
        format += "}"
    }

    fn formatImport(indent string , i ast.Import) -> (format string = "") {
        format = indent
        format += "import \"" + i.Import + "\""
        if i.alias != null {
            format += " as " + i.alias 
        }
    }

    fn formatBlock(indent string , block ast.Block) -> (format string = ""){
        for s := range block.statements {
            format += this.formatStatement(indent + "    " ,s)
        }
    }

    fn formatStatement(indent string , s ast.Statement) -> (format string = ""){
        switch s.Type {
            case ast.StatementTypeExpression:
                format += this.formatExpression(indent , s.Expression)
            case ast.StatementTypeIf:
                format += this.formatIf(indent , s.StatementIf)
            case ast.StatementTypeBlock:
                format += this.formatBlock(indent , s.block)
            case ast.StatementTypeFor:
                format += this.formatFor(indent , s.StatementFor)
            case ast.StatementTypeContinue:
                format += "continue\n"
            case ast.StatementTypeReturn:
                format += this.formatReturn(indent , s.StatementReturn)
            case ast.StatementTypeBreak:
                format += "break\n"
            case ast.StatementTypeSwitch:
                format += this.formatSwitch(indent , s.StatementSwitch)
            case ast.StatementTypeWhen:
                format += this.formatWhen(indent , s.StatementWhen)
            case ast.StatementTypeLabel:
                format += s.StatementLabel.name + ":\n"
            case ast.StatementTypeGoTo:
                format += this.formatGoto(indent , s.StatementGoTo )
            case ast.StatementTypeDefer:
                format += this.formatDefer(indent , s.Defer )
            case ast.StatementTypeClass:
                format += this.formatClass(indent , s.Class)
            case ast.StatementTypeEnum:
                format += this.formatEnum(indent , s.Enum)
            case ast.StatementTypeNop:
               //nothing
            case ast.StatementTypeImport:
                format += this.formatImport(indent , s.Import)
            case ast.StatementTypeTypeAlias :
                format += this.formatTypealias(indent , s.TypeAlias)
            case ast.StatementTypeComment:
                format += "\n" + "//" + s.comment  
            case ast.StatementTypeCommentMultiLine:
                format += "\n" + "/*" + s.comment + "*/"   
        }
        format += "\n"
    }
    fn formatTypealias(indent string ,a ast.TypeAlias)-> (format string = "") {
        format = indent
        format += sprintf("typealias %s = %s" , a.name , a.aliasName) 
    }
    fn formatDefer(indent string ,d ast.StatementDefer)-> (format string = "") {
        format = indent
        format += "defer {"
        format += this.formatBlock(indent + "    " ,  d.block)
        format += indent + "}"
    }
    fn formatIf(indent string ,s ast.StatementIf)-> (format string = "") {
        format = indent
        format += "if "
        for v := range s.prefixExpressions {
            format += this.formatExpression("" , v)
            format += " ; "
        }
        format += this.formatExpression("" , s.condition)
        format += " {"
        format += this.formatBlock(indent + "    " , s.block )
        format += indent + "}"
        for _,v := range s.elseIfList{
            format += " else if " + this.formatExpression("" , v.condition) + " {"
            format += this.formatBlock(indent + "    " , v.block )
            format += indent + "}"
        }
        if s.Else != null {
            format += " else { "
            format += this.formatBlock(indent + "    " , s.Else)
            format += indent + "}"
        }
    }
    fn formatGoto(indent string , s ast.StatementGoTo)-> (format string = "") {
        format = indent
        format += "goto " + s.labelName
    }
    fn formatFor(indent string ,s ast.StatementFor)-> (format string = "") {
        format = indent
        format += "for"
        if s.Init != null {
            format += " " + this.formatExpression("" , s.Init)
        }
        if s.condition != null {
            if s.Init != null {
                format += ";"
            }
            format += " " + this.formatExpression("" , s.condition)
        }
        if s.increment != null {
            format += " " + this.formatExpression("" , s.increment)
        }
    }

    fn formatSwitch(indent string ,s ast.StatementSwitch)-> (format string = "") {
        
    }
    fn formatWhen(indent string ,w ast.StatementWhen)-> (format string = "") {
        format = indent
        format += "when"

    }
    fn formatReturn(indent string ,s ast.StatementReturn)-> (format string = "") {
        format = indent 
        format += "return "
        for k,v := range s.expressions{
            format += this.formatExpression("" , v)
            if k != len(s.expressions) - 1 {
                format += " , "
            }
        }
    }

    fn formatExpression(indent string ,e ast.Expression)-> (format string = "") {
        switch e.Type {
            case ast.ExpressionTypeNull:
                return indent + "null"
            case ast.ExpressionTypeBool:
                return indent + e.boolValue
            case ast.ExpressionTypeByte, ast.ExpressionTypeShort,ast.ExpressionTypeChar, ast.ExpressionTypeInt,
                ast.ExpressionTypeLong, ast.ExpressionTypeFloat , ast.ExpressionTypeDouble, ast.ExpressionTypeString:
                return indent + e.literalRaw  ;
            case ast.ExpressionTypeArray:
                array := e.data.(ast.ExpressionArray)
                if array.Type == null {
                    format = indent + "["
                    for k,v := range array.expressions{
                        format += this.formatExpression(indent + "    " , v)
                        if k != len(array.expressions) {
                            format += " , "
                        }
                    }
                    format += indent + "]"
                }else {
                    format = indent + "[]" + array.Type.typeName() + ""
                    for k,v := range array.expressions{
                        format += this.formatExpression(indent + "    " , v)
                        if k != len(array.expressions) {
                            format += " , "
                        }
                    }
                    format += indent + "}"
                }
            case ast.ExpressionTypeLogicalOr,ast.ExpressionTypeLogicalAnd,  ast.ExpressionTypeOr    ,ast.ExpressionTypeAnd ,
                ast.ExpressionTypeXor, ast.ExpressionTypeLsh , ast.ExpressionTypeRsh ,ast.ExpressionTypeAdd, 
                ast.ExpressionTypeSub , ast.ExpressionTypeMul  ,ast.ExpressionTypeDiv ,ast.ExpressionTypeMod:
                bin := e.data.(ast.ExpressionBinary)
                format = indent + this.formatExpression("" , bin.left) + " "+ 
                    e.op + " " + this.formatExpression("" , bin.right)
            case ast.ExpressionTypeVarAssign:

            case ast.ExpressionTypeAssign, ast.ExpressionTypePlusAssign ,
                ast.ExpressionTypeMinusAssign ,ast.ExpressionTypeMulAssign ,ast.ExpressionTypeDivAssign ,
                ast.ExpressionTypeModAssign,  ast.ExpressionTypeAndAssign ,ast.ExpressionTypeOrAssign  ,
                ast.ExpressionTypeXorAssign ,ast.ExpressionTypeLshAssign , ast.ExpressionTypeRshAssign ,
                ast.ExpressionTypeEq , ast.ExpressionTypeNe ,   ast.ExpressionTypeGe,
                ast.ExpressionTypeGt  , ast.ExpressionTypeLe  ,   ast.ExpressionTypeLt:
                bin := e.data.(ast.ExpressionBinary)
                var lefts []ast.Expression
                if bin.left.Type == ast.ExpressionTypeList {
                    lefts = bin.left.data.([]ast.Expression)
                }else {
                    lefts = [bin.left]
                }
                var rights []ast.Expression
                if bin.right.Type == ast.ExpressionTypeList {
                    rights = bin.right.data.([]ast.Expression)
                }else {
                    rights = [bin.right]
                }
                format = indent 
                for k,v := range lefts {
                    format += this.formatExpression("" , v)
                    if k != len(lefts) {
                        format += " , "
                    }
                }
                format += " " + e.op + " "
                for k,v := range rights {
                    format += this.formatExpression("" , v)
                    if k != len(rights) {
                        format += " , "
                    }
                }
            case ast.ExpressionTypeIndex:   
                index := e.data.(ast.ExpressionIndex)
                format = indent 
                format += this.formatExpression("" , index.Expression)+"["
                format += this.formatExpression("" , index.index)
                format += "]"
            case ast.ExpressionTypeSelection : 
                selection := e.data.(ast.ExpressionSelection)
                format = indent 
                if selection.Expression.Type == ast.ExpressionTypeDot {
                    format += "." + selection.name    
                }else {
                    format += this.formatExpression("" , selection.Expression)+"." + 
                    selection.name    
                }                               
            case ast.ExpressionTypeSelectionConst: 
                selection := e.data.(ast.ExpressionSelection)
                format = indent 
                format += this.formatExpression("" , selection.Expression)+"::" + 
                selection.name     
            case ast.ExpressionTypeMethodCall : 
                call := e.data.(ast.ExpressionMethodCall)
                format = indent
                if call.Expression.Type == ast.ExpressionTypeDot {
                    format += "." + call.name
                }else {
                    format += this.formatExpression("" ,call.Expression) + "." + call.name + " ("
                }
                for k,v := range call.args {
                    format += this.formatExpression("" ,v)
                    if k != len(call.args) - 1 {
                        format += " , "
                    }
                }
                format += " )"                           
            case ast.ExpressionTypeFunctionCall:  
                call := e.data.(ast.ExpressionFunctionCall)
                format = indent
                format += this.formatExpression("" , call.Expression) + " ("
                for k,v := range call.args {
                    format += this.formatExpression("" , v)
                    if k != len(call.args) - 1 {
                        format += " , "
                    }
                }
                format += ")"                                
            case ast.ExpressionTypeincrement: 
                format = indent
                format += this.formatExpression("" , e.data.(ast.Expression)) + "++"                            
            case ast.ExpressionTypeDecrement:                                 
                format = indent
                format += this.formatExpression("" , e.data.(ast.Expression)) + "--"    
            case ast.ExpressionTypePrefixincrement :
                format = indent
                format += "++" + this.formatExpression("" , e.data.(ast.Expression))                           
            case ast.ExpressionTypePrefixDecrement:  
                format = indent
                format += "--" + this.formatExpression("" , e.data.(ast.Expression))                     
            case ast.ExpressionTypeNegative ,ast.ExpressionTypeNot,ast.ExpressionTypeBitwiseNot:
                format = indent
                format += e.op + this.formatExpression("" , e.data.(ast.Expression))                             
            case ast.ExpressionTypeIdentifier:
                format = indent + e.data.(ast.ExpressionIdentifier)
            case ast.ExpressionTypeNew: 
                n := e.data.(ast.ExpressionNew)
                format = indent
                format += "new " + n.Type.typeName()+ " ("
                for k,v := range n.args {
                    format += this.formatExpression("" , v)
                    if k != len(n.args) - 1 {
                        format += " , "
                    }
                }
                format += ")"
            case ast.ExpressionTypeList: 
                list := e.data.([]ast.Expression)  
                format = indent
                for k,v := range list {
                    format += this.formatExpression("" , v )
                    if k != len(list) - 1 {
                        format += " , "
                    }
                }                              
            case ast.ExpressionTypeFunctionLiteral:
                this.formatFunction(indent , e.data.(ast.Function))
            case ast.ExpressionTypeVar:  
                vs := e.data.(ast.ExpressionVar)
                format = indent
                format += "var "
                for k,v := range vs.variables {
                    format += v.name 
                    if k != len(vs.variables) -1 {
                        format += " , "
                    }
                }  
                if vs.Type != null {
                    format += " " + vs.Type.typeName()
                }
                if len(vs.InitValues) > 0 {
                    format += " = "
                    for k,v := range vs.InitValues {
                        format += this.formatExpression("" , v ) 
                        if k != len(vs.InitValues) -1 {
                            format += " , "
                        }
                    }  
                }                            
            case ast.ExpressionTypeConst: 
                cs := e.data.([]ast.Constant)
                for v := range cs {
                    t := indent + "cosnt " + v.name + " "
                    if v.Type != null {
                        t += v.Type.typeName() + " "
                    }
                    t += "="
                    t += this.formatExpression("" , v.defaultValueExpression) + "\n"
                    format += t 
                }                                 
            case ast.ExpressionTypeCheckCast:
                c := e.data.(ast.ExpressionTypeConversion) 
                format =  indent
                format += c.Type.typeName() + "("
                format += this.formatExpression("" , c.Expression)
                format += ")"                         
            case ast.ExpressionTypeRange:
                format =  indent + "range " + this.formatExpression("" , e.data.(ast.Expression))
            case ast.ExpressionTypeSlice: 
                s := e.data.(ast.ExpressionSlice)
                format =  indent
                format += this.formatExpression("" , s.ExpressionOn ) + "["
                if s.start != null {
                    format += this.formatExpression("" , s.start ) + "["
                }
                if s.end != null {
                    format += this.formatExpression("" , s.end ) + "["
                }
                format += " : "
                format += "]"                                
            case ast.ExpressionTypeMap:    
                m := e.data.(ast.ExpressionMap)
                format =  indent
                if m.Type == null {
                    format += "{"
                    for k,v := range m.keyValuePairs {
                        format += this.formatExpression("" , v.key) + " -> " 
                        format += this.formatExpression("" , v.value)
                        if k != len(m.keyValuePairs) - 1 {
                            format += " , "
                        } 
                    }
                    format += "}"
                }else {
                    format += sprintf("map{%s -> %s}{" , m.Type.Map.K.typeName() ,  m.Type.Map.V.typeName())
                    for k,v := range m.keyValuePairs{
                        format += this.formatExpression("" , v.key) + " -> " 
                        format += this.formatExpression("" , v.value)
                        if k != len(m.keyValuePairs) - 1 {
                            format += " , "
                        } 
                    }
                    format += "}"
                }                             
            case ast.ExpressionTypeTypeAssert:
                a := e.data.(ast.ExpressionTypeAssert)   
                format = indent 
                format += this.formatExpression("" , a.Expression ) + ".("  
                format += a.Type.typeName()
                format += ")"                        
            case ast.ExpressionTypeQuestion: 
                q := e.data.(ast.ExpressionQuestion)
                format = indent 
                format += this.formatExpression("" , q.selection)  
                format += "?"
                format += this.formatExpression("" , q.True) 
                format += ":"
                format += this.formatExpression("" , q.False)                              
            case ast.ExpressionTypeGlobal:                  
                return indent + "global"               
            case ast.ExpressionTypeParenthesis : 
                return indent + "(" + this.formatExpression("" , e.data.(ast.Expression)) + ")"                                
            case ast.ExpressionTypeVArgs:   
                return      indent + this.formatExpression("" , e.data.(ast.Expression)) + "..."                            
            case ast.ExpressionTypeDot:   
                return indent + "."
            default:
                panic("not possible")                           
        }
    }







}















