import "lucy/cmd/langtools/compile/ast"
import "lucy/cmd/langtools/ide"
import "lucy/os"
import "java/lang/Object"
import "java/lang/Boolean"
import "java/lang/Long"
import "java/lang/Double"


class AllDefinition {
    lucyFiles []ide.LucyFile
    packageName string
    printErr bool
    lucyPath string
    fn AllDefinition(lucyFiles []ide.LucyFile , packageName string , lucyPath string , printErr bool) {
        this.super()
        this.lucyFiles = lucyFiles
        this.lucyPath = lucyPath 
        this.packageName = packageName
        this.printErr = printErr
    }
    
    fn getAllDefinition() -> (alldefinition Object){
        nodes , errs := ide.parseAst(this.lucyFiles)
        if this.printErr {
            for v := range errs{
                os.stderr.println(v.getMessage())
            }
        }
        p := new ast.Package(this.packageName , true)
        p.onlyAnalyzeGlobals = true // make the process faster
        errs = p.typeCheck(nodes)
        if this.printErr {
            for v := range errs{
                os.stderr.println(v.getMessage())
            }
        }
        return this.mkResult(p)
    }
    
    fn mkResult(p ast.Package) ->(result map{string -> Object} = new map{string -> Object}()) {
        result["package"] = this.packageName
        result["LUCYPATH"] = this.lucyPath
        vs := new map{string -> Object}()
        result["variables"] = vs
        for _ , v := range p.block.variables {
            vv := new map{string -> Object}()
            vv["pos"] = v.pos
            vv["type"] = v.Type.typeString()
            vs[v.name] = vv
        }
        cs := new map{string -> Object}()
        result["constants"] = cs
        for _ , v := range p.block.constants {
            vv := new map{string -> Object}()
            vv["pos"] = v.pos
            vv["type"] = v.Type.typeString()
            cs[v.name] = vv
        }
        fs := new map{string -> Object}()
        result["functions"] = fs
        for _ , v := range p.block.functions {
            vv := new map{string -> Object}()
            vv["pos"] = v.pos
            vv["definition"] = v.readableMsg() 
            fs[v.name] = vv
        }
        es := new map{string -> Object}()
        result["enums"] = es
        for name , v := range p.block.enums {
            vv := new map{string -> Object}()
            vv["pos"] = v.pos
            es[name] = vv
            enumConsts := new Object[](len(v.enums))
            vv["enums"] = enumConsts
            for kk , vv := range v.enums {
                vvv := new map{string -> Object}()
                vvv["pos"] = vv.pos
                vvv["value"] = this.packLong(long(vv.value))
                vvv["name"] = vv.name 
                enumConsts[kk] = vvv
            }
        }
        classes := new map{string -> Object}()
        result["classes"] = classes
        for name , v := range p.block.Classes {
            vv := new map{string -> Object}()
            vv["pos"] = v.pos
            fs := new map{string -> Object} ()
            vv["fileds"] = fs 
            for _ , f := range v.fields{
                ff := new map{string -> Object} ()
                ff["pos"] = f.pos 
                ff["type"] = f.Type.typeString()
                fs[f.name] = ff 
            }
            ms := new map{string -> Object} ()
            vv["methods"] = ms
            for _ , vv := range v.methods {
                m := vv[0]
                if m.isCompilerAuto {
                    continue  
                }
                mm := new map{string -> Object} ()
                mm["pos"] = m.Function.pos 
                mm["type"] = m.Function.readableMsg()
                ms[m.Function.name] = mm 
            }
            classes[name] = vv
        }
    }
    
    fn packBool(v bool) -> (o Boolean = Boolean.valueOf(v)) { }
    fn packLong(v long) -> (o Long = Long.valueOf(v)) { }
    fn packDouble(v double) -> (o Double = Double.valueOf(v)) { }


}









