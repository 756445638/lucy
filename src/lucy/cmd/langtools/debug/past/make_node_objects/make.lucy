import "java/lang/Object"
import "lucy/cmd/langtools/compile/ast"


class MakeNodesObjects {

    



    
    fn Make(files map { string-> []ast.TopNode } ) -> (x Object) {
        if len(files) == 1 {
            for _, v := range files {
                return this.MakeNodes(v)
            }
        }
        ret := new map{string -> Object}()
        for k, v := range files {
            ret[k] = this.MakeNodes(v)
        }
        return ret

    }

    fn MakeNodes(nodes []ast.TopNode) -> (ret []Object = []Object{}) {
        for _, n := range nodes {
            if t,ok := n.Node.(ast.Block) ; ok {
                ss := this.makeBlock(t)
                ret.append({"block"-> ss})
            }
            if t,ok := n.Node.(ast.Function) ; ok {
                ret.append(this.makeFunction(t))
            }
            if t,ok := n.Node.(ast.Enum) ; ok {
                ret.append(this.makeEnum(t))
            }
            if t,ok := n.Node.(ast.Class) ; ok {
                ret.append(this.makeClass(t))
            }
            if t,ok := n.Node.(ast.Constant) ; ok {
                ret.append(this.makeConst(t))
            }
            if t,ok := n.Node.(ast.Import) ; ok {
                ret.append(this.makeImport(t))
            }
            if t,ok := n.Node.(ast.Expression) ; ok {
               ret.append(this.makeExpression(t))
            }
            if t,ok := n.Node.(ast.TypeAlias) ; ok {
               ret.append( this.makeTypeAlias(t))
            }
         
        }
        return ret
    }

    fn makeConst(c ast.Constant) -> (x Object) {
        s := sprintf("const%d %s", c.Pos.line, c.name)
        if c.Type != null {
            s += sprintf(" base on '%s'", c.Type.TypeString())
        }
        var ret []Object
        ret.append( s)
        ret.append({"init"-> this.makeExpression(c.defaultValueExpression)})
        return null
    }
    fn makeImport(i ast.Import) -> (x Object) {
        s := sprintf("import@%d", i.pos.line)
        s += sprintf(" '%s'", i.Import)
        if i.accessName != "" {
            s += sprintf(" as '%s'", i.accessName)
        }
        return s
    }
    fn makeFunction(f ast.Function) -> (x Object) {
        ret := new map{string -> Object}()
        {
            if len(f.Type.parameterList) == 1 {
                for _, v := range f.Type.parameterList {
                    p := new map{string->Object}()
                    p["name"] = v.name
                    p["type"] = v.Type.typeString()
                    if v.defaultValueExpression != null {
                        p["defaultValue"] = this.makeExpression(v.defaultValueExpression)
                    }
                    ret["parameterlist"] = p
                }
            } else {
                var t []Object
                for _, v := range f.Type.parameterList {
                    p := new map{string->Object}()
                    p["name"] = v.name
                    p["type"] = v.Type.typeString()
                    if v.defaultValueExpression != null {
                        p["defaultValue"] = this.makeExpression(v.defaultValueExpression)
                    }
                    t.append( p)
                }
                ret["parameterlist"] = t
            }
        }
        if f.Type.VoidReturn() == false {
            if len(f.Type.parameterList) == 1 {
                for _, v := range f.Type.returnList {
                    p := new map{string->Object}()
                    p["name"] = v.name
                    p["type"] = v.Type.typeString()
                    if v.defaultValueExpression != null {
                        p["defaultValue"] = this.makeExpression(v.defaultValueExpression)
                    }
                    ret["returnlist"] = p
                }
            } else {
                var t []Object
                for _, v := range f.Type.returnList {
                    p := new map{string->Object}()
                    p["name"] = v.name
                    p["type"] = v.Type.typeString()
                    if v.defaultValueExpression != null {
                        p["defaultValue"] = this.makeExpression(v.defaultValueExpression)
                    }
                    t.append( p)
                }
                ret["returnlist"] = t
            }
        } else {
            ret["returnlist"] = null
        }
        ret["block"] = this.makeBlock(f.block)
        return {
            sprintf("fn@%d '%s'", f.pos.line, f.name) -> ret,
        }
    }

    fn makeEnum(e ast.Enum) ->(x Object)  {
        ret := new map{string -> Object}()
        {
            var t []Object
            for _, v := range e.enums {
                en := new map{string -> Object}()
                en["name"] = v.name
                if v.NoNeed != null {
                    en["value"] = this.makeExpression(v.NoNeed)
                }
                t.append( en)
            }
            ret["enums"] = t
        }
        return {
            sprintf("enum@%d '%s'", e.pos.line, e.name)-> ret,
        }
    }

    fn makeClass(c ast.Class) ->(x Object) {
        ret := new map{string -> Object}()
        ret["name"] = c.name
        ret["accessFlags"] = c.AccessFlags
        if c.SuperClassName != null {
            ret["superClass"] = c.SuperClassName.name
        }
        if len(c.InterfaceNames) > 0 {
            var t []Object
            for _, v := range c.InterfaceNames {
                t.append( v.name)
            }
            ret["interfaces"] = t
        }

        if len(c.Block.Constants) > 0 {
            var t []Object
            for _, v := range c.Block.Constants {
                t.append( this.makeConst(v))
            }
            ret["constants"] = t
        }
        if len(c.Fields) > 0 {
            fields := new map{string -> Object}()
            for _, v := range c.Fields {
                f := new map{string -> Object}()
                f["accessFlags"] = v.AccessFlags
                f["name"] = v.name
                f["type"] = v.Type.typeString()
                if v.defaultValueExpression != null {
                    f["defaultValue"] = this.makeExpression(v.defaultValueExpression)
                }
                fields[v.name] = f
            }
            ret["fields"] = fields
        }
        if len(c.StaticBlocks) > 0 {
            var t []Object
            for _, v := range c.StaticBlocks {
                t.append( this.makeBlock(v))
            }
            ret["staticBlocks"] = t
        }
        if len(c.Methods) > 0 {
            methods := new map{string -> Object}()
            for name, ms := range c.Methods {
                if len(ms) != 1 {
                    var t []Object
                    for _, method := range ms {
                        m := new map{string -> Object}()
                        m["accessFlags"] = method.Function.AccessFlags
                        m["function"] = this.makeFunction(method.Function)
                        t.append( m)
                    }
                    methods[name] = t
                } else {
                    method := ms[0]
                    m := new map{string -> Object}()
                    m["accessFlags"] = method.Function.AccessFlags
                    m["function"] = this.makeFunction(method.Function)
                    methods[name] = m
                }

            }
            ret["methods"] = methods
        }
        return {
            sprintf("class@%d '%s'", c.pos.line, c.name)-> ret,
        }
    }

    fn makeTypeAlias(a ast.TypeAlias) ->(x Object) {
        s := sprintf("typealias@%d '%s' base on '%s'", a.pos.line, a.name, a.Type.TypeString())
        return s
    }
    fn makeBlock(b ast.Block) ->(x Object) {
        var ret []Object
        for _, s := range b.statements {
            ret.append( this.makeStatement(s))
        }
        return ret
    }
    fn makeStatementIf(s ast.StatementIf) ->(x Object) {
        ret := new map{string -> Object}()
        if len(s.prefixExpressions) > 0 {
            var t []Object
            for _, v := range s.prefixExpressions {
                t.append( this.makeExpression(v))
            }
            ret["prefixExpressions"] = t
        }
        if s.Condition != null {
            ret["condition"] = this.makeExpression(s.Condition)
        }
        ret["block"] = this.makeBlock(s.Block)
        if len(s.ElseIfList) > 0 {
            var t []Object
            for _, v := range s.ElseIfList {
                t.append( {
                    "condition" -> this.makeExpression(v.Condition),
                    "block" ->     this.makeBlock(v.Block),
                })
            }
            ret["elseifList"] = t
        }
        if s.Else != null {
            ret["else"] = this.makeBlock(s.Else)
        }
        return {
            sprintf("if@%d", s.pos.line) -> ret,
        }
    }
    fn makeStatementFor(s ast.StatementFor) ->(x Object) {
        ret := new map{string -> Object}()
        if s.Init != null {
            ret["init"] = this.makeExpression(s.Init)
        }
        if s.Condition != null {
            ret["condition"] = this.makeExpression(s.Condition)
        }
        if s.Increment != null {
            ret["increment"] = this.makeExpression(s.Increment)
        }
        ret["block"] = this.makeBlock(s.Block)
        return  {
            sprintf("for@%d", s.pos.line) -> ret,
        }
    }
    fn makeStatementSwitch(s ast.StatementSwitch) ->(x Object) {
        ret := new map{string -> Object}()
        if len(s.prefixExpressions) > 0 {
            var t []Object
            for _, v := range s.prefixExpressions {
                t.append( this.makeExpression(v))
            }
            ret["prefixExpressions"] = t
        }
        if s.Condition != null {
            ret["condition"] = this.makeExpression(s.Condition)
        }
        if len(s.StatementSwitchCases) > 0 {
            var cases []Object
            for _, v := range s.StatementSwitchCases {
                onecase := new map{string -> Object}()
                var conditions []Object
                for _, vv := range v.Matches {
                    conditions = append(conditions, this.makeExpression(vv))
                }
                onecase["conditions"] = conditions
                onecase["block"] = this.makeBlock(v.Block)
                cases = append(cases, onecase)
            }
            ret["cases"] = cases
        }
        if s.Default != null {
            ret["block"] = this.makeBlock(s.Default)
        }
        return  {
            sprintf("switch@%d", s.pos.line) -> ret,
        }
    }
    fn makeStatementWhen(w ast.StatementWhen) ->(x Object) {
        ret := new map{string -> Object}()
        if w.Condition != null {
            ret["condition"] = w.Condition.typeString()
        }
        if len(w.Cases) > 0 {
            var cases []Object
            for _, v := range w.Cases {
                onecase := new map{string -> Object}()
                var conditions []Object
                for _, vv := range v.Matches {
                    conditions = append(conditions, vv.TypeString())
                }
                onecase["conditions"] = conditions
                onecase["block"] = this.makeBlock(v.Block)
                cases = append(cases, onecase)
            }
            ret["cases"] = cases
        }
        if w.Default != null {
            ret["block"] = this.makeBlock(w.Default)
        }
        return  {
            sprintf("when%d", w.pos.line)-> ret,
        }
    }

    fn makeStatementLabel(label ast.StatementLabel) ->(x Object) {
        return sprintf("label@%d '%s'", label.pos.line, label.name)
    }
    fn makeStatementGoto(g ast.StatementGoTo) ->(x Object) {
        return sprintf("goto@%d '%s'", g.pos.line, g.labelName)
    }

    fn makeStatementDefer(d ast.StatementDefer) ->(x Object) {
        return  {
            sprintf("defer%d", d.pos.line) -> this.makeBlock(d.Block),
        }
    }
    fn makeStatement(s ast.Statement) ->(x Object) {
        switch s.Type {
        case ast.StatementTypeExpression:
            return  {
                sprintf("statementExpression@%d", s.pos.line) ->  this.makeExpression(s.Expression),
            }
        case ast.StatementTypeIf:
            return this.makeStatementIf(s.StatementIf)
        case ast.StatementTypeBlock:
            return  {
                "block" ->  this.makeBlock(s.Block),
            }
        case ast.StatementTypeFor:
            return this.makeStatementFor(s.StatementFor)
        case ast.StatementTypeContinue:
            return sprintf("continue@%d", s.pos.line)
        case ast.StatementTypeReturn:
            if len(s.StatementReturn.Expressions) == 0 {
                return sprintf("return@%d", s.pos.line)
            } else {
                key := sprintf("return@%d", s.pos.line)
                ret := new map{string -> Object}()
                if len(s.StatementReturn.Expressions) == 1 {
                    ret[key] = this.makeExpression(s.StatementReturn.Expressions[0])
                } else {
                    var t []Object
                    for _, v := range s.StatementReturn.Expressions {
                        t.append( this.makeExpression(v))
                    }
                    ret[key] = t
                }
                return ret
            }
        case ast.StatementTypeBreak:
            return sprintf("break@%d", s.pos.line)
        case ast.StatementTypeSwitch:
            return this.makeStatementSwitch(s.StatementSwitch)
        case ast.StatementTypeWhen:
            return this.makeStatementWhen(s.StatementWhen)
        case ast.StatementTypeLabel:
            return this.makeStatementLabel(s.StatementLabel)
        case ast.StatementTypeGoTo:
            return this.makeStatementGoto(s.StatementGoTo)
        case ast.StatementTypeDefer:
            return this.makeStatementDefer(s.Defer)
        case ast.StatementTypeClass:
            return this.makeClass(s.Class)
        case ast.StatementTypeEnum:
            return this.makeEnum(s.Enum)
        case ast.StatementTypeNop:
            return sprintf("nop")
        case ast.StatementTypeImport:
            return this.makeImport(s.Import)
        case ast.StatementTypeTypeAlias:
            return this.makeTypeAlias(s.TypeAlias)
        }
        return null
    }

    fn makeExpression(e ast.Expression) ->(x Object) {
        if e == null {
            return fmt.Errorf("EXPRESSION IS NULL")
        }
        switch e.Type {
        case ast.ExpressionTypeNull:
            return "null"
        case ast.ExpressionTypeBool:
            fallthrough
        case ast.ExpressionTypeByte:
            fallthrough
        case ast.ExpressionTypeShort:
            fallthrough
        case ast.ExpressionTypeChar:
            fallthrough
        case ast.ExpressionTypeInt:
            fallthrough
        case ast.ExpressionTypeLong:
            fallthrough
        case ast.ExpressionTypeFloat:
            fallthrough
        case ast.ExpressionTypeDouble:
            return e.Data
        case ast.ExpressionTypeString:
            return sprintf(`literal string@%d "%s"`, e.pos.line, e.data.(string))
        case ast.ExpressionTypeArray:
            array := e.data.(ast.ExpressionArray)
            ret := new map{string -> Object}()
            ret["op"] = e.op

            if array.Type != null {
                ret["type"] = array.Type.typeString()
            }
            var t []Object
            for _, v := range array.Expressions {
                t.append( this.makeExpression(v))
            }
            ret["elements"] = t
            return ret
        case ast.ExpressionTypeLogicalOr:
            fallthrough
        case ast.ExpressionTypeLogicalAnd:
            fallthrough
        case ast.ExpressionTypeOr:
            fallthrough
        case ast.ExpressionTypeAnd:
            fallthrough
        case ast.ExpressionTypeXor:
            fallthrough
        case ast.ExpressionTypeLsh:
            fallthrough
        case ast.ExpressionTypeRsh:
            fallthrough
        case ast.ExpressionTypeAdd:
            fallthrough
        case ast.ExpressionTypeSub:
            fallthrough
        case ast.ExpressionTypeMul:
            fallthrough
        case ast.ExpressionTypeDiv:
            fallthrough
        case ast.ExpressionTypeMod:
            fallthrough
        case ast.ExpressionTypeEq:
            fallthrough
        case ast.ExpressionTypeNe:
            fallthrough
        case ast.ExpressionTypeGe:
            fallthrough
        case ast.ExpressionTypeGt:
            fallthrough
        case ast.ExpressionTypeLe:
            fallthrough
        case ast.ExpressionTypeLt:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            bin := e.data.(ast.ExpressionBinary)
            ret["left"] = this.makeExpression(bin.Left)
            ret["right"] = this.makeExpression(bin.Right)
            return ret
        case ast.ExpressionTypeAssign:
            fallthrough
        case ast.ExpressionTypeVarAssign:
            fallthrough
        case ast.ExpressionTypePlusAssign:
            fallthrough
        case ast.ExpressionTypeMinusAssign:
            fallthrough
        case ast.ExpressionTypeMulAssign:
            fallthrough
        case ast.ExpressionTypeDivAssign:
            fallthrough
        case ast.ExpressionTypeModAssign:
            fallthrough
        case ast.ExpressionTypeAndAssign:
            fallthrough
        case ast.ExpressionTypeOrAssign:
            fallthrough
        case ast.ExpressionTypeXorAssign:
            fallthrough
        case ast.ExpressionTypeLshAssign:
            fallthrough
        case ast.ExpressionTypeRshAssign:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            bin := e.data.(ast.ExpressionBinary)
            if bin.Left.Type == ast.ExpressionTypeList {
                var t []Object
                for _, v := range bin.Left.Data.([]ast.Expression) {
                    t.append( this.makeExpression(v))
                }
                ret["left"] = t
            } else {
                ret["left"] = this.makeExpression(bin.Left)
            }
            ret["right"] = this.makeExpression(bin.Right)
            return ret
        case ast.ExpressionTypeIndex:
            index := e.data.(ast.ExpressionIndex)
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(index.Expression)
            ret["index"] = this.makeExpression(index.Index)
            return ret
        case ast.ExpressionTypeSelection:
            selection := e.data.(ast.ExpressionSelection)
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(selection.Expression)
            ret["index"] = selection.name
            return ret
        case ast.ExpressionTypeSelectionConst:
            selection := e.data.(ast.ExpressionSelection)
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(selection.Expression)
            ret["index"] = selection.name
            return ret
        case ast.ExpressionTypeMethodCall:
            call := e.data.(ast.ExpressionMethodCall)
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["name"] = call.name
            ret["on"] = this.makeExpression(call.Expression)
            if len(call.Args) > 0 {
                var t []Object
                for _, v := range call.Args {
                    t.append( this.makeExpression(v))
                }
                ret["args"] = t
            }
            if len(call.ParameterTypes) > 0 {
                var t []Object
                for _, v := range call.ParameterTypes {
                    t.append( v.TypeString())
                }
                ret["parameterTypes"] = t
            }
            return ret
        case ast.ExpressionTypeFunctionCall:
            call := e.data.(ast.ExpressionFunctionCall)
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(call.Expression)
            if len(call.Args) > 0 {
                var t []Object
                for _, v := range call.Args {
                    t.append( this.makeExpression(v))
                }
                ret["args"] = t
            }
            if len(call.ParameterTypes) > 0 {
                var t []Object
                for _, v := range call.ParameterTypes {
                    t.append( v.TypeString())
                }
                ret["parameterTypes"] = t
            }
            return ret
        case ast.ExpressionTypeIncrement:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(e.data.(ast.Expression))
            return ret
        case ast.ExpressionTypeDecrement:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(e.data.(ast.Expression))
            return ret
        case ast.ExpressionTypePrefixIncrement:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(e.data.(ast.Expression))
            return ret
        case ast.ExpressionTypePrefixDecrement:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(e.data.(ast.Expression))
            return ret
        case ast.ExpressionTypeNegative:
            fallthrough
        case ast.ExpressionTypeNot:
            fallthrough
        case ast.ExpressionTypeBitwiseNot:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(e.data.(ast.Expression))
            return ret
        case ast.ExpressionTypeIdentifier:
            return e.data.(ast.ExpressionIdentifier).name
        case ast.ExpressionTypeNew:
            n := e.data.(ast.ExpressionNew)
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["type"] = n.Type.typeString()
            {
                var t []Object
                for _, v := range n.Args {
                    t.append( this.makeExpression(v))
                }
                ret["args"] = t
            }
            return ret
        case ast.ExpressionTypeList:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            list := e.data.([]ast.Expression)
            if len(list) == 1 {
                return this.makeExpression(list[0])
            }
            var t []Object
            for _, v := range list {
                t.append( this.makeExpression(v))
            }
            ret["list"] = t

            return ret
        case ast.ExpressionTypeFunctionLiteral:
            return this.makeFunction(e.data.(ast.Function))
        case ast.ExpressionTypeVar:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            v := e.data.(ast.ExpressionVar)
            if v.Type != null {
                ret["type"] = v.Type.typeString()
            }
            {
                var t []Object
                for _, vv := range v.variables {
                    t.append( vv.name)
                }
                ret["variables"] = t
            }
            if len(v.InitValues) > 0 {
                var t []Object
                for _, vv := range v.InitValues {
                    t.append( this.makeExpression(vv))
                }
                ret["initValues"] = t
            }
            return ret
        case ast.ExpressionTypeConst:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            {
                var t []Object
                for _, v := range e.data.([]ast.Constant) {
                    m := new map{string -> Object}()
                    m["name"] = v.name
                    if v.Type != null {
                        m["type"] = v.Type.typeString()
                    }
                    if v.defaultValueExpression != null {
                        m["defaultValue"] = this.makeExpression(v.defaultValueExpression)
                    }
                    t.append( m)
                }
                ret["constants"] = t
            }
            return ret
        case ast.ExpressionTypeCheckCast:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            cast := e.data.(ast.ExpressionTypeConversion)
            ret["expression"] = this.makeExpression(cast.Expression)
            ret["type"] = cast.Type.typeString()
            return ret
        case ast.ExpressionTypeRange:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            ret["on"] = this.makeExpression(e.data.(ast.Expression))
            return ret
        case ast.ExpressionTypeSlice:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            slice := e.data.(ast.ExpressionSlice)
            ret["expression"] = this.makeExpression(slice.ExpressionOn)
            if slice.Start != null {
                ret["start"] = this.makeExpression(slice.Start)
            }
            if slice.End != null {
                ret["end"] = this.makeExpression(slice.Start)
            }
            return ret
        case ast.ExpressionTypeMap:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            m := e.data.(ast.ExpressionMap)
            if m.Type != null {
                ret["type"] = m.Type.typeString()
            }
            {
                var t []Object
                for _, v := range m.KeyValuePairs {
                    tt := new map{string -> Object}()
                    tt["key"] = this.makeExpression(v.Key)
                    tt["value"] = this.makeExpression(v.Value)
                    t.append( tt)
                }
                ret["paris"] = t
            }
        case ast.ExpressionTypeTypeAssert:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            cast := e.data.(ast.ExpressionTypeAssert)
            ret["expression"] = this.makeExpression(cast.Expression)
            ret["type"] = cast.Type.typeString()
            return ret
        case ast.ExpressionTypeQuestion:
            ret := new map{string -> Object}()
            ret["op"] = e.op
            q := e.data.(ast.ExpressionQuestion)
            ret["selection"] = this.makeExpression(q.selection)
            ret["true"] = this.makeExpression(q.True)
            ret["false"] = this.makeExpression(q.False)
            return ret
        case ast.ExpressionTypeGlobal:
            return e.op // should be "global"
        case ast.ExpressionTypeParenthesis:
            return {
                "()"->  this.makeExpression(e.data.(ast.Expression)),
            }
        case ast.ExpressionTypeVArgs:
            return {
                "..." -> this.makeExpression(e.data.(ast.Expression)),
            }
        case ast.ExpressionTypeDot:
            return "."
        }
        return null
    }







}

