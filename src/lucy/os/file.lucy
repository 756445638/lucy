import "java/io";
import "lucy/lang";



fileModelIsEmptyErr := new lang.Error("file model is empty");
createFileFailErr := new lang.Error("create file failed");
var fileNotExistsErr lang.Error = new lang.Error("file not exists");
var notAFile lang.Error = new lang.Error("file is not a regular file");


public class File extends io.File {
	reader io.FileInputStream;
	writer io.FileOutputStream;

	public fn File(filepath string ,model string = "r"){
		this.super(filepath);
		if model == null || model == ""{
			panic(fileModelIsEmptyErr);
		}
		isCreate := false;
		for k,v := range []byte(model){
			if v == 'r' && this.reader == null{
				this.reader = new io.FileInputStream(this);
			}
			if v == 'w' && this.writer == null{
				this.writer = new io.FileOutputStream(this);
			}
			if v == 'c'{
				isCreate = true;
			}
		}
		if isCreate &&  this.exists() == false{
			if false == this.createNewFile(){
				panic(createFileFailErr);
			}
		}
	}


	public fn read(bs []byte)->(n int){
		n = this.reader.read(bs.toJavaArray()); 
	}
	
	public fn close(){
		if this.reader != null {
			this.reader.close();
		}
		if this.writer != null {
			this.writer.close();
		}
	}

	public static fn readFile(filepath string)->(bs []byte,err lang.Error){
		file := new File(filepath);
		bs = new []byte(0);
		reader := new io.FileInputStream(file);
		defer reader.close();
		b := new []byte(1 << 10);
		var n int;
		for n != -1 {
			n = reader.read(b.toJavaArray());
			if n != -1 {
				bs.appendAll(b[0:n]);
			}
		}
	}
	
	public static fn writeFile( filepath string ,bs []byte){
		writer := new io.FileOutputStream(new io.File(filepath));
		defer writer.close();
		writer.write(bs.toJavaArray());
	}
	
	
	/*
	create directory
	*/
	public static fn mkDir(path string)->(ok bool){
		f := new io.File(path);
		ok = f.mkdirs();
	}

	/*
		delete a directory
		ok means if delete is ok
	*/
	public static fn removeDir(path string)->(ok bool){
		f := new io.File(path);
		ok = f.delete();
	}
	

	public fn listDir()->(fis []File){
		
	}
	

}