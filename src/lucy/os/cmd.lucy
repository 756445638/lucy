
import "java/io/InputStream"
import "java/io/OutputStream"
import "lucy/io"
import "java/lang/Process"
import "java/lang/Runtime"
import "java/io/File"

public class Command{
	cmd string  
	args string []  
	envs string [] 
	file File 
	public stdin  InputStream
	public stdout , stderr  OutputStream 
	p Process
	
	public fn Command(cmd string , args  , envs string []   ,file File  ){
		this.super()
		this.cmd = cmd
		this.args = args
		this.envs = envs
		this.file = file  
	}
	public fn destroy() {
		this.p.destroy()
	}

	public fn getProcess() -> (p Process  = this.p ) { }
	
	public fn startCatchError() -> (err error){
		defer {
			err = catch()
		}
		this.start() 
	}
	
	public fn start()  {
		if this.cmd == null || this.cmd == "" {
			panic(new error("cmd is not set")) 
		} 
		if this.file != null  {
			if this.envs == null {
				this.envs = new string [] (0) 
			}
			if this.args == null {
				this.args = new string [] (0)  
			}
		}
		if this.envs != null {
			if this.args == null {
				this.args = new string [] (0)  
			}
		}
		// start process
		if this.file != null {
			this.p = Runtime.getRuntime().exec(this.mkCmdArray(), this.envs , this.file)
		}else if this.envs != null {
			this.p = Runtime.getRuntime().exec(this.mkCmdArray(), this.envs )
		}else if this.args != null {
			this.p = Runtime.getRuntime().exec(this.mkCmdArray())
		}else {
			this.p = Runtime.getRuntime().exec(this.cmd)
		}
		// copy io 
		var that = this
		if this.stdin != null {
			Run.runFn(fn () {
			    io.ioCopy(  that.p.getOutputStream() , that.stdin )
			})
		}
		if this.stdout != null {
			Run.runFn(fn () {
			    io.ioCopy(that.stdout , that.p.getInputStream())
			})
		}
		if this.stderr != null {
			Run.runFn(fn () {
			    io.ioCopy(that.stderr , that.p.getErrorStream()  )
			})
		}

	}
	private fn mkCmdArray() -> (arr string[]) {
		arr  = new string[] (1 + this.args.size())  
		arr[0] = this.cmd
		for k,v := range this.args {
			arr[k + 1] = v 
		}
	}

	public fn wait() -> (err error){
		if code := this.p.waitFor() ; code != 0 {
			err = new error("errcode:" + code )
		}
	}
	
}






















