
/*
	a simple but yet powerful args parse for lucy programing
*/
public final class  FlagParser {
	options map{ string -> Option };
	
	public fn FlagParser() {
	    this.super()
		this.options = new map{string -> Option}()
	}
	
	
	
	public fn boolOption(name string , d bool ,usage string ) ->(o BoolOption){
		if this.options.keyExist(name)  {
			panic(new error(sprintf("name already '%s' exists" , name )))
		}
		if name.startsWith("-") == false {
			panic(new error(sprintf("'%s' not a valid option" , name )))
		}
		o = new BoolOption(d)
		o.typ = OptionTypeBool
		o.usage = usage
		this.options[name] = o
	} 
	
	public fn intOption(name string , d int ,usage string ) ->(o IntOption){
		if this.options.keyExist(name)  {
			panic(new error(sprintf("name already '%s' exists" , name )))
		}
		if name.startsWith("-") == false {
			panic(new error(sprintf("'%s' not a valid option" , name )))
		}
		o = new IntOption(d);
		o.typ = OptionTypeInt
		o.usage = usage 
		this.options[name] = o
	} 
	
	public fn stringOption(name string , d string ,usage string ) ->(o StringOption){
		if this.options.keyExist(name)  {
			panic(new error(sprintf("name already '%s' exists" , name )))
		}
		if name.startsWith("-") == false {
			panic(new error(sprintf("'%s' not a valid option" , name )))
		}
		o = new StringOption(d);
		o.typ = OptionTypeString
		o.usage = usage 
		this.options[name] = o
	}

	public fn floatOption(name string , d float ,usage string ) ->(o FloatOption){
		if this.options.keyExist(name)  {
			panic(new error(sprintf("name already '%s' exists" , name )))
		}
		if name.startsWith("-") == false {
			panic(new error(sprintf("'%s' not a valid option" , name )))
		}
		o = new FloatOption(d);
		o.typ = OptionTypeFloat
		o.usage = usage 
		this.options[name] = o
	} 
	
	
	
	public fn parse(args []string)->(noDefine []string , err error){
		for v := range this.options{
			v.reset()
		}
		noDefine = []string{} 
		for k := 0 ; k < len (args) ; k++{
			v := args[k]
			if false == this.options.keyExist(v) {
				noDefine.append(v)
				continue
			}
			o := this.options[v]
			if o.typ == OptionTypeBool {
				o.parse(v)
			}else {
				if k == len(args) -1 {
						err = new error(sprintf("no value  after '%s'" , v ))
						return 
				}
				err = o.parse(args[++k])
				if err != null {
					return 
				}
			}
			
		}
	}
	/*
	private fn parseInt(s string)->(value int, err error) {
		
	}
	
	private fn parseFloat(s string)->(value float, err error) {
		
	}
	*/
	public fn helpMsg() -> (msg string){
		msg = "flag are:\n"
		for k,v := range this.options {
			msg += sprintf("\t '%s' default:'%s' usage:'%s'\n" , k , v.formatDefaultValue() , v.usage )
		}
	}

} 




















