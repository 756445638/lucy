// all rights reserved , check the LICENSE file


import "java/lang/reflect/Array"
import "java/lang/Object"



public class ArrayBool   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements bool[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayBool(values bool[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value bool) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t bool){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayBool){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayBool(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e bool){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayBool){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = bool[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}


public class ArrayByte   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements byte[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayByte(values byte[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value byte) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t byte){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayByte){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayByte(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e byte){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayByte){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = byte[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}


public class ArrayShort   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements short[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayShort(values short[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value short) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t short){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayShort){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayShort(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e short){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayShort){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = short[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}


public class ArrayChar   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements char[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayChar(values char[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value char) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t char){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayChar){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayChar(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e char){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayChar){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = char[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}


public class ArrayInt   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements int[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayInt(values int[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value int) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t int){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayInt){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayInt(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e int){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayInt){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = int[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}


public class ArrayLong   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements long[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayLong(values long[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value long) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t long){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayLong){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayLong(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e long){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayLong){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = long[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}


public class ArrayFloat   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements float[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayFloat(values float[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value float) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t float){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayFloat){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayFloat(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e float){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayFloat){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = float[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}


public class ArrayDouble   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements double[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayDouble(values double[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value double) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t double){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayDouble){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayDouble(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e double){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayDouble){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = double[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}


public class ArrayObject   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements Object[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayObject(values Object[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value Object) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t Object){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayObject){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayObject(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e Object){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayObject){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = Object[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}


public class ArrayString   {
	public start ,end ,cap int 
	const outOfRangeMsg = "index out range"
	public elements string[]

	public synchronized fn size() -> (s int){
		return this.end - this.start
	}
	public fn ArrayString(values string[]){
		this.super()
		if values != null {
			this.start = 0
			this.end = values.size()
			this.cap = values.size()
			this.elements = values
		}
	}

	public synchronized fn set(index int  , value string) {
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		this.elements[index] = value
	}

	public synchronized fn get(index int) -> (t string){
		if index < 0 {
			panic(outOfRangeMsg)
		}
		index += this.start 
		if index >= this.end {
			panic(outOfRangeMsg)
		}
		return this.elements[index] 
	}

	public  synchronized fn slice(start,end int) -> (result ArrayString){
		length := end - start 
		if start < 0 || length < 0 || (length + this.start + start) > this.end {
			panic(outOfRangeMsg)
		}
		result = new ArrayString(null)
		result.elements = this.elements
		result.start = this.start + start
		result.end = result.start + length
		result.cap = this.cap
	}

	public synchronized fn append(e string){
		if this.end < this.cap{
		}else{
			this.expand(this.cap * 2)
		}
		this.elements[this.end++] = e
	}
	public synchronized  fn appendAll(es ArrayString){
		if es == null{ //no need 
			return  ;
		}
		if this.end + es.size() < this.cap{
		}else {
			this.expand((this.cap + es.size()) * 2);
		}
		for i := 0;i < es.size();i++{
			this.elements[this.end + i] = es.elements[es.start + i ]
		}
		this.end += es.size()
	}
	private synchronized fn expand(cap int){
		if cap <= 0 {
		    cap = 10
		}
		c := Object(this.elements).getClass()
		typealias retType = string[]
		eles :=  retType(Array.newInstance(c.getComponentType() , cap ));
		length := this.size();
		for i := 0;i < length;i++{
			eles[i] = this.elements[i + this.start];
		}
		this.start = 0
		this.end = length
		this.cap = cap
		this.elements = eles
	}
	
	public synchronized fn toString() -> (ret string = "["){
	    size := this.end - this.start;
	    for i := 0;i < size;i++{
            ret += this.elements[this.start + i ] + "";
            if(i != size -1){
                ret += " ";
            }
	    }
	    ret += "]";
	}
}